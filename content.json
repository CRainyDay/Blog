{"meta":{"title":"CRainyDay","subtitle":null,"description":null,"author":"CRainyDay","url":"https://blog.crainyday.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-03-15T10:48:09.000Z","updated":"2019-10-06T09:47:10.000Z","comments":true,"path":"404.html","permalink":"https://blog.crainyday.com/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"About","date":"2019-03-15T11:10:09.000Z","updated":"2019-10-06T09:49:35.000Z","comments":true,"path":"about.html","permalink":"https://blog.crainyday.com/about.html","excerpt":"","text":"The road to success is not crowded, but too few people stick to it. 成功的道路其实并不拥挤, 只是坚持的人太少了! 欢迎你来”踩点”, 预祝你可以坚持到成功. 关于站长&emsp;&emsp;来自山东的天秤男, 目前还走在求学路上, 喜欢并享受着科技和网络带来的各种神奇和美好.&emsp;&emsp;其实, 我也不了解自己. 我也不知道, 自己到底在做什么, 到底喜欢什么. 也有一点迷茫, “到底从哪里来, 最后到哪里去”.&emsp;&emsp;希望你的到来, 能帮我真正了解自己. 关于本站&emsp;&emsp;欢迎来到CRainyDay’Blog! 如果你有什么想法、建议和意见, 欢迎随时告诉我, 很期待与你的交流! 本站文章, 可能存在错误, 欢迎指出. 本站大部分内容属于原创, 大部分为学习的笔记, 凡是本站发表的文章, 请在转载时注明原文出处为CRainyDay’Blog. 转载本站文章可修改内容, 但要保证文章的语义完整, 以免让读者误解作者真实意图. 修改内容需通知源作者.&emsp;&emsp;本站初建于2019年3月, 备用网站: &emsp;&emsp;&emsp;&emsp;https://blog.crainyday.com &emsp;&emsp;&emsp;&emsp;https://crainyday.gitee.io"},{"title":"所有分类","date":"2019-03-15T10:45:49.000Z","updated":"2019-10-06T09:47:57.000Z","comments":true,"path":"categories/index.html","permalink":"https://blog.crainyday.com/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-03-16T04:46:38.000Z","updated":"2019-10-06T11:25:42.000Z","comments":true,"path":"bbs/index.html","permalink":"https://blog.crainyday.com/bbs/index.html","excerpt":"","text":"没有什么想说的吗?留下点什么吧!!!定期更新优质留言. The road to success is not crowded, but too few people stick to it. 成功的道路其实并不拥挤, 只是坚持的人太少了! —————— CRainyDay 当你发现自己的能力hold不住野心时, 那就静下心来学习吧. —————— CRainyDay"},{"title":"My Friends","date":"2019-03-15T10:46:15.000Z","updated":"2019-10-06T11:20:30.000Z","comments":true,"path":"friends/index.html","permalink":"https://blog.crainyday.com/friends/index.html","excerpt":"","text":"背景音乐《You》, 这首歌曲名字之所以叫《You》, 相信很多人能听出歌曲里的情感, 平静孤寂的调子起头, 两个人分开之后的沉寂 颓废, 慢慢的音阶起伏, 我意识到不能这样下去, 我开始改变现状, 变得积极. 到高潮部分 我不在颓废, 我找到新的目标 我迎着太阳前进. 我想这就是You的含义, 你是我的一段过去. 欢迎互相加友链 名称： CRainyDay头像： https://cdn.jsdelivr.net/gh/crainyday/blog@master/avatar.png网址： https://crainyday.gitee.io标签： Java 前端"},{"title":"所有标签","date":"2019-03-15T10:46:02.000Z","updated":"2019-09-30T21:14:02.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.crainyday.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Ubuntu中py2与py3共存","slug":"Python","date":"2020-03-04T08:32:25.000Z","updated":"2020-03-04T13:10:05.789Z","comments":true,"path":"Python.html","link":"","permalink":"https://blog.crainyday.com/Python.html","excerpt":"&emsp;&emsp;在一些常见的 Linux 发行版本中, py2 都是系统默认自带的. 但我们往往需要py3, 有时也会用到 py2, 就像 宝塔面板和 yum 包管理器都是用的 py2. &emsp;&emsp;如何安装 py3, 并使其与 py2 共存?","text":"&emsp;&emsp;在一些常见的 Linux 发行版本中, py2 都是系统默认自带的. 但我们往往需要py3, 有时也会用到 py2, 就像 宝塔面板和 yum 包管理器都是用的 py2. &emsp;&emsp;如何安装 py3, 并使其与 py2 共存? 1.安装python3①直接安装12345# ubuntu中利用 apt 包管理器sudo apt-get install python3.7 # 或其他版本# CentOS中利用 yum 包管理器: 安装python3.7，pip3yum -y install python37uyum -y install python37u-pip 个人来说, 我不喜欢这样 :smile:. 更喜欢利用 wget 下载编译安装, 这样适用于大多 Linux 发行版本. ②下载编译安装步骤1：在python官网找到 python-3.7.1.tgz 的地址：https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz 步骤2：利用 wget 下载安装包. 123wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz# 下载后的文件默认会在当前所在文件夹ls # 查看下载的文件 步骤3：解压安装包. 12# 针对不同类型的文件利用不中的命令解压即可.tar -zxvf Python-3.7.1.tgz 步骤4：切换到解压后的目录下, configure. 1234cd Python-3.7.1./configure# 或者 利用 prefix 参数指定编译的时候用来存放程序的路径./configure --prefix=/usr/local/python3.7.1 步骤5：编译安装. 1make &amp;&amp; make install 2.将python3配置为全局命令 &emsp;&emsp;先请测试一下, python3当前是否已经是全局命令, 任意目录下: python3 -V. 若已经是全局命令, 只需进行 步骤③建立软连接 即可. ①找到python3的安装目录 &emsp;&emsp;一般可能会在 /usr/local/python3.x.x 中. 真不知道的用命令查找: 12find / -name python3*# 自己判断出python3的安装路径 ②配置环境变量 &emsp;&emsp;添加python3的安装目录(bin目录)到系统的 PATH 变量. 123456sudo vim /etc/profile# 在文件的最下方添加:export PYTHON3_HOME = /usr/local/python3.7.1export PATH = $PATH:$PYTHON3_HOME/bin# 或直接export PATH = $PATH:/usr/local/python3.7.1/bin &emsp;&emsp;保存编辑, 再次测试此时 python3 是否为全局变量. ③建立python3和pip3的软连接12ln -s /usr/local/python3.7.1/bin/python3.7 /usr/bin/python3ln -s /usr/local/python3.7.1/bin/pip3 /usr/bin/pip3 3.将python3改为系统默认(可以不改) &emsp;&emsp;注意: 有些软件默认使用了 python 命令, 而该命令默认为 python2. 若改变了系统默认的py, 可能有些软件不可用. 就像: 宝塔和 yum 等(需要修改它们的配置文件). 若想改, 只需改变 /usr/bin/python 的软链接即可. 123rm -f /usr/bin/pythonln -s /usr/local/python3.7.1/bin/python3.7 /usr/bin/python# 即可","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.crainyday.com/categories/Ubuntu/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.crainyday.com/tags/Python/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.crainyday.com/tags/Ubuntu/"},{"name":"CentOS","slug":"CentOS","permalink":"https://blog.crainyday.com/tags/CentOS/"}]},{"title":"CentOS7上部署Flash应用","slug":"Flask","date":"2020-03-04T01:55:25.000Z","updated":"2020-03-04T13:10:05.789Z","comments":true,"path":"Flask.html","link":"","permalink":"https://blog.crainyday.com/Flask.html","excerpt":"①安装python3(可以更改系统默认的python为python3) ②创建python虚拟环境(当然也可以直接用系统的python环境) ③部署项目到服务器 ④以development WSGI server方式直接运行项目 ⑤结合Nginx服务器用uWSGI部署 Flask","text":"①安装python3(可以更改系统默认的python为python3) ②创建python虚拟环境(当然也可以直接用系统的python环境) ③部署项目到服务器 ④以development WSGI server方式直接运行项目 ⑤结合Nginx服务器用uWSGI部署 Flask 1.在CentOS7上安装python3 详见: python2与python3共存 2.不使用python虚拟环境 &emsp;&emsp;若想使用python虚拟环境, 请看之后的内容. ①得到开发环境需要的依赖123# 在本地的 Flask 开发环境中 env 下执行:pip freeze&gt;requirements.txt ②pip3安装依赖12# 将 requirements.txt 上传到服务器, 执行:pip3 install -r requirements.txt ③上传项目并运行(确保端口开放) &emsp;&emsp;将 Flask 项目上传到 服务器, 测试运行. 这里直接在 /opt/project/hello.py 简单测试. 第一步: 新建 hello.py 文件, 注意: app.run(host=’0.0.0.0’), 否则外网无法访问. 123456789# hello.pyfrom flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run(host='0.0.0.0')# 默认为 0.0.0.0:5000 第二步: 运行 Flask 应用, hello.py 1python3 hello.py 第三步: 浏览器访问 http://你的服务器IP:端口号测试结果. 3.创建python虚拟环境 虚拟环境: &emsp;&emsp;建议在开发环境和生产环境下都使用虚拟环境来管理项目的依赖。 &emsp;&emsp;为什么要使用虚拟环境？随着你的 Python 项目越来越多，你会发现不同的项目会需要 不同的版本的 Python 库。同一个 Python 库的不同版本可能不兼容。 ①安装python虚拟环境12pip3 install virtualenvpip3 install virtualenvwrapper ②配置虚拟环境 &emsp;&emsp;一般用 pip 安装完后都是OK的, 可以直接使用. 若不能使用, 再来配置 python 虚拟环境. 编辑文件 vim ~/.bashrc, 在最后添加: 1234export WORKON_HOME=$HOME/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3# 可以使用find命令找出virtualenvwrapper.sh的路径source /usr/local/python3.7.1/bin/virtualenvwrapper.sh 执行 source ~/.bashrc 生效. 利用 find 找出 virtualenv 的路径, 一般会在 /usr/local/python3.x.x/bin/ 中. 1sudo find / -name \"virtualenv\" 建立 virtualenv 的软连接 1ln -s /usr/local/python3.7.1/bin/virtualenv /usr/bin/virtualenv ③创建 python 虚拟环境12# --python 指定python版本, wpwl-env为虚拟环境的名字.mkvirtualenv --python=/usr/bin/python3 wpwl-env 4.在虚拟环境中运行Flask①虚拟环境简单命令1234# 进入虚拟环境workon wpwl-env# 退出虚拟环境deactivate ②将项目打包放到服务器 &emsp;&emsp;这里直接在 /opt/project/hello.py 简单测试. 第一步: 新建 hello.py 文件, 注意: app.run(host=’0.0.0.0’), 否则外网无法访问. 123456789# hello.pyfrom flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run(host='0.0.0.0')# 默认为 0.0.0.0:5000 第二步: 进入虚拟环境运行 Flask 应用, hello.py 12workon wpwl-envpython hello.py 第三步: 浏览器访问 http://你的服务器IP:端口号测试结果. 5.结合Nginx服务器用uWSGI部署 Flask &emsp;&emsp;将 uWSGI 和 Nginx Web 服务器结合使用，实现更高的并发性能。 ①python安装uwsgi1pip3 install uwsgi ②uwsgi启动Flask应用第一种启动方式: 命令行参数启动. 12345uwsgi --http 0.0.0.0:5000 --wsgi-file /opt/project/hello.py --callable app -H /root/.virtualenvs/wpwl-env# --http: 指定通过 HTTP 请求访问# --wsgi-file: 指定 Flask 应用文件# -H 指定要使用的python虚拟环境# 当然, 还有其他参数, 可到 uwsgi 的 API 中查看. 之后, 可通过浏览器访问 http://你的服务器IP:端口号测试结果. 第二种启动方式: .ini 配置文件启动. &emsp;&emsp;先在项目根目录下创建 .ini 配置文件. 这里的是: /opt/project/hello.ini 12345678910111213[uwsgi]master = truehttp=:5000chdir = /opt/projectwsgi-file=/opt/project/hello.pycallable=appprocesses=4threads=2buffer-size = 65536vacuum=truepidfile =/opt/project/uwsgi.piddaemonize =/opt/project/hello.logstats = 127.0.0.1:9191 &emsp;&emsp;再通过命令行运行 Flask 应用. 1uwsgi hello.ini 之后, 可通过浏览器访问 http://你的服务器IP:端口号测试结果. ③通过Nginx代理到uwsgi &emsp;&emsp;之前用 uwsgi 启动的 Flask 应用, 并不是我们想要的, 我们想通过 直接访问 WEB 应用(80端口) 来访问 Flask 应用. &emsp;&emsp;因此, 我们需要用 Nginx 来做代理, 将请求代理到 Flask 应用. 同时, 不能再为 uwsgi 配置 http 协议, 而改用 socket: 12345678910111213[uwsgi]master = truesocket=127.0.0.1:5000chdir = /opt/projectwsgi-file=/opt/project/hello.pycallable=appprocesses=4threads=2buffer-size = 65536vacuum=truepidfile =/opt/project/uwsgi.piddaemonize =/opt/project/hello.logstats = 127.0.0.1:9191 Nginx配置: 12345# 当然在 listen 80的 server 块中location /flask &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:5000;&#125; 之后, 可通过浏览器访问 http://你的服务器IP/flask测试结果.","categories":[{"name":"Flask","slug":"Flask","permalink":"https://blog.crainyday.com/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://blog.crainyday.com/tags/Flask/"},{"name":"Python3","slug":"Python3","permalink":"https://blog.crainyday.com/tags/Python3/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.crainyday.com/tags/CentOS7/"}]},{"title":"Markdown与Typora","slug":"Markdown_Typora","date":"2020-03-01T10:55:25.000Z","updated":"2020-03-04T13:10:05.789Z","comments":true,"path":"Markdown_Typora.html","link":"","permalink":"https://blog.crainyday.com/Markdown_Typora.html","excerpt":"简单使用Markdown语言; 利用Typora编辑器, 记录日常生活学习笔记;","text":"简单使用Markdown语言; 利用Typora编辑器, 记录日常生活学习笔记; 1.Markdown简介简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 编辑器 &emsp;&emsp;介绍一款最流行的 Typora 编辑器, Typora 支持 MacOS 、Windows、Linux 平台，且包含多种主题，编辑后直接渲染出效果。 &emsp;&emsp;支持导出HTML、PDF、Word、图片等多种类型文件。 &emsp;&emsp;Typora 官网：https://typora.io/. 2.Markdown标题标题 &emsp;&emsp;共六级标题, 使用 # 号可表示 1-6 级标题, 一级标题对应一个 # 号, 二级标题对应两个 # 号, 以此类推. 例: # 一级标题 ## 二级标题 &emsp;&emsp;Typora 快捷键, 使光标停留在要设置标题的行, 按下 Ctrl+数字键设置对应标题. 3.Markdown段落格式换段 段落的换行: 空一行表示或两个空格+回车表示. Typora 中直接按回车即可. 斜体 斜体1: 123 斜体2: 123 Typora 中的快捷键: Ctrl+I. 粗体 粗体1: 123 粗体2: 123 Typora 中的快捷键: Ctrl+B. 粗斜体 粗斜体1: 123 粗斜体2: 123 Typora 中的快捷键: Ctrl+B+I或Ctrl+I+B. 分隔线 Typora 中的快捷键: 先按三下-, 再按Enter. 删除线例子: 123 Typora 中的快捷键: Alt+Shift+5. 下划线例子: 123 Typora 中的快捷键: Ctrl+U. 脚标与脚注例子: 这上边有脚注^1 &emsp;&emsp;Typora 中的使用: 在需要插入脚注标号的位置写 [^ number ] ;再在下方通过 [^ number ]:在文档中插入脚注. 注意不要遗漏了脚注编号 number 前后的空格. 4.Markdown列表无序列表无序列表1: 第一项 第二项 第三项 无序列表2: 第一项 第二项 第三项 无序列表3: 第一项 第二项 第三项 Typora 中的快捷键: Ctrl+Shift+]. 便捷使用: -+Space. 有序列表有序列表: 第一项 第四项 Typora 中的快捷键: Ctrl+Shift+[. 便捷使用: 数字键+.+Space. 列表嵌套 第一项 一一 一二 第二项 二一 二二 5.Markdown区块简单区块: 一 二 区块嵌套: 一 二 区块中使用列表: 第一项 第二项 第一项 第二项 列表中使用区块: 第一项 ① ② 第二项 区块即引用. Typora 中的快捷键: Ctrl+Shift+Q. 快捷使用: &gt;+Space. 6.Markdown代码简单代码片: printf()函数. 代码块: 123$(document).ready(function () &#123; alert('RUNOOB');&#125;); Typora 中的快捷键: 代码片: Ctrl+Shift+~. 代码块: Ctrl+Shift+K. 快捷使用: `或直接包括代码块.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142---# 7.Markdown链接直接使用链接地址: &lt;https://www.baidu.com&gt;链接: [百度一下](https://www.baidu.com)高级链接: 这个链接用 1 作为网址变量 [Google然后在文档的结尾为变量赋值（网址）[1]: http://www.google.com/&gt; Typora 中的快捷键: &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;K&lt;/kbd&gt;.&gt;&gt; 直接使用链接地址: \\&lt;链接地址\\&gt;---# 8.Markdown图片简单使用:![alt 占位图](https://via.placeholder.com/480x100 &quot;可选标题&quot;)使用变量:这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾为变量赋值（网址）[1]: http://static.runoob.com/images/runoob-logo.png也可以直接使用 img 标签:&lt;img src=&quot;https://via.placeholder.com/480x100&quot; width=&quot;50%&quot;&gt;&gt; Typora 中的快捷键: &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;I&lt;/kbd&gt;.---# 9.Markdown表格Markdown 制作表格使用 **|** 来分隔不同的单元格，使用 **-** 来分隔表头和其他行。- -: 设置内容和标题栏居右对齐。- :- 设置内容和标题栏居左对齐。- :-: 设置内容和标题栏居中对齐。| 左对齐 | 右对齐 | 居中对齐 || :----- | -----: | :------: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |&gt; Typora 中的快捷键: &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;T&lt;/kbd&gt;.&gt;&gt; 可在界面直接操作单元格.---# 10.Markdown高级使用技巧## 使用HTML标签直接使用HTML标签: 如, \\&lt;kbd\\&gt;、\\&lt;sup\\&gt;、\\&lt;sub\\&gt;等.例如: 使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑## 插入公式$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 = \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\\\end&#123;vmatrix&#125;$&#123;$tep1&#125;&#123;\\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;$$&gt; Typora 中的快捷键: &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;M&lt;/kbd&gt;.&gt;&gt; 快捷使用: 先按键入两个&lt;kbd&gt;$&lt;/kbd&gt;, 再按&lt;kbd&gt;Enter&lt;/kbd&gt;.## 角标例如: X^2^、H~2~O等&gt; 上标快捷使用: &lt;kbd&gt;^&lt;/kbd&gt; +&lt;kbd&gt;上标&lt;/kbd&gt;+&lt;kbd&gt;^&lt;/kbd&gt;.&gt;&gt; 下标快捷使用: &lt;kbd&gt;~&lt;/kbd&gt; +&lt;kbd&gt;下标&lt;/kbd&gt;+&lt;kbd&gt;~&lt;/kbd&gt;.## 高亮显示例如: ==高亮显示==&gt; 快捷使用: 将高亮内容键入一对&lt;kbd&gt;==&lt;/kbd&gt;和&lt;kbd&gt;\\=\\=&lt;/kbd&gt;之间.## 着重关键字例如: `Keyword`&gt; 着重关键字即插入代码片.&gt;&gt; Typora 中的快捷键: &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;`&lt;/kbd&gt;.&gt;&gt; 快捷使用: &lt;kbd&gt;`&lt;/kbd&gt;包括关键字.## 插入enjoy表情例如: :smiley:.&gt; 快捷使用: 键入&lt;kbd&gt;:&lt;/kbd&gt;+表情对应单词.## 内联公式例如: $\\frac &#123;\\partial f&#125; &#123;\\partial x &#125;$, 公式和文字显示在一行.&gt; 快捷使用: 将高亮内容键入一对&lt;kbd&gt;$&lt;/kbd&gt;和&lt;kbd&gt;\\$&lt;/kbd&gt;之间.## 插入图表(序列图、流程图、Mermaid图)例子, 简单图表:```mermaidgraph LRA[方形] --&gt;B(圆角)B --&gt; C&#123;条件a&#125;C --&gt;|a=1| D[结果1]C --&gt;|a=2| E[结果2]F[横向流程图]","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://blog.crainyday.com/tags/Markdown/"},{"name":"Typora","slug":"Typora","permalink":"https://blog.crainyday.com/tags/Typora/"}]},{"title":"JDBC-Web简单运用","slug":"JDBC2-0","date":"2019-10-17T14:00:35.000Z","updated":"2019-10-19T06:52:56.356Z","comments":true,"path":"JDBC2-0.html","link":"","permalink":"https://blog.crainyday.com/JDBC2-0.html","excerpt":"在 JavaWeb 中使用 JDBC 进行相关数据的操作。 在这里只是讲一下简单的应用，不涉及 MVC 模式。 ① 利用 c3p0 数据库连接池获取数据库连接。 ② 利用 dbutils 工具类操作数据库。 ③ 利用 beanutils 工具类操作 JavaBean。","text":"在 JavaWeb 中使用 JDBC 进行相关数据的操作。 在这里只是讲一下简单的应用，不涉及 MVC 模式。 ① 利用 c3p0 数据库连接池获取数据库连接。 ② 利用 dbutils 工具类操作数据库。 ③ 利用 beanutils 工具类操作 JavaBean。 1.下载相关包 当然，你可以自己到相应的官网下载。 commons包———Apache Commons MySQL驱动———MySQL官网 c3p0相关驱动———SF开源网站 这里也提供全套的 jar 包下载，百度云链接: https://pan.baidu.com/s/1aSDHhDx5T3Y1-FUxYvpncA&amp;shfl=shareset 提取码: ncv7。失效请联系博主。 其中 Codec 包是用来进行特殊编码和解码的。 2.在JavaWeb中简单使用 JDBC ①在 Ecplise 中创建一个动态的 Web 工程。 ②在 Web 根目录下的 WEB-INF/lib 目录下，导入下载好的 jar 包。 ③在 src 目录下新建包，存放相应的 java 文件，当然，都放在一个包里也可以。如下图： 下面用到的 src，下载地址：链接: https://pan.baidu.com/s/1MHoMuvXXb0Fx_ehlWVE87g&amp;shfl=shareset 提取码: sv8y。失效请联系博主。 下载后解压后，别忘记了 先将下载要用的 jar 包导入 lib，再修改你的 c3p0-config.xml 配置文件：修改的你数据库 jdbcUrl、用户名、密码。 期间用到的数据库表为 user，字段为：userId(int)、userName(varchar)、password(vrachar)、age(int)、address(varchar)、email(varchar)。 之后以 Java Application 形式运行 UserDAOJDBCImplTest.java 文件测试即可。 相关介绍： dao包———Data Access Object 接口类 domain包———存放JavaBean impl包———存放DAO的实现类 servlet包———存放用到的servlet test包———junit测试包 utils包———工具类 c3p0-config.xml———c3p0配置信息 在JavaWeb中简单使用中，我们先把所有的类文件放在一个包里。 例子：使用c3p0数据库连接池，获取 MySQL 数据库连接，之后利用 DButils 操作数据库，查询数据库记录并返回对应的 JavaBean 对象，或数据库的查询结果、更新数据库记录。数据库的一张 user 表如下： 在这里建议，开发 Java 项目的话，数据表字段名建议用 小驼峰命名法 命名。 user_id user_name password age address email 1 root root 10 山东临沂 root @crainyday.com 2 admin admin 20 山东济南 admin @crainyday.com 3 user user 30 山东泰安 user @crainyday.com 修改数据表字段名： userId userName password age address email 1 root root 10 山东临沂 root @crainyday.com 2 admin admin 20 山东济南 admin @crainyday.com 3 user user 30 山东泰安 user @crainyday.com 分文件介绍： A.创建表对应的 JavaBean JavaBean 属性与 user 表一一对应，属性名用小驼峰命名法，setter和getter用大驼峰命名。 为了方便编程，可以将数据库表的字段名也用 小驼峰命名法，这样的话，写对该表操作的 SQL 语句时方便很多。 例如：对同一种查询，数据库字段用下划线命名法命名的话，要这样写：”SELECT user_id as userId,user_name as userName,password,age,address,email FROM user WHERE user_name = ?”。 数据库字段用小驼峰命名法命名的话，就可以这样写：”SELECT * FROM user WHERE userName = ?”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.crainyday.web;/** * 用户Bean * @author crainyday * */public class User &#123; private int userId; private String userName; private String password; private int age; private String address; private String email; public User() &#123; super(); &#125; public int getUserId() &#123; return userId; &#125; public void setUserId(int userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return \"User [userId=\" + userId + \", userName=\" + userName + \", password=\" + password + \", age=\" + age + \", address=\" + address + \", email=\" + email + \"]\"; &#125;&#125; B.JDBCUtils工具类 利用 c3p0 连接池获取数据源，下面只是初步的工具类，不涉及事务操作。 注意：需要在 src 目录下有 c3p0-config.xml 文件，JDBCUtils.java 中的数据源名为：c3p0-config.xml文件中的named-config标签中的 name 属性值。 c3p0-config.xml： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://127.0.0.1:3306/design?useSSL=false&amp;amp;serverTimezone=GMT%2B8&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;root&lt;/property&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name=\"web\"&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; JDBCUtils.java： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.crainyday.web;import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;/** * JDBC 操作工具类 * 1. 获取数据库连接 * 2. 释放数据库连接 * @author crainyday * */public class JDBCUtils &#123; // 注意数据源只创建一次即可, 需要在静态代码块里初始化 private static DataSource ds = null; static &#123; // 这里的数据源名为：c3p0-config.xml文件中的named-config标签中的 name 属性值。 ds = new ComboPooledDataSource(\"web\"); &#125; /** * 释放一个 connection 连接 * @param connection */ public static void release(Connection connection) &#123; try &#123; if(connection != null) &#123; connection.close(); &#125; &#125; catch (SQLException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; /** * 返回数据源的一个 connection 连接对象 * @return * @throws SQLException */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125;&#125; C.最基础DAO 封装了基本的 CRUD (增加Create、读取Read、更新Update和删除Delete)的方法, 以供子类继承使用。 这里的 DAO 无事务操作，故直接在方法中利用 JDBCUtils 获取数据库连接。 采用 DBUilts 操作数据库。 返回查询到的某一条记录对应的 JavaBean 对象，或返回查询的某些记录对应的 JavaBean 对象的 List 对象，或返回查询结果的数值。 DAO.java： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.crainyday.web;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;/** * * @author crainyday * 封装了基本的 CRUD 的方法, 以供子类继承使用 * 当前 DAO 无事务操作,直接在方法中获取数据库连接 * 整个 DAO 采用 DBUtils 方案解决 * @param &lt;T&gt;: 当前 DAO 操作的实体类型 */public class DAO&lt;T&gt; &#123; // QueryRunner 是线程安全的 private QueryRunner qr = new QueryRunner(); private Class&lt;T&gt; clazz; /** * DAO 构造函数: 利用反射确定当前 DAO 操作的实体类型 clazz */ @SuppressWarnings(\"unchecked\") public DAO() &#123; Type superClass = getClass().getGenericSuperclass(); if(superClass instanceof ParameterizedType) &#123; ParameterizedType parameterizedType = (ParameterizedType) superClass; Type [] typeArgs = parameterizedType.getActualTypeArguments(); if(typeArgs != null &amp;&amp; typeArgs.length &gt; 0) &#123; if(typeArgs[0] instanceof Class) &#123; clazz = (Class&lt;T&gt;) typeArgs[0]; &#125; &#125; &#125; &#125; /** * 返回某一个字段的值 或 数据表中符合条件的记录数 * @param sql * @param args * @return */ public &lt;E&gt; E getForValue(String sql, Object ...args) &#123; Connection connection = null; try &#123; connection = JDBCUtils.getConnection(); return (E) qr.query(connection, sql, new ScalarHandler&lt;E&gt;(), args); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally &#123; JDBCUtils.release(connection); &#125; return null; &#125; /** * 返回 T 所对应的 List * @param sql * @param args * @return */ public List&lt;T&gt; getForList(String sql, Object ...args)&#123; Connection connection = null; try &#123; connection = JDBCUtils.getConnection(); return qr.query(connection, sql, new BeanListHandler&lt;&gt;(clazz), args); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally &#123; JDBCUtils.release(connection); &#125; return null; &#125; /** * 返回 T 所对应的一个实体类的对象 * @param sql * @param args * @return */ public T get(String sql, Object ...args) &#123; Connection connection = null; try &#123; connection = JDBCUtils.getConnection(); return qr.query(connection, sql, new BeanHandler&lt;&gt;(clazz), args); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally &#123; JDBCUtils.release(connection); &#125; return null; &#125; /** * 该方法封装了 INSERT DELETE UPDATE 操作. * @param sql sql 语句 * @param args */ public void update(String sql, Object ... args) &#123; Connection connection = null; try &#123; connection = JDBCUtils.getConnection(); qr.update(connection, sql, args); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally &#123; JDBCUtils.release(connection); &#125; &#125;&#125; D.UserDAO 描述了一些与 User JavaBean 相关的 操作接口，以供子类 implements 就是这个 User Bean 可以用来干什么，只是描述一下它的功能。 UserDAO.java： 点击显/隐内容 1234567891011121314151617181920212223242526272829303132package com.crainyday.web;/** * UserBean 操作接口 * @author crainyday * */public interface UserDAO &#123; /** * 用户注册 * @param user */ public void register(User user); /** * 用户登录 * @param username * @param password * @return */ public User login(String username, String password); /** * 返回和 username 相等的记录条数 * @param username * @return */ public long getUsernameCount(String username); /** * 返回和 email 相等的记录条数 * @param email * @return */ public long getEmailCount(String email);&#125; E.UserDAOJDBCImpl 继承自 基础的 DAO，实现了 功能接口 DAO。 User 数据访问对象 JDBC 的实现 通过基础 DAO 操作数据库：用户登陆，用户注册，查询用户信息 UserDAOJDBCImpl.java： 点击显/隐内容 12345678910111213141516171819202122232425262728293031package com.crainyday.web;/** * User 数据访问对象 JDBC 的实现 * 操作数据库:用户登陆,用户注册,查询用户 * @author crainyday * */public class UserDAOJDBCImpl extends DAO&lt;User&gt; implements UserDAO &#123; @Override public void register(User user) &#123; String sql = \"INSERT INTO user VALUES(?,?,?,?,?,?)\"; update(sql, user.getUserId(),user.getUserName(), user.getPassword(), user.getAge(), user.getAddress(), user.getEmail()); &#125; @Override public User login(String username, String password) &#123; String sql = \"SELECT * FROM user WHERE userName = ?\"; return get(sql, username); &#125; @Override public long getUsernameCount(String username) &#123; String sql = \"SELECT count(userId) FROM user WHERE userName = ?\"; return getForValue(sql, username); &#125; @Override public long getEmailCount(String email) &#123; String sql = \"SELECT count(userId) FROM user WHERE email = ?\"; return getForValue(sql, email); &#125;&#125; F.UserDAOJDBCImplTest 测试写好的数据操作、对象功能是否正确。也可以用 junits 测试，为了共用，这里用了基本的方法。 UserDAOJDBCImplTest.java： 1234567891011121314151617181920package com.crainyday.web;public class UserDAOJDBCImplTest &#123; public static void main(String[] args) &#123; UserDAO dao = new UserDAOJDBCImpl(); String username = &quot;root&quot;; String password = &quot;root&quot;; User user = dao.login(username, password); User registerUser = new User(); registerUser.setUserId(2); registerUser.setUserName(&quot;admin&quot;); registerUser.setPassword(&quot;admin&quot;); registerUser.setAge(12); registerUser.setAddress(&quot;山东济南&quot;); registerUser.setEmail(&quot;admin@crainyday.com&quot;); dao.register(registerUser); System.out.println(user); &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"},{"name":"Web","slug":"Web","permalink":"https://blog.crainyday.com/tags/Web/"}]},{"title":"Ubuntu使用博客","slug":"Ubuntu-XMind","date":"2019-10-16T12:39:25.000Z","updated":"2019-10-19T06:41:51.203Z","comments":true,"path":"Ubuntu-XMind.html","link":"","permalink":"https://blog.crainyday.com/Ubuntu-XMind.html","excerpt":"作为最受欢迎的思维导图软件———XMind，在日常生活工作中也是经常用到的。之前在 Windows 中也是用它来做一些知识点的梳理，因此在转向了 ubuntu 后也想继续使用该软件。 但是如何最正确的安装呢？注意，本人这里仅仅针对 ubuntu 安装的 XMind。","text":"作为最受欢迎的思维导图软件———XMind，在日常生活工作中也是经常用到的。之前在 Windows 中也是用它来做一些知识点的梳理，因此在转向了 ubuntu 后也想继续使用该软件。 但是如何最正确的安装呢？注意，本人这里仅仅针对 ubuntu 安装的 XMind。 1.下载 XMind &emsp;&emsp;去 XMind 的官网下载 ，也可点击下载 XMind。下载后不要急于安装。需要配置好 XMind 的运行环境，因为 XMind 是用 eclipse 基于 Java 开发的，这里用的是 JDK 1.8，XMind 8 最低必须要求 1.8。 2.安装 JDK &emsp;&emsp;已经配置好 ubuntu 的 Java 环境的请忽略此步骤。不想配置 ubuntu 的 Java 环境 的，可以用下面的 shell 命令直接安装。不过这里更建议，先配置好 ubuntu 的 Java 环境 ，因为配置后就不用再修改 XMind.ini 配置文件，直接就可运行 XMind。 1sudo apt-get install openjdk-8-jdk 3.解压安装 XMind &emsp;&emsp;其实不用安装，直接解压第一步下载下来的 zip文件就能运行。将下载下来的 XMind.zip 文件 mv 到你想要的地方，解压即可。涉及得到的命令如下： 1234567sudo mkdir /opt/xmindsudo mv xmind-8-update8-linux.zip /opt/xmindcd /optsudo chmod -R 777 xmindcd /xmindsudo unzip xmind-8-update8-linux.zipsudo rm xmind-8-update8-linux.zip 重要的事情说三遍！！！这一步很重要，成败在此一举。在 Linux 中，文件系统安全很高，有好处也有弊端，在这里建议，以后安装或运行什么软件的时候，第一步就提权，不然可能会恶心死你，明明操作都对，结果不尽人愿，运行 web 项目的时候有时也要提权。 一定要提权 /opt/xmind 目录。 一定要提权 /opt/xmind 目录。 一定要提权 /opt/xmind 目录。 这里简单说一下，XMind 的目录结构。 ./setup.sh ——— XMind 的安装文件，这里用不到。 ./XMind_amd64 ——— 64位版 XMind 的目录 ./XMind_i386 ——— 32位版 XMind 的目录 4.配置 XMind.ini &emsp;&emsp;已经配置好 ubuntu 的 Java 环境的也请忽略此步骤。 在原来的 XMind_amd64/XMind.ini 或 XMind_i386/XMind.ini 文件的基础上，添加下面两行代码。 注意：若是你是通过安装实现的配置 Java 环境的，到最后运行 XMind 时报了错误或有警告，请放弃这种配置方式，直接先去配置好 ubuntu 的 Java 环境，此时不需再修改 XMind.ini 文件。 12-vm/usr/lib/jvm/java-8-openjdk/amd64/bin 5.运行 XMind 双击 XMind_amd64/XMind 文件即可成功运行，32位的请双击 XMind_i386/XMind 文件。 6.编辑 .desktop &emsp;&emsp;添加桌面快捷方式，快速打开 XMind。在 /usr/share/applications 目录下，添加 .desktop 文件。 12sudo cd /usr/share/applicationssudo vim xmind.desktop 123456789101112[Desktop Entry]Version = 1.0Encoding=UTF-8Type=ApplicationName=XmindComment=XmindPath=/opt/xmind/XMind_amd64Exec=/opt/xmind/XMind_amd64/XMindIcon=/opt/xmind/XMind_logo.pngTerminal=falseCategories=ApplicationStartupWMClass=XMind 这里的 XMind_logo.png 图标是我自己百度找的，XMind本身没有。","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.crainyday.com/categories/ubuntu/"}],"tags":[{"name":"XMind","slug":"XMind","permalink":"https://blog.crainyday.com/tags/XMind/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.crainyday.com/tags/ubuntu/"}]},{"title":"JavaBean","slug":"JavaWeb4-0","date":"2019-09-23T07:25:36.000Z","updated":"2019-10-10T05:15:28.000Z","comments":true,"path":"JavaWeb4-0.html","link":"","permalink":"https://blog.crainyday.com/JavaWeb4-0.html","excerpt":"什么是 JavaBean ？(Java豆) 在 JSP 中 使用 JavaBean。 三个标签：","text":"什么是 JavaBean ？(Java豆) 在 JSP 中 使用 JavaBean。 三个标签： 123&lt;jsp:useBean id=\"JavaBean的标识符\" class=\"JavaBean的全类名\" scope=\"作用范围\"&gt;&lt;/jsp:useBean&gt;&lt;jsp:setProperty property=\"属性名(键)\" value=\"属性值\" name=\"JavaBean的标识符\" /&gt;&lt;jsp:getProperty property=\"属性名(键)\" name=\"JavaBean的标识符\" /&gt; 1. JavaBean 用作 JavaBean 的类的要求： ① 必须有一个公共的、无参的构造方法（利用 反射 创建该类的对象时必须的） ② JavaBean 的属性以方法定义的形式出现 ③ 对属性赋值的方法称为属性修改器或 setter 方法，获取属性值的方法称为属性访问器或 getter 方法 ④ userName 的 setter 方法名为：setUserName，password 的 getter 方法名为 getPassword ⑤ JavaBean 的属性名根据 getter 和 setter 方法名生成，方法名去掉”get“或”set“，剩余部分首字母小写即为属性名 以下就是一个典型的 JavaBean 类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.crd.design.domain;public class User &#123; private int userId; private String userName; private String userPassword; private String userSalt; private String userEmail; public User() &#123; super(); &#125; public User(int userId, String userName, String userPassword, String userSalt, String userEmail) &#123; super(); this.userId = userId; this.userName = userName; this.userPassword = userPassword; this.userSalt = userSalt; this.userEmail = userEmail; &#125; public User(String userName, String userPassword, String userEmail) &#123; super(); this.userName = userName; this.userPassword = userPassword; this.userEmail = userEmail; &#125; public int getUserId() &#123; return userId; &#125; public void setUserId(int userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUserPassword() &#123; return userPassword; &#125; public void setUserPassword(String userPassword) &#123; this.userPassword = userPassword; &#125; public String getUserSalt() &#123; return userSalt; &#125; public void setUserSalt(String userSalt) &#123; this.userSalt = userSalt; &#125; public String getUserEmail() &#123; return userEmail; &#125; public void setUserEmail(String userEmail) &#123; this.userEmail = userEmail; &#125; @Override public String toString() &#123; return \"User [userId=\" + userId + \", userName=\" + userName + \", userPassword=\" + userPassword + \", userSalt=\" + userSalt + \", userEmail=\" + userEmail + \"]\"; &#125;&#125; 2. JSP中应用 JavaBean &emsp;&emsp;对于 JSP 页面来说，只要是一个类有一个公共的、无参的构造方法，该类就可以用作创建 JavaBean 对象。该类中不接受任何参数的 getter 方法和 只接受一个参数的 setter 方法，都可以当作该类对象的属性名来引用。 A.相关标签 标签 作用 &lt;jsp:useBean&gt; 创建和查找 JavaBean 实例对象 &lt;jsp:setProperty&gt; 设置 JavaBean 对象的属性 &lt;jsp:getProperty&gt; 读取 JavaBean 对象的属性 B.&lt;jsp:useBean&gt; &lt;jsp:useBean&gt;用法： &emsp;&emsp;用于在某个指定(scope属性指定)的域范围(application、session、request、pageContext等)内查找一个指定(id属性指定)名称的 JavaBean 对象，若查到则返回该对象的引用，若不存在则实例化一个新的 JavaBean 对象(class属性指定)并将它存进 scope 属性 指定的域范围内。 语法： 12&lt;jsp:useBean id=\"beanInstanceName\" class=\"package.class\" scope=\"page|request|session|application\"&gt;&lt;/jsp:useBean&gt;&lt;%-- scope只能取上述四个值，page 为默认值 --%&gt; 另一种用法：（此时返回的bean是Object类型的对象） 1&lt;jsp:useBean id=\"beanInstanceName\" beanName=\"package.class\" type=\"java.lang.Object\" scope=\"page|request|session|application\"&gt;&lt;/jsp:useBean&gt; 1234567891011121314&lt;jsp:useBean id=\"user\" class=\"com.crd.design.domain.User\" scope=\"session\"&gt;&lt;/jsp:useBean&gt;&lt;%--以上代码相当于如下：&lt;% User user = (User)session.getAttribute(\"user\"); if(user == null)&#123; user = (User)Class.forName(\"com.crd.design.domain.User\").newInstance(); session.setAttribute(\"user\", user); &#125;%&gt;--%&gt;&lt;%-- useBean之后就可以使用该bean对象，如： --%&gt;&lt;% user.setUserName(\"CRainyDay\");%&gt; C.&lt;jsp:setProperty&gt; &lt;jsp:setProperty&gt;用法： &emsp;&emsp;给指定(name属性指定)的 JavaBean 对象的 指定(property属性指定)属性 赋指定(value属性指定)的属性值。 语法： 1&lt;jsp:setProperty property=\"属性名\" value=\"属性值\" name=\"id指定的bean对象\" /&gt; 1234567&lt;jsp:useBean id=\"user\" class=\"com.crd.design.domain.User\" scope=\"session\"&gt;&lt;/jsp:useBean&gt;&lt;jsp:setProperty property=\"userName\" value=\"crainyday\" name=\"user\" /&gt;&lt;%--以上代码相当于如下：&lt;% user.setUserName(\"crainyday\");%&gt;--%&gt; setProperty 的特殊用法： 若 property 属性值为 ”*“，省略 value 属性，则会自动为对应 JavaBean 对象的所有属性赋值为对应的请求参数的值。 123456&lt;%--例：请求参数为 ?userName=\"crainyday\"&amp;userId=12&amp;userPassword=\"crainyday\"--%&gt;&lt;jsp:useBean id=\"user\" class=\"com.crd.design.domain.User\" scope=\"session\"&gt;&lt;/jsp:useBean&gt;&lt;jsp:setProperty property=\"*\" name=\"user\" /&gt;&lt;%--这样做进一步简化了开发， 否则，必须先从request中取出对应参数的值， 然后为JavaBean对象对应属性赋值--%&gt; D.&lt;jsp:getProperty&gt; &lt;jsp:getProperty&gt;用法： &emsp;&emsp;获取指定(name属性指定)的 JavaBean 对象的 指定(property属性指定)属性 的属性值。 语法： 1&lt;jsp:getProperty property=\"属性名\" name=\"id指定的bean对象\" /&gt; 12345&lt;jsp:useBean id=\"user\" class=\"com.crd.design.domain.User\" scope=\"session\"&gt;&lt;/jsp:useBean&gt;&lt;jsp:getProperty property=\"userName\" name=\"user\" /&gt;&lt;%--以上代码相当于如下：&lt;%= user.getUserName()%&gt;--%&gt; 3.利用eclipse快速开发JavaBean ①新建类并创建 JavaBean 的私有属性。 ②在该类中右键单击，然后点击源码，再点击生成 Getter 和 Setter 方法，选择要生成方法的字段即可生成对应的 Getter、Setter方法。 ③同步骤②，也可以由字段生成该类的构造方法，一定要一个公共的、无参的构造方法。 ④同步骤②，也可以覆盖该类的 toString 方法，用于之后测试 JavaBean。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://blog.crainyday.com/categories/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://blog.crainyday.com/tags/Web/"},{"name":"Servlet","slug":"Servlet","permalink":"https://blog.crainyday.com/tags/Servlet/"},{"name":"JSP","slug":"JSP","permalink":"https://blog.crainyday.com/tags/JSP/"}]},{"title":"第一个JavaWeb应用","slug":"JavaWeb1-1","date":"2019-09-15T15:05:25.000Z","updated":"2019-10-10T04:52:25.000Z","comments":true,"path":"JavaWeb1-1.html","link":"","permalink":"https://blog.crainyday.com/JavaWeb1-1.html","excerpt":"什么是 JavaWeb？ 如何开发 JavaWeb？ ①同之前一样，用 eclipse 开发普通 Java 项目的方式创建第一个 JavaWeb 项目并发布到 Tomcat 服务器。 ②用 JavaEE 版的 eclipse 创建第一个动态的 JavaWeb 工程。","text":"什么是 JavaWeb？ 如何开发 JavaWeb？ ①同之前一样，用 eclipse 开发普通 Java 项目的方式创建第一个 JavaWeb 项目并发布到 Tomcat 服务器。 ②用 JavaEE 版的 eclipse 创建第一个动态的 JavaWeb 工程。 1. JavaWeb 概述 &emsp;&emsp;JavaWeb 应用是由一组 Servlet、HTML 页面、Java 类以及其它可以被绑定的资源构成的，它可以运行在各种供应商提供的实现了 Servlet 规范的 Servlet 容器中。 由此，JavaWeb 应用中可以包含： — Servlet — JSP — 实用类 — 静态文档，如HTML、图片、CSS、JS等 — 描述 Web 应用的信息(web.xml) JavaWeb 目录结构： 在此，先统一 eclipse 的所有文件的编码解码格式，一般统一为 UTF-8 即可。 请看教程示例 Eclipse 修改字符集 2.手动创建 JavaWeb 应用 经典版的 Eclipse：Eclipse 的每个安装包都不同， Java 开发人员通常使用 Eclipse IDE for Java Developers 来开发 Java 应用。安装 Eclipse 之前必须做好 Java开发环境配置 用经典版的 eclipse 开发普通 Java 项目的方式创建第一个 JavaWeb 项目并发布到Tomcat服务器 ①创建 Java 项目 右键新建一个 Java 项目，按照 Servlet 定义的 JavaWeb 目录结构，创建对应目录。 web.xml： 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" id=\"WebApp_ID\" version=\"3.1\"&gt; &lt;display-name&gt;test&lt;/display-name&gt;&lt;!--注意：这里要为Web项目名称--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; index.jsp： 123&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;Hello ②配置Build Path 在 JavaWeb 目录结构中要求：JavaWeb 应用的类文件必须存放在 /WEB-INF/classes 目录下。 因此，需要将当前 Java 项目 src 的源码输出文件夹改为 /WEB-INF/classes。 &emsp;&emsp;在项目上右键单击，依次 选择 Build Path → Config Build Path &emsp;&emsp;之后将 src 的源码输出文件夹 修改即可。 &emsp;&emsp;之后在 src 下创建一个 Java 类(Test.java)。 Test.java： 12345public class Test&#123; public String getTestInfo()&#123; return \"Testing......\"; &#125;&#125; &emsp;&emsp;修改 index.jsp： 12345678&lt;%@ page import=\"test.Test\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;Hello&lt;% Test test = new Test(); System.out.println(test.getTestInfo());%&gt; ③部署到 tomcat 这里说两种部署方法： ①最简单的方法，把 WebContent 目录复制到 Tomcat 的 webapps 目录下，并改名为：test，重启 tomcat 后访问 localhost:8080/test/index.jsp 即可。浏览器会输出：Hello。控制台会输出：Testing…… ②通过配置，映射任意目录下的 WEB 应用，实现后，重启 tomcat 后访问 localhost:8080/test/index.jsp 即可。浏览器会输出：Hello。控制台会输出：Testing…… &emsp;&emsp;先在 Tomcat 根目录中，conf 目录下依次创建 catalina/localhost 目录，然后在 localhost 目录下为 test这个 Web 应用程序建立 test.xml 文件。 test.xml： 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Context path=\"/hello\" docBase=\"E:\\\\Java\\\\Source\\\\test\\\\WebContent\" reloadable=\"true\"/&gt;&lt;!--path 不起作用--&gt;&lt;!--docBase 为创建的 JavaWeb 应用的 WebContent的真实物理路径--&gt;&lt;!--注意写路径时的转义字符--&gt; reloadable：当修改了 docBase 指向的目录下的 class 文件时， tomcat 服务器是否重新加载 web 应用。 3.创建动态的 JavaWeb 工程 JavaEE 版的 Eclipse 下载 下载之后，将压缩文件解压，和原来安装的 Eclipse 合并即可。Ctrl+C、Ctrl+V，选择全部覆盖。 请看教程示例 Eclipse 修改字符集 ①将 Eclipse 切换到 JavaEE 模式 点击如图中的图标即可切换，没有的点击“打开透视图”查找即可。 若查找不到，就是你的 Eclipse 没有安装 JavaEE 开发的系列插件。 ②打开包资源管理器 JavaEE 默认使用的是 Project Explorer(项目资源管理器)，这里我用惯了 包资源管理器。 依次点击 Window → Show View → Other，打开要显示的视图。 找到 Java → Package Explorer 即可打开 包资源管理器。 ③新建一个 Server 按照②的方法，打开 Servers 视图。 之后右键单击，依次点击 New → Server，新建一个 Server。 选择新建的 Tomcat 的版本，host name、Server name 默认即可。 之后添加 Server 的运行时环境，点击 Add，添加 Tomcat Server，选择自己电脑上安装的 Tomcat，确定即可。 ④新建一个 Dynamic Web Project 在包管理器中，右键单击，New → Dynamic Web Project。 这里注意，一定不要新建 Static Web Project，若找不到新建的动态 Web 工程，点击 Other 寻找即可。 输入项目名，选择运行环境(就是刚才新建的 Server 的 Apache Tomcat 版本，默认即可)，选择动态 Web 应用版本，Next → Next，别急着点 Finish，最后一步一定要选择 Generate web.xml deployment descriptor。 ⑤测试 新建一个 Test 类，index.jsp 文件如图。 Eclipse 快捷键：Alt+/ 代码提示，Ctrl+Shift+O 自动导包，Ctrl+/ 代码注释。 Test.java： 1234567package com.crd.test;public class Test &#123; public String getTestInfo() &#123; return \"testings......\"; &#125;&#125; index.jsp： 12345678910111213141516&lt;%@page import=\"com.crd.test.Test\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% Test test = new Test(); System.out.println(test.getTestInfo()); %&gt;&lt;/body&gt;&lt;/html&gt; 之后，在 index.jsp 文件上，右键单击 → Run AS → Run On Server，即可成功运行。 打开 Console(控制台)视图，同步骤②。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://blog.crainyday.com/categories/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://blog.crainyday.com/tags/Web/"},{"name":"Servlet","slug":"Servlet","permalink":"https://blog.crainyday.com/tags/Servlet/"},{"name":"JSP","slug":"JSP","permalink":"https://blog.crainyday.com/tags/JSP/"}]},{"title":"配置JavaWeb环境","slug":"JavaWeb1-0","date":"2019-09-15T04:55:25.000Z","updated":"2019-10-10T05:22:28.000Z","comments":true,"path":"JavaWeb1-0.html","link":"","permalink":"https://blog.crainyday.com/JavaWeb1-0.html","excerpt":"安装、部署、启动 JavaWeb 的环境——Tomcat服务器。 在此之前，必须保证已经安装配置了JDK的环境。 若没有请参看 Java环境配置 进行配置。","text":"安装、部署、启动 JavaWeb 的环境——Tomcat服务器。 在此之前，必须保证已经安装配置了JDK的环境。 若没有请参看 Java环境配置 进行配置。 1.配置 JDK 环境 输入以下命令，查看 JDK 版本。 1java -version 若是提示找不到 java 命令，请先安装 JDK 或 JRE。并配置系统变量: JAVA_HOME 或 JRE_HOME. 如何配置 Java 开发环境？ Java环境配置 配置一个环境变量. java_home(指向 JDK 安装的根目录) 或 jre_home 2.部署并启动 tomcat1)下载 tomcattomcat ，下载哪个版本都 OK，我这里用的 apache-tomcat-8.5.46.zip 2)解压 tomcat 解压时注意，要解压到非中文目录 3)启动 tomcat 通过双击 apache-tomcat-8.5.46\\bin 目录下的 startup.bat, 启动服务器 在浏览器中输入 localhost:8080 来检验 Tomcat 安装是否正确. 成功： 4)端口可能被占用 若8080端口已被占用；或已经启动了一个 Tomcat 应用, 再启动同一个 Tomcat 应用, 会抛出异常: java.net.BindException: Address already in use: JVM_Bind:8080 因为 8080 端口已经被占用了. 3.关于 tomcat &emsp;&emsp;Tomcat, 一款常用的 运行 Servlet(一种特殊的 JAVA 类，之后会详细介绍)和 JSP(一种特殊的文件，也可以说是一种特殊的 Servlet，之后会介绍) 的 Web 服务器。它和 Apache Web 服务器一样，也具有处理静态HTML的功能，但效果不如Apache，它主要用于处理 jsp 文件。你也可以将它简单的理解为一个 “特殊的 JVM”。实际上 Tomcat 是 Apache 服务器的扩展，它不仅仅是 Web 服务器，还是 Servlet 容器。 &emsp;&emsp;当然，还有很多和 Tomcat 类似的 web 服务器，像：Resin 服务器、JBoss服务器、WebSphere 服务器、WebLogic 服务器等，但由于 Tomcat 是轻量级、开源并且完全免费的Web容器，所以使用广泛，它只适用于中小型项目，对于大型项目要选用其他服务器。 Servlet 与 Servlet 容器： Servlet 容器：为 JavaWeb 应用提供运行时环境，负责管理 Servlet 和 JSP 的生命周期，以及它们的共享数据。Servlet 容器，也称 JavaWeb 应用容器，或者 Servlet/JSP 容器。 在这里多说一点，区分一下：静态页面与动态页面。 静态页面： &emsp;&emsp;你可以理解为一些“死的资源”构成的“死”的页面，如HTML、图片、CSS、JS等。里面的“数据都是死的”。这些页面，往往用户在请求之前，都是已经在服务器存在了的。 动态页面： &emsp;&emsp;并不是说页面能“动”就是动态页面，而是里面有一些动态的、实时的数据交互，如连接、查询数据库，并返回一些动态的数据。这些页面，往往用户请求之前，服务器中还没有，用户请求时，根据特定的请求信息，动态生成了静态页面，并返回给浏览器。 4.修改 tomcat 端口 通过修改 apache-tomcat-8.5.37\\conf\\server.xml 文件中的配置信息来修改 Tomcat 服务的端口号。 1234&lt;Connector port=\"8989\" protocol=\"HTTP/1.1\"connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;&lt;!--修改 port 为想要修改的端口号即可--&gt; 5.配置启动 tomcat 往往为了方便开发，我们希望在任意文件夹下，通过相应命令即可启动、停止 tomcat。 步骤： ①新建系统变量 CATALINA_HOME. 值为 tomcat 所在的根目录, 例：D:\\Program Files\\apache-tomcat-8.5.37。 ②在系统的 Path 中添加一项，“%CATALINA_HOME%\\bin”。 ③打开cmd，输入catalina run命令即可启动 tomcat。 ④在③的基础上，按“Ctrl+C”即可停止 tomcat。 6.启动 tomcat 中文乱码 启动 tomcat 时，往往会有一些中文的乱码，打印在控制台上，可以通过修改配置文件以解决。 通过修改 apache-tomcat-8.5.37\\conf\\logging.properties 文件，将里面的 GBK，全部改为 UTF-8 即可。 若文件中本来都是用 UTF-8 编码的，就将 java.util.logging.ConsoleHandler.encoding = GBK。 7. tomcat 目录结构 目录 描述 /bin 存放windows或Linux平台上启动和关闭Tomcat的脚本文件 /conf 存放Tomcat服务器的各种全局配置文件，其中最重要的是server.xml和web.xml /doc 存放Tomcat文档 /server 包含三个子目录：classes、lib和webapps /server/lib 存放Tomcat服务器所需的各种JAR文件 /server/webapps 存放Tomcat自带的两个WEB应用admin应用和 manager应用 /common/lib 存放Tomcat服务器以及所有web应用都可以访问的jar文件 /shared/lib 存放所有web应用都可以访问的jar文件（但是不能被Tomcat服务器访问） /logs 存放Tomcat执行时的日志文件 /src 存放Tomcat的源代码 /webapps Tomcat的主要Web发布目录，默认情况下把Web应用文件放于此目录 /work 存放JSP编译后产生的class文件 8. tomcat 的管理程序 &emsp;&emsp;tomcat 提供了一个管理程序：manage，用于管理已部署到 tomcat 的 web 应用程序，也可以部署 web 应用到 tomcat 服务器。 ①如下图，点击 Manage App 进入管理程序，需要输入用户名和密码。 ②一开始不知道密码，点击取消即可，之后显示如下图配置。 ③将上述提示配置，配置到 conf/tomcat-users.xml 文件。 12&lt;role rolename=\"manager-gui\"/&gt;&lt;user username=\"root\" password=\"root\" roles=\"manager-gui\"/&gt; ④重启 tomcat 利用改后的用户名、密码，登录即可。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://blog.crainyday.com/categories/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://blog.crainyday.com/tags/Web/"},{"name":"Servlet","slug":"Servlet","permalink":"https://blog.crainyday.com/tags/Servlet/"},{"name":"JSP","slug":"JSP","permalink":"https://blog.crainyday.com/tags/JSP/"}]},{"title":"vuex初识","slug":"Vue5-1","date":"2019-08-13T10:31:25.000Z","updated":"2019-10-06T09:46:18.000Z","comments":true,"path":"Vue5-1.html","link":"","permalink":"https://blog.crainyday.com/Vue5-1.html","excerpt":"vuex初识 为什么要引入 vuex? vuex是什么? vuex怎么使用?","text":"vuex初识 为什么要引入 vuex? vuex是什么? vuex怎么使用? 1.vuex简介 vuex是vue的一个插件(它并没有遵循一般vue插件的命名规范), 它的目的是对vue应用中多个组件的共享状态进行集中式的管理(读/写). vue是一个状态自管理应用. 下面是整个vue应用的数据流通图: State: 驱动整个应用的数据源. View: 以声明方式将State中的数据映射到视图. Actions: 响应在View上的用户输入导致的状态变化(包含多种更新状态的方法) 关于多组件共享状态 产生的问题: ①多个视图依赖于同一状态. ②来自不同视图的行为需要变更同一状态. 之前的解决方法: a. 将数据及操作数据的行为都定义在父组件里 b. 将数据及操作数据的行为传递给需要的各个组件(可能存在多级传递) 而vuex就是用来专门解决这一问题的. vuex的流程图 2.一个简单的vue计数应用 先使用原始的vue方式实现, 之后一步步改为vuex实现方式. App.vue: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div&gt; &lt;p&gt;click &#123;&#123;count&#125;&#125; times, count is &#123;&#123;evenOrOdd&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;incrementIfOdd&quot;&gt;increment if odd&lt;/button&gt; &lt;button @click=&quot;incrementAsync&quot;&gt;increment async&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; count: 0 &#125; &#125;, computed: &#123; evenOrOdd () &#123; return this.count % 2 === 0 ? &apos;偶数&apos; : &apos;奇数&apos; &#125; &#125;, methods: &#123; increment () &#123; const count = this.count this.count = count + 1 &#125;, decrement () &#123; const count = this.count this.count = count - 1 &#125;, incrementIfOdd () &#123; const count = this.count if (count % 2 === 1) &#123; this.count = count + 1 &#125; &#125;, incrementAsync () &#123; const count = this.count setTimeout(() =&gt; &#123; this.count = count + 1 &#125;, 1000) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 3.vuex的初步使用 ①之前项目没有vuex库的需要先安装库: npm install –save vuex ②在项目根目录下创建 store.js, vuex的核心管理对象模块. 编写vuex的核心代码 ③将store模块配置到当前项目中: 在main.js中配置store main.js: 123456789101112import Vue from 'vue'import App from './App'import store from './store'new Vue(&#123; el: '#app', components: &#123; App &#125;, template: '&lt;App/&gt;', store// 配置store后,所有组件对象都多了一个属性对象: $store&#125;) $store 对象 配置完 store 后, 所有的组件对象就都多了一个属性对象: $store, 可以用它来实现很多功能. $store中有两个属性对象: state 和 getters, 也有方法: dispatch(actionName, data) //用来分发调用actions App.vue: 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;p&gt;click &#123;&#123;count&#125;&#125; times, count is &#123;&#123;evenOrOdd&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;incrementIfOdd&quot;&gt;increment if odd&lt;/button&gt; &lt;button @click=&quot;incrementAsync&quot;&gt;increment async&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapState, mapActions&#125; from &apos;vuex&apos; export default &#123; computed: &#123; ...mapState([&apos;count&apos;]), evenOrOdd () &#123; //这里其实是返回了一个vuex的计算属性(可以理解为返回了一个方法) return this.$store.getters.evenOrOdd &#125; &#125;, methods: &#123; increment () &#123; this.$store.dispatch(&apos;increment&apos;) &#125;, decrement () &#123; this.$store.dispatch(&apos;decrement&apos;) &#125;, ...mapActions([&apos;incrementIfOdd&apos;, &apos;incrementAsync&apos;]) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; store.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*vuex的核心管理对象模块: store */import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123; count: 0&#125;const mutations = &#123; INCREMENT (state) &#123; state.count++ &#125;, DECREMENT (state) &#123; state.count-- &#125;&#125;const actions = &#123; increment (&#123;commit&#125;) &#123; commit('INCREMENT') &#125;, decrement (&#123;commit&#125;) &#123; commit('DECREMENT') &#125;, incrementIfOdd (&#123;commit, state&#125;) &#123; if (state.count % 2 === 1) &#123; commit('INCREMENT') &#125; &#125;, incrementAsync (&#123;commit, state&#125;) &#123; setTimeout(() =&gt; &#123; commit('INCREMENT') &#125;, 1000) &#125;&#125;const getters = &#123; evenOrOdd (state) &#123; return state.count % 2 === 0 ? '偶数' : '奇数' &#125;&#125;export default new Vuex.Store(&#123; state, // 包含多个状态对象 mutations, // 包含多个更新state函数的对象 actions, // 包含多个对应时间回掉函数的对象 getters// 包含多个getter计算属性函数的对象&#125;) 这个例子并不适合用vuex来做, vuex是用来解决多组件共享状态问题的. 在这里仅仅用来说明vuex的基本语法. 在真正开发一个项目时, 要综合分析, 有时多组件共享问题用vuex实现也不是很好. 4.vuex的一般项目结构 上面的例子中, 将vuex相关的所有代码, 书写在了一个文件(store.js)中. 但在一般大中型项目中, 会将 vuex 的store.js 拆分为五个文件: index.js、actions.js、getters.js、mutations.js、types.js index.js: 创建 state 状态对象, 并将其余几个文件引入后, 向外暴露 store 对象. actions.js: 包含多个事件回调函数的对象, 经常用来做一些异步操作(向服务器请求数据等), 之后通过触发 mutations.js 中的方法, 间接的更新 state . getters.js: vuex的 state 相关的一些计算属性. mutations.js: 包含多个直接更新 state 的方法(回调函数)的对象. 这些方法由 actions.js 中的 commit(‘mutation名’) 触发执行. 注意: 在这里只能执行一些同步代码, 一般只用来同步操作 state . types.js: 创建并向外暴露一些对应 mutations.js 方法的字符串常量. vuex 还有一种 modules 配置, 但是一般用不到. 在一些状态非常非常多的应用中才会使用.","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue路由续","slug":"Vue4-2","date":"2019-08-10T13:43:35.000Z","updated":"2019-10-06T09:46:09.000Z","comments":true,"path":"Vue4-2.html","link":"","permalink":"https://blog.crainyday.com/Vue4-2.html","excerpt":"缓存路由组件 路由组件传值 编程式路由组件 路由守卫","text":"缓存路由组件 路由组件传值 编程式路由组件 路由守卫 1.缓存路由组件对象 &emsp;&emsp;要知道一点, 页面中的组件其实都是一些组件对象. &emsp;&emsp;在页面中切换路由时, 会默认先销毁当前的路由组件对象, 在创建要访问的路由组件对象. &emsp;&emsp;而销毁了之前的组件对象的话, 那个组件中的数据(可能是从后台花了很大力气得到的数据)也会销毁, 再切换回这个组件时, 又会重新请求组件中的数据. &emsp;&emsp;如果我们对那些数据的实时性要求不高的话, 我们希望不要放弃之前的数据. 这就用到了——缓存路由组件对象的技术. 那些数据都在路由对象中存着, 只要对象不销毁, 数据就在. 缓存路由组件对象: 我们只需要显示路由组件的地方加个keep-alive标签说明一下就OK. 123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 2.向路由组件传递数据 在vue中路由真实涉及的只有两个标签: router-link 和 router-view. 无可厚非, 我们有两种方法传递数据. 一种通过 router-link 传递, 一种通过 router-view 传递. ①路由路径携带参数 在这里也有两种携带参数的方式: 携带 param 参数和 query 参数. 在页面中切换路由组件时, 都会有一个特殊的对象 $route : 当前路由对象, 它存着一些路由的信息, 包括路由路径携带的参数(param/query). ①定义路由时, 不能把路径写死. 因为路径带有参数, 需要用占位符. ②编写路由连接时, 需要在 to 属性里指定占位符的值. ③在子路由组件中接收参数. 定义路由路径: 123456789path: 'message',component: Message,children: [ &#123; //path: '/home/message/detail?id=:id',//路径携带query参数. path: '/home/message/detail/:id',//路径携带param参数.带有占位符 component: Detail &#125;] 编写路由连接: 12&lt;!--&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;message.id&#125;`&quot;&gt;&#123;&#123;message.title&#125;&#125;&lt;/router-link&gt;--&gt;&lt;router-link :to=&quot;`/home/message/detail/$&#123;message.id&#125;`&quot;&gt;&#123;&#123;message.title&#125;&#125;&lt;/router-link&gt; 接收路由参数: 12345678910111213141516171819202122&lt;script&gt; export default &#123; data () &#123; return &#123; id: &apos;&apos; &#125; &#125;, mounted () &#123; setTimeout(() =&gt; &#123;//模拟异步ajax请求 this.id = this.$route.params.id//这里接收的是param参数 //this.id = this.$route.query.id//这样接收的是query参数 &#125;, 1000) &#125;, watch: &#123; //这里需要监视$route对象,因为mounted函数只会调用一次. //当前组件不知道$route的值发生了变化.故须监视 $route: function (value) &#123; this.id = value.params.id &#125; &#125; &#125;&lt;/script&gt; ②router-view标签属性携带数据 ①在父组件中的router-view标签属性中传递数据 ②在子组件中的props中声明接收属性 Parent.vue: 1&lt;router-view msg=&quot;Hello VueRouter!!!&quot;&gt;&lt;/router-view&gt; Child.vue: 1234567&lt;script&gt; export default &#123; props: &#123; msg: String &#125; &#125;&lt;/script&gt; 3.编程式路由导航 路由(跳转页面)有两种基础的实现方式: 路由标签(如: a标签)和 JS编程实现路由. vue中编程式路由导航用到了另一个对象 $router(路由器), 这是一个功能对象. this.$router.push(url): 相当于点击了路由链接(可以返回当前路由界面) this.$router.replace(url): 用新路由替换当前路由(不能再返回到当前路由界面) this.$router.back(): 返回到上一个记录路由(相当于浏览器的回退按钮) this.$router.go(1): 请求下一个记录路由(相当于浏览器的前进按钮) 4. History 模式 这种模式得玩好, 不然部署项目的时候你就知道了(奸笑). 开发的时候可以使用 history 模式, 但是建议, 部署项目的时候一定要使用(hash)模式. 当然, 你也可以配置一下web服务器, 使之支持 history 模式路由. 5.路由守卫 支持组件内路由和全局路由. 这里我只使用过 全局前置守卫路由: router.beforeEach((to, from, next). 主要是用来判断用户的token是否过期.","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue路由初识","slug":"Vue4-1","date":"2019-08-10T03:09:45.000Z","updated":"2019-10-06T09:45:54.000Z","comments":true,"path":"Vue4-1.html","link":"","permalink":"https://blog.crainyday.com/Vue4-1.html","excerpt":"vue中的路由简介 什么是路由? 怎么使用路由?","text":"vue中的路由简介 什么是路由? 怎么使用路由? 1. SPA 与 MPA SPA: 单页Web应用, 就是只有一张Web页面的应用(只请求一个html文件), 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序. MPA: 每一次页面跳转时, 都会向后台服务器请求一个新的html文档, 这种类型的网站也就是多页网站, 也叫做多页Web应用. 在SPA中, 不会产生页面跳转, 但是一个页面中承载着很多功能页面(即组件), 只是更新显示不同的路由组件. 2.路由与路由器 路由器管理路由. 路由是什么? 可以说是键值对(即一种映射关系), key 是路径(即path), value: 对于后台来说是处理请求的回调函数, 对于前台来说是组件. 3.基本路由 基本步骤: ①先在项目src创建main.js和App.vue. ②从这之后vue组件分为: 非路由组件(一般放在/src/components下)和路由组件(一般放在/src/views或/src/pages目录下). ③这里在views目录下, 创建路由组件About.vue和Home.vue, 里面随便写点要显示的东西. ④创建文件/src/router/index.js 或/src/router.js, 在里面配置路由, 如下方代码. ⑤在 main.js 中配置路由器, 如下方代码. ⑥在页面组件对应地方生成路由连接 router-link. ⑦在页面组件对应地方指定要显示的路由组件 router-view. router.js: 123456789101112131415161718192021import Vue from 'vue'import VueRouter from 'vue-router'import About from './views/About'import Home from './views/Home'Vue.use(VueRouter)export default new VueRouter(&#123;//向外暴露路由对象即路由器 routes: [ &#123; path: '/about', component: About &#125;, &#123; path: '/home', component: Home &#125;, &#123; path: '/', redirect: '/about' &#125; ]&#125;) main.js: 1234567891011import Vue from 'vue'import App from './App'import router from './router'new Vue(&#123; el: '#app', components: &#123; App &#125;, template: '&lt;App/&gt;', router&#125;) App.vue: 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-offset-2 col-xs-8&quot;&gt; &lt;div class=&quot;page-header&quot;&gt;&lt;h2&gt;Router Test&lt;/h2&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-2 col-xs-offset-2&quot;&gt; &lt;div class=&quot;list-group&quot;&gt; &lt;!--生成路由链接--&gt; &lt;router-link to=&quot;/about&quot; class=&quot;list-group-item&quot;&gt;About&lt;/router-link&gt; &lt;router-link to=&quot;/home&quot; class=&quot;list-group-item&quot;&gt;Home&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-6&quot;&gt; &lt;div class=&quot;panel&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;!--显示上面路由链接对应的路由组件--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style scoped&gt; .router-link-active &#123; color: red !important; &#125;&lt;/style&gt; 编写使用路由实际上只有3步: ①编写路由组件 ②定义路由 ③使用路由: router-link和router-view标签. (这里注意keep-alive标签) keep-alive标签: 保存 router-view 显示的组件, 在切换组件时, 不销毁之前的组件. 4.嵌套路由 嵌套路由: 顾名思义, 在路由组件中在嵌套其他路由组件.(可以多层嵌套) ①先定义路由组件News.vue和Message.vue ②定义路由(或称注册路由). 修改router.js. 之前已经配置过了路由器. 没有配置的自行配置. ③在Home.vue中使用路由. News.vue: 12345678910111213141516171819&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;(news, index) in newsArr&quot; :key=&quot;index&quot;&gt;&#123;&#123;news&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; newsArr: [&apos;news001&apos;, &apos;news002&apos;, &apos;news003&apos;, &apos;news004&apos;] &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; Message.vue: 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;m in messages&quot; :key=&quot;m.id&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; messages: [] &#125; &#125;, mounted () &#123; setTimeout(() =&gt; &#123; //模拟ajax请求 const messages = [ &#123;id: 1, title: &apos;messages001&apos;&#125;, &#123;id: 3, title: &apos;messages003&apos;&#125;, &#123;id: 4, title: &apos;messages004&apos;&#125; ] this.messages = messages &#125;, 1000) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; router.js: 12345678910111213141516171819202122232425262728293031323334353637import Vue from 'vue'import VueRouter from 'vue-router'import About from './views/About'import Home from './views/Home'import News from './views/News'import Message from './views/Message'Vue.use(VueRouter)export default new VueRouter(&#123; routes: [ &#123; path: '/about', component: About &#125;, &#123; path: '/home', component: Home, children: [//定义home组件的子路由 &#123; path: '/home/news', component: News &#125;, &#123; path: 'message', component: Message &#125;, &#123;//默认路由 path: '', redirect: '/home/news' &#125; ] &#125;, &#123;//默认路由 path: '/', redirect: '/about' &#125; ]&#125;) Home.vue: 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;div&gt; &lt;ul class=&quot;nav nav-tabs&quot;&gt; &lt;!--生成路由链接--&gt; &lt;li&gt;&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!--显示当前路由组件--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;Home&apos; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue的UI组件库","slug":"Vue3-4","date":"2019-08-09T13:27:25.000Z","updated":"2019-10-06T09:45:41.000Z","comments":true,"path":"Vue3-4.html","link":"","permalink":"https://blog.crainyday.com/Vue3-4.html","excerpt":"Vue的UI组件库","text":"Vue的UI组件库 vue常用的组件库有两个: Mint UI(移动端) 和 Element(PC端). 这两个都是饿了么开源的组件库. 下面主要介绍一下 mint-ui 的使用. 1.使用前配置 首先下载mint-ui: npm install –save mint-ui 为了缩小项目整体体积, 借助 babel-plugin-component, 实现按需打包: 只需引入需要的组件, 以达到减小项目体积的目的. 安装 babel-plugin-component: npm install –save-dev babel-plugin-component 修改项目根目录下的 .babelrc 文件. 在 plugin 配置中添加一些新的配置. 新的 plugin 配置如下: 1234567&gt; &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;, [&quot;component&quot;, [&gt; &#123;&gt; &quot;libraryName&quot;: &quot;mint-ui&quot;,&gt; &quot;style&quot;: true&gt; &#125;&gt; ]]]&gt; 2.mint-ui mint-ui组件分为: 标签组建和非标签组建. 由于 mint-ui 是一个移动端的库, 需要在./src/index.html中引入一些移动端必要的第三方库 添加 meta: 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\" /&gt; 引入JS文件以解决移动端事件延迟的问题, 实现快速点击. 1234567891011&lt;script src=\"https://as.alipayobjects.com/g/component/fastclick/1.0.6/fastclick.js\"&gt;&lt;/script&gt; &lt;script&gt; if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false); &#125; if(!window.Promise) &#123; document.writeln('&lt;script src=\"https://as.alipayobjects.com/g/component/es6-promise/3.2.2/es6-promise.min.js\"'+'&gt;'+'&lt;'+'/'+'script&gt;'); &#125; &lt;/script&gt; 3.根据mint-ui官网的文档编写即可main.js: 123456789101112import Vue from 'vue'import App from './App'import &#123;Button&#125; from 'mint-ui'// 注册成为全局标签Vue.component(Button.name, Button)new Vue(&#123; el: '#app', components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) App.vue: 123456789101112131415161718&lt;template&gt; &lt;mt-button style=&quot;width: 100%;&quot; type=&quot;primary&quot; @click.native=&quot;handleClick&quot;&gt;primary&lt;/mt-button&gt;&lt;/template&gt;&lt;script&gt; import &#123;Toast&#125; from &apos;mint-ui&apos; export default &#123; methods: &#123; handleClick () &#123; Toast(&apos;提示信息&apos;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue发送ajax请求","slug":"Vue3-3","date":"2019-08-09T10:23:19.000Z","updated":"2019-10-06T09:45:34.000Z","comments":true,"path":"Vue3-3.html","link":"","permalink":"https://blog.crainyday.com/Vue3-3.html","excerpt":"Vue利用vue-resource和axios发送ajax请求","text":"Vue利用vue-resource和axios发送ajax请求 1. vue-resource vue的一个插件库, 非官方库, 在vue1.x中使用广泛. vue2.x中已很少使用, 之后都是用axios库. 使用步骤: ①当前项目中安装: npm install vue-resource –save ②在入口main.js文件中引入: import VueResource from ‘vue-resource’ ③调用Vue的use函数声明引用插件: Vue.use(VueResource) ④通过 this.$http.get()或this.$http.post()发送请求. App.vue: 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div v-if=&quot;repoURL&quot;&gt;most star repo is &lt;a target=&quot;_blank&quot; :href=&quot;repoURL&quot;&gt;&#123;&#123;repoName&#125;&#125;&lt;/a&gt;&lt;/div&gt; &lt;div v-else&gt;LOADING...&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; repoURL: &apos;&apos;, repoName: &apos;&apos; &#125; &#125;, mounted () &#123; const url = `https://api.github.com/search/repositories?q=vue&amp;sort=stars` this.$http.get(url).then( response =&gt; &#123;//请求成功时 const item = response.data.items[0] this.repoURL = item.html_url this.repoName = item.name &#125;, response =&gt; &#123;//请求失败时 alert(response) &#125; ) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 2. axios 通用的 ajax 请求库, 第三方库. 官方推荐使用. vue2.x中广泛使用. 使用步骤: ①当前项目中安装: npm install axios –save ②在哪个组件中使用, 就要: import axios from ‘axios’ ③之后通过 axios.get()或axios.post() 发送请求. App.vue: 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div v-if=&quot;repoURL&quot;&gt;most star repo is &lt;a target=&quot;_blank&quot; :href=&quot;repoURL&quot;&gt;&#123;&#123;repoName&#125;&#125;&lt;/a&gt;&lt;/div&gt; &lt;div v-else&gt;LOADING...&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from &apos;axios&apos; export default &#123; data () &#123; return &#123; repoURL: &apos;&apos;, repoName: &apos;&apos; &#125; &#125;, mounted () &#123; const url = `https://api.github.com/search/repositories?q=vue&amp;sort=stars` axios.get(url).then( response =&gt; &#123;//请求成功时 const item = response.data.items[0] this.repoURL = item.html_url this.repoName = item.name &#125;, response =&gt; &#123;//请求失败时 alert(response) &#125; )//.catch(error =&gt; &#123;//请求失败的回调函数也可以这样写 // alert(error) // &#125;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue存储数据与组件间的通信续","slug":"Vue3-2","date":"2019-08-09T03:34:25.000Z","updated":"2019-10-06T09:45:26.000Z","comments":true,"path":"Vue3-2.html","link":"","permalink":"https://blog.crainyday.com/Vue3-2.html","excerpt":"存储数据——即将数据缓存. 这里用 localStorage 缓存. 这里还用到了深度监视. Vue中组件通信的其他方式.","text":"存储数据——即将数据缓存. 这里用 localStorage 缓存. 这里还用到了深度监视. Vue中组件通信的其他方式. 1. localStorage localstorage 生命周期是永久, 这意味着除非用户显示的在浏览器提供的UI上清除 localStorage 信息, 否则这些信息将永远存在. 存放数据大小为一般为5 MB, 而且它仅在客户端(即浏览器)中保存, 不参与和服务器的通信. localStorage 存储的数据都是以文件存储的, 数据格式都是文本类型(即字符串). 所以这就需要转换数据格式. 存储数据前: 利用JSON.stringify将对象转换成字符串 获取数据后: 利用JSON.parse将字符串转换成对象 123456JSON.stringify(Object)//将对象转换成字符串并返回JSON.parse(str)//将字符串转换成对象并返回localStorage.setItem(\"key\",\"value\");//以\"key\"为名称存储一个值\"value\"localStorage.getItem(\"key\");//获取名称为\"key\"的值localStorage.removeItem(\"key\");//删除名称为\"key\"的信息.localStorage.clear();//清空localStorage中所有信息 2.存取时机 定义数据的时候, 将要用的数据从localStorage中取出数据. 当数据改变时, 将数据重新存到localStorage中. 提到了数据改变, 就用到了深度监视. 深度监视某个属性: 1234567891011121314151617181920&lt;script&gt; export default &#123; data () &#123; return &#123; //此时定义数据,从localStorage中将想要的数据取出. //一开始localStorage中没有todos_key. todos: JSON.parse(window.localStorage.getItem(&apos;todos_key&apos;) || &apos;[]&apos;) &#125; &#125;, watch: &#123; todos: &#123; deep: true,//深度监视 handler: function (value) &#123; window.localStorage.setItem(&apos;todos_key&apos;, JSON.stringify(value)) &#125; &#125; &#125; //......// &#125;&lt;/script&gt; 3.数据存储优化 将上述的localStorage的读写过程封装在一个JS文件中. 4.组件间的通信①自定义事件 之前我们组件之间的通信都是用的 propos 属性. 现在用自定义事件来进行组件通信. 自定义事件只能用于组件之间传递函数, 不能传递其他的. 一说到事件, 首先应考虑两点: ①绑定事件监听. ②触发(分发)事件. 在这里, 绑定自定义事件有两种方法: ① @事件名=’回调函数’. 例在Component标签对象上绑定myEvent事件: \\&lt;Component @myEvent=”myEvent”/>. 这种方式只能用于父子组件之间的通信. ② 利用 $on 函数给特定标签对象绑定事件. 先给该标签对象设置 ref 属性, 再用 this.$refs.xxx.$on(‘自定义事件名’, 回调函数). 触发事件的方式: 通过 $emit 函数触发自定义事件. this.$emit(‘自定义事件名’,参数…). ②消息订阅与发布 这种组件通信需要一个PubSub库. 通过 npm install –save pubsub-js 安装库到当前项目. 消息订阅可以类比绑定事件, 消息发布可以类比触发事件. 订阅消息与绑定事件都是一些异步操作, 在钩子函数 mounted 中书写相关代码即可. 消息订阅与发布的一种好处就是, 没有组件之间的限制, 任何组件之间都可以用. 步骤: ①import库 ②在mounted中订阅消息 PubSub.subscribe(‘消息名’, 回调函数) ③在需要时发布消息. PubSub.publish(‘消息名’, 参数…) 123PubSub.subscribe('delToDos', (msg, index) =&gt; &#123;//最好用箭头函数, 防止this出错 this.delToDos(index)&#125;) ③slot 此种方式用于父组件向子组件传递标签数据. 在子组件的内部, 已经事先定义好了一些”插口”, 父组件只需要说明把要显示的标签”插到”哪个插口即可. 这种方式不同于其他几种, 其他的都是传递的消息或数据. 这种方式适用于, 多个父组件共用一个子组件且要求的显示效果不同. 子组件声明插口, Child.vue: 1234567891011&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;label&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt; &lt;/label&gt; &lt;span&gt; &lt;slot name=&quot;slot2&quot;&gt;&lt;/slot&gt; &lt;/span&gt; &lt;slot name=&quot;slot3&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 父组件根据插口属性将标签插入子组件, Parent.vue: 123456789&lt;template&gt; &lt;div class=&quot;demo&quot;&gt; &lt;Child&gt; &lt;input type=&quot;checkbox&quot; slot=&quot;slot1&quot;/&gt; &lt;span slot=&quot;slot2&quot; &gt;Hello Slot2&lt;/span&gt; &lt;button slot=&quot;slot3&quot;&gt;清除已完成任务&lt;/button&gt; &lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"JS数组函数","slug":"Vue3-1","date":"2019-08-09T00:42:33.000Z","updated":"2019-10-06T09:45:18.000Z","comments":true,"path":"Vue3-1.html","link":"","permalink":"https://blog.crainyday.com/Vue3-1.html","excerpt":"介绍几个常用的JS数组函数 filter、forEach、map、reduce、splice、sort","text":"介绍几个常用的JS数组函数 filter、forEach、map、reduce、splice、sort 1. filter filter() 方法创建一个新的数组并返回, 新数组中的元素一定是原数组中的元素, 不改变原来的数组. 过滤原数组产生新数组. array.filter(function(currentValue,index,arr), thisValue) thisValue(对象)用作回调函数中的 “this” 的值 若使用箭头函数: array.filter((currentValue,index,arr) =&gt; {}), 在箭头函数里使用this, 当前无this就会去父作用域寻找. 2. forEach 数组每个元素都执行一次回调函数. array.forEach(function(currentValue, index, arr), thisValue) 3. map 通过指定函数处理数组的每个元素, 并返回处理后的数组. 返回一个新数组, 数组中的元素为原始数组元素调用函数处理后的值. array.map(function(currentValue,index,arr), thisValue) 4. reduce 将数组元素计算为一个值(从左到右). 接收一个函数作为累加器, 数组中的每个值(从左到右)开始缩减, 最终计算为一个值. array.reduce(function(total, currentValue, currentIndex, arr), initialValue) initialValue: 计算的初始值. 5. splice 从数组中添加或删除元素. array.splice(index,howmany,item1,…..,itemX) 6. sort 对数组元素重新排序. array.sort(sortfunction)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue组件化编码之添加交互","slug":"Vue2-3","date":"2019-08-08T10:46:25.000Z","updated":"2019-10-06T09:45:09.000Z","comments":true,"path":"Vue2-3.html","link":"","permalink":"https://blog.crainyday.com/Vue2-3.html","excerpt":"在之前的项目基础上, 实现交互添加、交互删除功能.","text":"在之前的项目基础上, 实现交互添加、交互删除功能. 首先, 要明白实现这些交互功能要先添加相应的事件监听. 之后, 要明白: 这些交互无非就是一些改变页面原始数据的操作. 即我们需要更新页面数据. 这里要知道: 数据在哪个组件定义的, 更新数据的方法就应该定义在哪个组件. 根据需要, 父组件将该方法传递给子组件, 子组件接收后调用它实现数据更新. 1.交互添加 在App组件中添加addComment方法, 来向comments数组中插入新的评论数据. 该方法不是在本组件中调用, 而是在Add组件中调用. 因此需要将该方法, 传递给其子组件Add. 传递的方法与传递数据的方法一致. 子组件声明接收属性后调用. 数组的unshift方法: 向数组的开头添加一个或更多元素,并返回新的长度. array.unshift(el1,el2,….,el3). 2.交互删除 在App组件中添加delComment(index)方法, 来在comments数组删除一条评论数据. 该方法不是在本组件中调用, 而是在Item组件中调用. 因此需要将该方法, 向下传递两次给其子孙组件Item. 传递的方法与传递数据的方法一致. 子组件声明接收属性后调用. 数组的splice方法: 用于添加或删除数组中的元素.array.splice(index,howmany,item1,…,itemX) 最后的示例项目src: 一定不要忘了, 在这个项目里我们引用了第三方库 bootstrap.css 需要在项目根目录的index.html中引入.","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue组件化编码小案例","slug":"Vue2-2","date":"2019-08-08T01:02:25.000Z","updated":"2019-10-06T09:45:01.000Z","comments":true,"path":"Vue2-2.html","link":"","permalink":"https://blog.crainyday.com/Vue2-2.html","excerpt":"Vue的组件化编码——小案例——初始化显示","text":"Vue的组件化编码——小案例——初始化显示 1.组件化编码的步骤 分三步: ①拆分页面. ②先实现一个静态页面. ③再实现动态页面. 静态组件显示的内容数据是固定的、没有交互, 动态组件数据是动态的、存在交互. 将本例中的静态页面划分为如下4个组件: 本例的HTML:点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./bootstrap.css\"&gt; &lt;style&gt; .reply &#123; margin-top: 0px; &#125; li &#123; transition: .5s; overflow: hidden; &#125; .handle &#123; width: 40px; border: 1px solid #ccc; background: #fff; position: absolute; right: 10px; top: 1px; text-align: center; &#125; .handle a &#123; display: block; text-decoration: none; &#125; .list-group-item .centence &#123; padding: 0px 50px; &#125; .user &#123; font-size: 22px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;div&gt; &lt;header class=\"site-header jumbotron\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-12\"&gt; &lt;h1&gt;请发表对Vue的评论&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/header&gt; &lt;div class=\"container\"&gt; &lt;div class=\"col-md-4\"&gt; &lt;form class=\"form-horizontal\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"用户名\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;评论内容&lt;/label&gt; &lt;textarea class=\"form-control\" rows=\"6\" placeholder=\"评论内容\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-offset-2 col-sm-10\"&gt; &lt;button type=\"button\" class=\"btn btn-default pull-right\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"col-md-8\"&gt; &lt;h3 class=\"reply\"&gt;评论回复：&lt;/h3&gt; &lt;h2 style='display: none'&gt;暂无评论，点击左侧添加评论！！！&lt;/h2&gt; &lt;ul class=\"list-group\"&gt; &lt;li class=\"list-group-item\"&gt; &lt;div class=\"handle\"&gt; &lt;a href=\"javascript:;\"&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;p class=\"user\"&gt;&lt;span &gt;xxx&lt;/span&gt;&lt;span&gt;说:&lt;/span&gt;&lt;/p&gt; &lt;p class=\"centence\"&gt;Vue不错!&lt;/p&gt; &lt;/li&gt; &lt;li class=\"list-group-item\"&gt; &lt;div class=\"handle\"&gt; &lt;a href=\"javascript:;\"&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;p class=\"user\"&gt;&lt;span &gt;yyy&lt;/span&gt;&lt;span&gt;说:&lt;/span&gt;&lt;/p&gt; &lt;p class=\"centence\"&gt;Vue有点难!&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 之后开始正式拆分组件. 2.创建Vue组件 ①先清空src目录, 并新建空白main.js入口文件. ②将第三方库bootstrap.css文件放在static/css目录下, 并在当前Vue项目的index.html中引入. ③拆分编写各组件, 实现静态页面. ④在静态页面添加数据和交互, 实现动态页面. ①拆分搭建静态页面App.vue:点击显/隐内容 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;header class=&quot;site-header jumbotron&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-12&quot;&gt; &lt;h1&gt;请发表对Vue的评论&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;Add/&gt; &lt;List/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Add from &apos;./components/Add&apos; import List from &apos;./components/List&apos; export default &#123; components: &#123; Add, List &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; main.js: 点击显/隐内容 123456789import Vue from 'vue'import App from './App'new Vue(&#123; el: '#app', components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) Add.vue:点击显/隐内容 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;用户名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;评论内容&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; rows=&quot;6&quot; placeholder=&quot;评论内容&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default pull-right&quot;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;Add&apos; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; List.vue:点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;h3 class=&quot;reply&quot;&gt;评论回复：&lt;/h3&gt; &lt;h2 style=&apos;display: none&apos;&gt;暂无评论，点击左侧添加评论！！！&lt;/h2&gt; &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot;&gt; &lt;div class=&quot;handle&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;p class=&quot;user&quot;&gt;&lt;span &gt;xxx&lt;/span&gt;&lt;span&gt;说:&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;centence&quot;&gt;Vue不错!&lt;/p&gt; &lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt; &lt;div class=&quot;handle&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;p class=&quot;user&quot;&gt;&lt;span &gt;yyy&lt;/span&gt;&lt;span&gt;说:&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;centence&quot;&gt;Vue有点难!&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;List&apos; &#125;&lt;/script&gt;&lt;style scoped&gt; .reply &#123; margin-top: 0px; &#125; li &#123; transition: .5s; overflow: hidden; &#125; .handle &#123; width: 40px; border: 1px solid #ccc; background: #fff; position: absolute; right: 10px; top: 1px; text-align: center; &#125; .handle a &#123; display: block; text-decoration: none; &#125; .list-group-item .centence &#123; padding: 0px 50px; &#125; .user &#123; font-size: 22px; &#125;&lt;/style&gt; 目前, 还没进一步拆分List.vue组件, 等到添加动态组件时再进一步拆分. 最后, npm run dev当前项目显示如下图, 达到了预期效果. ②添加数据 观察下面图片, 先分析图中一条条的评论中数据类型. 每条数据是一个对象, 包含: username、content属性. List组件区域整体数据构成对象数组 comments. 在分析数据 comments 放在哪个组件. 由于 Add 组件也会用到该数据(向数组中添加新的评论信息), 所以将 comments 放到 Add 和 List 组件的父组件 App 中定义. 在哪定义数据 被多个组件共用的数据, 放到它们的父组件中. 只有当前组件用到的数据, 放到当前组件中即可. 如何传递数据 本组件中定义的数据, 仅在当前组件中可用. 但在父组件中定义的数据, 如何传递到其他组件呢? 这就涉及到一个术语: 组件间通信. 最简单最原始的方式: 通过标签属性传递 例: 在App组件中将comments传递给List组件 123&lt;!--注意属性名一定要用强制数据绑定--&gt;&lt;!--注意属性名可以自定义, .但一般与要传递的数据一致--&gt;&lt;List :comments=&apos;comments&apos;/&gt; 如何接收数据 接收数据, 在Vue中叫做声明接收属性: 这个属性就会成为组件对象的属性. 1234567&lt;script&gt; export default &#123; props: &#123; comments: Array &#125; &#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"vue-cli","slug":"Vue2-1","date":"2019-08-07T02:12:25.000Z","updated":"2019-10-06T09:44:53.000Z","comments":true,"path":"Vue2-1.html","link":"","permalink":"https://blog.crainyday.com/Vue2-1.html","excerpt":"vue的组件化编码. Vue脚手架——即vue-cli","text":"vue的组件化编码. Vue脚手架——即vue-cli 1.用vue-cli创建一个模板项目 vue-cli是vue官方提供的脚手架工具. 实际上也是一个库, 它从网上下载一个模板项目 相关的命令: 12345678910&gt; #安装脚手架&gt; npm install -g vue-cli&gt; #初始化项目xxx&gt; vue init webpack xxx&gt; cd xxx&gt; #下载项目文件&gt; npm install&gt; #编译运行项目&gt; npm run dev&gt; 之后浏览器访问: http://localhost:8080/ 即可访问该项目. 在这里我们用的是 webpack 构建的脚手架, 当然也有其他的. ①项目整体目录结构 .babelrc文件是babe的配置文件. babe 的功能: JSX转JS、ES6转ES5等. rc 即 runtime control(运行时控制) .eslintignore文件. ESlint检查时忽略的文件的配置信息. .eslintrc.js文件是 eslint 的配置文件. ESLint 是一个ECMAScript/JavaScript 语法规则和代码风格的检查工具. package.json文件是当前应用的描述文件. ②src目录结构 assets文件夹与 static文件夹的区别: 相同点: 文件夹里的资源在页面中都是可以引用的. 不同点: 在js中使用assets下面的资源, 不能直接写路径, 路径会经过webpack中file-loader的编译. 动态绑定assets中的资源时, 要用require来引入该资源. 对于非第三方资源, 推荐放在assets中, 这里面的文件会经过webpack打包、重新编译. 而static中的文件, 不会经过重新编译. 项目在经过打包后, 会生成dist文件夹, static中的文件只是复制到dist文件夹中. static中建议放一些外部第三方资源文件. 2.基于脚手架编写项目 这里从头开始编写. 先删除项目src中的components文件夹、App.vue文件、main.js入口文件. 先在src下新建一个main.js入口文件, 接着新建一个空白的vue文件和components文件夹. 在components文件夹下新建一个HelloWorld.vue文件. 在以上vue文件中编写上vue的模板代码: 如下. 之后可以自己创建一个vue模板文件. 之后依次编写HelloWorld.vue、App.vue、main.js文件. vue组件的使用步骤: ①引入组件 ②映射组件标签 ③使用组件标签 vue模板代码: 12345678910111213&lt;template&gt; &lt;/template&gt;&lt;script&gt; export default &#123;//固定语法,向外暴露里面的配置对象.与编写Vue配置对象一致 &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; HelloWorld.vue: 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;p class=&quot;msg&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123;//在Vue配置对象中data可以写对象也可以写函数. 但在这里必须写函数. return &#123; msg:&apos;Hello Vue!!!&apos;, &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .msg&#123; color: red; font-size: 20px; &#125;&lt;/style&gt; App.vue: 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;img class=&quot;logo&quot; src=&quot;./assets/logo.png&quot; alt=&quot;logo&quot;&gt; &lt;!--3.使用组件标签--&gt; &lt;HelloWorld/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //1.引入组件 import HelloWorld from &apos;./components/HelloWorld.vue&apos; export default &#123; components:&#123; //2.映射组件标签 HelloWorld &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .logo&#123; width: 200px; height: 200px; &#125;&lt;/style&gt; main.js: 123456789101112131415/*项目入口JS文件 *///1.引入组件import Vue from 'vue'import App from './App.vue'new Vue(&#123; el:'#app', components:&#123; //2.映射组件标签 App &#125;, template: '&lt;App/&gt;'//3.使用组件标签&#125;) 3.打包发布项目 打包项目: npm run build 发布项目: 发布1: 使用静态服务器工具包. 123&gt; npm install -g serve #全局安装静态服务器&gt; serve dist #运行项目, 访问: http://localhost:5000 即可&gt; 发布2:使用动态web服务器(像: tomcat) 12345678&gt; //1.先修改配置: webpack.prod.conf.js&gt; output:&#123;&gt; publicPath:'/xxx/' //xxx为打包文件夹的名字,注意名字前后一定要加'/'&gt; &#125;&gt; //2.修改完配置后,再运行: npm run build 重新打包&gt; //3.然后将dist文件夹名修改为上面的:xxx&gt; //4.将xxx文件夹拷贝到正在运行的服务器根目录下.&gt; 4.ESLint ESLint是一个很流行的代码规范检查工具, 基本已经替代了JSLint. ESLint定义了一系列规则, 一旦你违反了其中一个规则, ESLint就会提示你. 从用脚手架编写完项目, 之后运行, 你会发现WebStrom的Terminal里ESLint所给出的提示, 如下图. 当然, 作为一个专业的程序员. 看见它们你肯定会有强迫症, 想去掉它们. ①一个个的根据ESLint的提示去掉, 以后写的时候注意. ②通过配置项目根目录下的.eslintrc.js文件去掉, 更改里面的 rules对象配置即可. ③霸道的方法, 直接更改.eslintignore配置文件, 将要忽略的文件名写在里面.","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"vue常用的一些东西","slug":"Vue1-5","date":"2019-08-06T10:05:50.000Z","updated":"2019-10-06T09:44:45.000Z","comments":true,"path":"Vue1-5.html","link":"","permalink":"https://blog.crainyday.com/Vue1-5.html","excerpt":"表单数据的自动收集 生命周期、过渡&amp;动画、过滤器","text":"表单数据的自动收集 生命周期、过渡&amp;动画、过滤器 1. vue的生命周期 vue的生命周期分为三大部分: ①初始化显示 ②更新显示 ③销毁vue实例. vue执行到特定的生命周期后, 会依次调用对应的回调函数. 以下回调函数从上到下依次执行. 注意: 在vue中这些函数被称为 钩子函数. ①初始化显示阶段. 该阶段回调函数只会被调用一次 before Create() created() before Mount() mount: 挂载, 表示从内存挂载到HTML页面 mounted() ②更新显示阶段. 该阶段回调函数会被调用多次 before Update() updated() ③销毁(死亡)阶段. 该阶段回调函数只会被调用一次 before destroy() destroyed() 常用的生命周期回调函数 mounted(): 发送ajax请求, 启动定时器等异步任务. before Destroy(): 做一些收尾工作, 如: 清除定时器等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;button @click=\"destroyVM\"&gt;销毁VM对象&lt;/button&gt; &lt;p v-show=\"isShow\"&gt;Hello Vue!!!&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el:'#demo', data:&#123; isShow:true, &#125;, beforeCreate()&#123; console.log('beforeCreate()') &#125;, created()&#123; console.log('created()') &#125;, beforeMount()&#123; console.log('beforeMount()') &#125;, mounted()&#123; console.log('mounted()') this.intervalID = setInterval(()=&gt;&#123; this.isShow = !this.isShow &#125;,1000) &#125;, beforeUpdate()&#123; console.log('beforeUpdate()') &#125;, updated()&#123; console.log('updated()') &#125;, beforeDestroy()&#123; console.log('beforeDestroy()') clearInterval(this.intervalID) &#125;, destroyed()&#123; console.log('destroyed()') &#125;, methods:&#123; destroyVM()&#123; this.$destroy() &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 2.过渡&amp;动画 过渡: transition. 动画: animation. &emsp;&emsp;这实际上是说, 我们网页中的一个HTML元素, 在显示和隐藏的过程中有一些特殊的过渡和动画样式. vue的动画, 实际上是操作的 CSS 的 transition 或 animation, 通过给目标元素动态的添加或移除特定的 class 实现. vue中过渡&amp;动画相关的类名: xxx-enter-active: 指定显示的 transition. xxx-leave-active: 指定隐藏的 transition. xxx-enter/xxx-leave-to: 指定隐藏时的样式. vue做基本过渡&amp;动画的步骤: 在目标元素外包裹\\&lt;transition name=”xxx”>\\&lt;/transition>标签 定义 class 样式: ①指定过渡样式: transition. ②指定隐藏时的样式: opacity/其他 便于理解, 请看下图: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type=\"text/css\"&gt; /*显示和隐藏的过滤效果*/ .fade-enter-active,.fade-leave-active&#123; transition: opacity 2s; &#125; /*隐藏时的样式*/ .fade-enter,.fade-leave-to&#123; opacity: 0; &#125; /*显示的过滤效果*/ .move-enter-active&#123; transition: all 1s; &#125; /*隐藏的过滤效果*/ .move-leave-active&#123; transition: all 3s; &#125; /*隐藏时的样式*/ .move-enter,.move-leave-to&#123; opacity: 0; transform: translateX(20px); &#125; .bounce-enter-active &#123; animation: bounce-in .5s; &#125; .bounce-leave-active &#123; animation: bounce-in .5s reverse; &#125; @keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;button @click=\"isShow=!isShow\"&gt;显示/隐藏&lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-show=\"isShow\"&gt;Hello Vue!!!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;div id=\"demo2\"&gt; &lt;button @click=\"isShow=!isShow\"&gt;显示/隐藏&lt;/button&gt; &lt;transition name=\"move\"&gt; &lt;p v-show=\"isShow\"&gt;Hello Vue!!!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;div id=\"demo3\"&gt; &lt;button @click=\"isShow=!isShow\"&gt;显示/隐藏&lt;/button&gt; &lt;br&gt; &lt;transition name=\"bounce\"&gt; &lt;p style=\"display: inline-block;\" v-show=\"isShow\"&gt;Hello Vue!!!&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el:\"#demo\", data()&#123; return &#123; isShow:true, &#125; &#125; &#125;) new Vue(&#123; el:\"#demo2\", data()&#123; return &#123; isShow:true, &#125; &#125; &#125;) new Vue(&#123; el:\"#demo3\", data()&#123; return &#123; isShow:true, &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 3.过滤器 过滤器就是对我们要在网页显示的数据进行一些格式化操作后再显示. 注意: 并没有改变原本的数据, 而是产生新的对应的数据 过滤器的使用步骤: 定义过滤器.12345&gt; Vue.filter(filterName, function(value[,arg1,arg2,...])&#123;&gt; // 进行一定的数据处理&gt; return newValue&gt; &#125;)&gt; 使用过滤器. 注意: 原始数据之后和过滤器之前都有一个空格. 123&gt; &lt;div&gt;&#123;&#123;myData | filterName&#125;&#125;&lt;/div&gt;&gt; &lt;div&gt;&#123;&#123;myData | filterName(arg)&#125;&#125;&lt;/div&gt;&gt; 123456789101112131415161718192021222324&lt;body&gt; &lt;div id=\"test\"&gt; &lt;h2&gt;显示格式化的日期时间&lt;/h2&gt; &lt;p&gt;未处理:&#123;&#123;datetime&#125;&#125;&lt;/p&gt; &lt;p&gt;完整版:&#123;&#123;datetime | datetimeFilter&#125;&#125;&lt;/p&gt; &lt;p&gt;年月日:&#123;&#123;datetime | datetimeFilter('YYYY-MM-DD')&#125;&#125;&lt;/p&gt; &lt;p&gt;时分秒:&#123;&#123;datetime | datetimeFilter('HH:mm:ss')&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/moment.js/2.24.0/moment.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; Vue.filter('datetimeFilter',function (value,format) &#123; //设置形参默认值也可以 //function (value,format=\"YYYY-MM-DD HH:mm:ss\") return moment(value).format(format||\"YYYY-MM-DD HH:mm:ss\") &#125;) new Vue(&#123; el:\"#test\", data:&#123; datetime:new Date(), &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 4. vue指令 vue指令分为: 内置指令和自定义指令. ①vue内置指令 常见的一些内置vue指令: v-text: 更新元素的 test Content. v-html: 更新元素的 inner HTML. v-if: 如果为 true, 当前标签才会输出到页面. v-else: 如果为 false, 当前标签才会输出到页面. v-show: 通过控制元素的 display 来控制元素的显示与隐藏. v-for: 遍历数组/对象. v-on: 绑定事件监听, 一般简写为 “@” v-bind: 强制绑定解析表达式, 一般简写为 “:” v-model: 双向数据绑定. ref: 为HTML元素指定唯一标识, vue对象通过 $refs 属性访问这个元素对象. v-cloak: 防止闪现, 与 CSS 配合: [v-cloak]{display: none} 如下图, 在经过vue解析之后, 才会将原始HTML文件中的vue指令和一些表达式去除或替换. 如果解析过慢, 或vue等待的数据还没有到来, 此时HTML页面就会出现如下图的情况. 为了防止, 出现了 v-cloak 指令. 注意: 在网页中第一次运行下述代码时, 会出现上述图片中的情况. 12345678910111213141516171819202122&lt;body&gt; &lt;div id=\"test\"&gt; &lt;p ref=\"example\"&gt;Hello Vue!!!&lt;/p&gt; &lt;button @click=\"output\"&gt;弹出&lt;/button&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; alert(\"----\") new Vue(&#123; el:'#test', data:&#123; msg:'I love China!', &#125;, methods:&#123; output() &#123; alert(this.$refs.example.textContent) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; ②自定义vue指令 有两种方法: 全局注册和局部注册. 全局注册的指令, 当前页面的所有部分都可以用. 局部注册的指令, 只有在注册范围内可用. 全局注册: 1234&gt; Vue.directive('my-directive', function(el, binding)&#123;&gt; el.innerHTML = binding.value.toupperCase()&gt; &#125;)&gt; 局部注册: 12345678&gt; directives : &#123;&gt; 'my-directive' : &#123;&gt; bind (el, binding) &#123;&gt; el.innerHTML = binding.value.toupperCase()&gt; &#125;&gt; &#125;&gt; &#125;&gt; 注意: 下述代码有错误, 局部注册的 lower-text 指令, 在 test2 中不可用. 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;div id=\"test\"&gt; &lt;p v-upper-text=\"msg\"&gt;&lt;/p&gt; &lt;p v-lower-text=\"msg\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=\"test2\"&gt; &lt;p v-upper-text=\"msg\"&gt;&lt;/p&gt; &lt;p v-lower-text=\"msg\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; Vue.directive('upper-text',function (el,binding) &#123; //全局注册的 upper-text 指令, 在本页面的所有vue对象中都可用 //el: 指令属性所在的标签对象 //binding: 包含指令相关信息数据的对象 el.textContent = binding.value.toUpperCase() &#125;) new Vue(&#123; el:'#test', data:&#123; msg:'I love China!', &#125;, directives:&#123; //局部注册的 lower-text 指令, 在 test2 里面不可用,会报错 'lower-text'(el,binding)&#123; el.textContent = binding.value.toLowerCase() &#125; &#125; &#125;) new Vue(&#123; el:'#test2', data:&#123; msg:'I love China!', &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 5. vue插件 开发插件: 新建 JS 文件, 将插件的所有代码放到匿名函数调用里. 声明插件对象, 给插件对象添加 install 方法. 添加全局方法或属性, 用Vue函数对象点’’Vue.’’添加. 添加全局资源: 指令/过滤器/过渡等, 用Vue函数对象点’’Vue.’’添加. 添加实例方法, 通过 Vue.prototype 添加. 为了区别全局方法, 实例方法以”$”开头. 使用插件: 在引入Vue.js后, 先引入外部vue插件库, 再用 Vue.use(MyPlugin) 声明使用该插件. 实际上这调用了 插件对象的 install 方法, 将插件中的功能”安装”到 Vue 里. vue-myPlugin.js: 12345678910111213141516171819202122(function (window) &#123;//匿名函数调用包裹插件代码, 更规范 //1.创建需要向外暴露的插件对象 const MyPlugin = &#123;&#125; //2.vue插件必须暴露一个 install 方法,且第一个参数必须是Vue MyPlugin.install = function (Vue, options) &#123; //3.添加插件功能 // ①. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; console.log('Vue函数对象的myGlobalMethod()') &#125; // ②. 添加全局资源 Vue.directive('my-directive',function (el, binding) &#123; el.textContent = 'my-directive---'+binding.value &#125;) // ④. 添加实例方法. Vue.prototype.$myMethod = function () &#123; console.log('vm---$myMethod()') &#125; &#125; //4.向外暴露插件对象 window.MyPlugin = MyPlugin&#125;)(window) 使用自定义插件: 12345678910111213141516171819&lt;body&gt; &lt;div id=\"test\"&gt; &lt;p v-my-directive=\"msg\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"js/vue-myPlugin.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //声明使用插件 Vue.use(MyPlugin) Vue.myGlobalMethod() const vm = new Vue(&#123; el:'#test', data:&#123; msg:'I Love China!', &#125;, &#125;) vm.$myMethod() &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue的事件处理与表单输入绑定","slug":"Vue1-4","date":"2019-08-06T09:28:12.000Z","updated":"2019-10-06T09:44:37.000Z","comments":true,"path":"Vue1-4.html","link":"","permalink":"https://blog.crainyday.com/Vue1-4.html","excerpt":"vue中事件的处理与表单数据的自动收集","text":"vue中事件的处理与表单数据的自动收集 1.事件处理①.绑定监听 vue中绑定监听最原始的做法: v-on:事件名=’响应函数’ 简化做法: @事件名=’响应函数’ 1234567891011121314151617181920&lt;body&gt; &lt;div id=\"test\"&gt; &lt;button @click=\"test1\"&gt;test1&lt;/button&gt;&lt;!--相当于&lt;button @click=\"test1($event)\"&gt;test1&lt;/button&gt;--&gt; &lt;button @click=\"test2('hello',$event)\"&gt;test2&lt;/button&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el:'#test', methods:&#123; test1(event)&#123; alert(event.target.innerHTML) &#125;, test2(msg,event)&#123; alert(msg + \"---\" + event.target.innerHTML) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; ②.事件修饰符 两个事件修饰符: stop和prevent. stop修饰符用以阻止事件冒泡. 也可以通过当前event的stopPropagation()方法阻止事件冒泡 prevent修饰符用以取消组件的默认行为. 也可以通过当前event的preventDefault()方法取消组件的默认行为 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id=\"test\"&gt; &lt;div style=\"width:200px;height: 200px;background-color: red\" @click=\"test3\"&gt; &lt;div style=\"width:100px;height: 100px;background-color: blue\" @click.stop=\"test4\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;a href=\"https://www.baidu.com/\" @click.prevent=\"test5\"&gt;GO&lt;/a&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el:'#test', methods:&#123; test3(event)&#123; alert('outer') &#125;, test4()&#123; //也可以通过当前event的stopPropagation()方法阻止事件冒泡 alert('inner') &#125;, test5()&#123; //也可以通过当前event的preventDefault()方法取消组件的默认行为 alert('test5'); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; ③.按键修饰符 只有一般常用的按键才有按键修饰符, 如: enter、space、alt、ctrl等. 也可以判断当前event的keyCode值实现 1234567891011121314151617&lt;body&gt; &lt;div id=\"test\"&gt; &lt;input type=\"text\" @keyup.enter=\"test6\"&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el:'#test', methods:&#123; test6(event)&#123; //除了按键修饰符,也可以判断当前event的keyCode实现 alert(event.target.value) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 2.表单输入绑定 常用的一些表单控件: test/textarea、password、radio、checkbox、select-option等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;form action=\"/xxx\" @submit.prevent=\"handleSub\"&gt; &lt;span&gt;用户名: &lt;/span&gt; &lt;input type=\"text\" v-model=\"username\" placeholder=\"请输入用户名\"&gt;&lt;br&gt; &lt;span&gt;密码: &lt;/span&gt; &lt;input type=\"password\" v-model=\"password\"&gt;&lt;br&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;input type=\"radio\" id=\"female\" value=\"女\" v-model=\"sex\"&gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;input type=\"radio\" id=\"male\" value=\"男\" v-model=\"sex\"&gt; &lt;label for=\"male\"&gt;男&lt;/label&gt;&lt;br&gt; &lt;span&gt;爱好: &lt;/span&gt; &lt;input type=\"checkbox\" id=\"basket\" value=\"basket\" v-model=\"likes\"&gt; &lt;label for=\"basket\"&gt;篮球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"foot\" value=\"foot\" v-model=\"likes\"&gt; &lt;label for=\"foot\"&gt;足球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"pingpong\" value=\"pingpong\" v-model=\"likes\"&gt; &lt;label for=\"pingpong\"&gt;乒乓&lt;/label&gt;&lt;br&gt; &lt;span&gt;城市: &lt;/span&gt; &lt;select v-model=\"cityID\"&gt; &lt;option value=\"\"&gt;未选择&lt;/option&gt; &lt;option :value=\"city.id\" v-for=\"(city,index) in citys\" :key=\"city.id\"&gt; &#123;&#123;city.name&#125;&#125; &lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;span&gt;介绍: &lt;/span&gt; &lt;textarea rows=\"10\" v-model=\"desc\"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el:'#demo', data:&#123; username:\"\", password:\"\", sex:'女', likes:['pingpong'], cityID:\"1\", citys:[ &#123;id:1,name:\"BJ\"&#125;, &#123;id:2,name:\"SD\"&#125;, &#123;id:3,name:\"SH\"&#125; ], desc:\"\" &#125;, methods:&#123; handleSub()&#123; console.log(this.username,this.password) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue中的两个常用渲染","slug":"Vue1-3","date":"2019-08-06T00:22:25.000Z","updated":"2019-10-06T09:44:29.000Z","comments":true,"path":"Vue1-3.html","link":"","permalink":"https://blog.crainyday.com/Vue1-3.html","excerpt":"条件渲染与列表渲染 const、var、let 的区别","text":"条件渲染与列表渲染 const、var、let 的区别 1.条件渲染 条件渲染指令: &emsp;&emsp;v-if、v-else、v-show v-if与v-show的比较: 如果需要频繁的切换用 v-show 更好, 下面将告诉你为什么. 123456789101112131415161718192021222324&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;p v-if=\"ok\"&gt;成功&lt;/p&gt; &lt;p v-else&gt;失败&lt;/p&gt; &lt;!--&lt;button @click=\"shift\"&gt;切换&lt;/button&gt;--&gt; &lt;button @click=\"ok=!ok\"&gt;切换&lt;/button&gt; &lt;p v-show=\"ok\"&gt;表白成功&lt;/p&gt; &lt;p v-show=\"!ok\"&gt;表白失败&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue(&#123; el:'#demo', data:&#123; ok:false, &#125;, methods:&#123; shift()&#123; this.ok = ! this.ok; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; &emsp;&emsp;先看一下下图, v-show 只是暂时的在页面中隐藏HTML元素, 而 v-if 是操作DOM. 如果频繁的切换, v-if要频繁的修改网页的DOM树. 2.列表渲染 两种渲染: v-for遍历数组、v-for遍历对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;h2&gt;v-for遍历数组&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"(p,index) in persons\" :key=\"index\"&gt; &#123;&#123;index&#125;&#125;---&#123;&#123;p.name&#125;&#125;---&#123;&#123;p.age&#125;&#125; ---&lt;button @click=\"deleteItem(index)\"&gt;删除&lt;/button&gt; ---&lt;button @click=\"updateItem(index,&#123;name:'Test',age:18&#125;)\"&gt;更新&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;v-for遍历对象&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"(value,key) in person\" :key=\"key\"&gt; &#123;&#123;value&#125;&#125;---&#123;&#123;key&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //在这里,vue本身只监视persons数组的改变,而没有监视数组内部数据的改变 //但是vue重写了一些改变数组内部数据的方法(先调用原来的方法,再进行数据绑定),进而实现数据数组内部数据变化时自动刷新页面 const vm = new Vue(&#123; el:\"#demo\", data:&#123; persons:[ &#123;name:'Ajax',age:20&#125;, &#123;name:'Bob',age:18&#125;, &#123;name:'Jane',age:22&#125;, &#123;name:'Stein',age:21&#125; ], person:&#123;name:'Bob',age:20,email:'3013142340@qq.com',phone:'18888888888'&#125; &#125;, methods:&#123; deleteItem(index)&#123; //删除数组中指定index的元素 this.persons.splice(index,1); &#125;, updateItem(index,newP)&#123; this.persons[index] = newP;//这行代码并没有改变persons本身,只是改变了数组内部的数据.数组内部的数据发生变化,但是没有vue的变异方法,所以不会更新页面 this.persons.splice(index,1,newP); //splice函数也可以向数组中插入新的元素.用法:splice(index,0,item) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; &emsp;&emsp;vue中变异的数组函数, splice: ①向数组中添加一个元素, array.splice(index,0,item) ②删除数组的一个元素, array.splice(index,1) ③替换数组中的一个元素, array.splice(index,1,item) &emsp;&emsp;为了实现当数组内部数据变化时, 自动刷新页面, vue重写了一些改变数组内部数据的变异方法(先调用原来的方法,再进行数据绑定). 3.列表的搜索与排序 列表搜索即对显示数据的条件过滤, 按照指定条件选取出符合的数据并显示. 利用数组的 filter 方法过滤数组元素. 用到了 vue 的计算属性, 当计算属性中的相关变量的值发生变化时, 该计算属性便会重新被计算. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;input type=\"text\" v-model=\"filterName\"/&gt; &lt;ul&gt; &lt;li v-for=\"(p,index) in filterPersons\" :key=\"index\"&gt; &#123;&#123;index&#125;&#125;---&#123;&#123;p.name&#125;&#125;---&#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"setOrderType(1)\"&gt;年龄升序&lt;/button&gt; &lt;button @click=\"setOrderType(2)\"&gt;年龄降序&lt;/button&gt; &lt;button @click=\"setOrderType(0)\"&gt;原本顺序&lt;/button&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el:'#demo', data:&#123; filterName:'', orderType:0,//0-&gt;原本顺序,1-&gt;升序,2-&gt;降序 persons:[ &#123;name:'Ajax',age:20&#125;, &#123;name:'Bob',age:18&#125;, &#123;name:'Jane',age:22&#125;, &#123;name:'Stein',age:21&#125; ] &#125;, methods:&#123; setOrderType(orderType)&#123; this.orderType = orderType &#125; &#125;, computed:&#123; filterPersons()&#123; const &#123;filterName,persons,orderType&#125; = this let newPersons newPersons = persons.filter(p=&gt;p.name.indexOf(filterName)!==-1) if(orderType!==0)&#123; newPersons.sort(function (p1,p2) &#123; if(orderType===1)&#123; return p1.age-p2.age &#125;else&#123; return p2.age-p1.age &#125; &#125;) &#125; return newPersons &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; &emsp;&emsp;const、let、var的区别. 首先, 要知道作用域, ES5 中作用域有: 全局作用域和函数作用域, 没有块作用域的概念. ES6 正式引入块级作用域{}. var: 会发生变量提升. 用var声明的变量, 在其声明之前就可以调用. 其值为: undefined. 属于函数级作用域. const: 用来定义常量, 声明时必须初始化(即必须赋值), 只能在块作用域里访问, 而且不能修改. let: 不会发生变量提升. 只能在块作用域里访问, 不能跨块访问, 更不能跨函数访问.","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"强制绑定class与style","slug":"Vue1-2","date":"2019-07-30T11:28:25.000Z","updated":"2019-10-06T09:44:20.000Z","comments":true,"path":"Vue1-2.html","link":"","permalink":"https://blog.crainyday.com/Vue1-2.html","excerpt":"Vue动态的改变class与style属性值","text":"Vue动态的改变class与style属性值 1.理解 一般在应用界面中, 某个(些)元素的样式是变化的, class/style绑定就是专门用来实现动态样式效果的技术 2.class绑定 html用法 :class=”variable” 其中variable是data中的变量, variable有三种类型: 字符串、对象、数组. 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Test&lt;/title&gt; &lt;style&gt; .classA &#123; color: red; &#125; .classB &#123; color: blue; &#125; .classC &#123; font-size: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"demo\"&gt; &lt;h2&gt;1. class绑定: :class='xxx'&lt;/h2&gt; &lt;p class=\"classC\" :class=\"myClass\"&gt;xxx是字符串&lt;/p&gt; &lt;p class=\"classC\" :class=\"&#123;classA:hasClassA,classB:hasClassB&#125;\"&gt;xxx是对象&lt;/p&gt; &lt;p :class=\"['classA','classC']\"&gt;xxx是对象&lt;/p&gt; &lt;button @click=\"update\"&gt;更新&lt;/button&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo', data: &#123; myClass:\"classA\", hasClassA:false, hasClassB:true, &#125;, methods: &#123; update()&#123; this.myClass = \"classB\"; this.hasClassA = !this.hasClassA; this.hasClassB = !this.hasClassB; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 3.style绑定 html用法 :style=”{ color: activeColor, fontSize: fontSize + ‘px’ }”其中activeColor/fontSize是data中的变量 123456789101112131415161718192021222324&lt;body&gt;&lt;div id=\"demo\"&gt; &lt;h2&gt;2. style绑定&lt;/h2&gt; &lt;p :style=\"&#123;color:activeColor, fontSize: fontSize + 'px'&#125;\"&gt;:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&lt;/p&gt; &lt;button @click=\"update\"&gt;更新&lt;/button&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo', data: &#123; activeColor:\"red\", fontSize:20, &#125;, methods: &#123; update()&#123; this.activeColor = \"yellowGreen\"; this.fontSize = 50-this.fontSize; &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue的计算属性与监视","slug":"Vue1-1","date":"2019-07-29T11:07:13.000Z","updated":"2019-10-06T09:44:12.000Z","comments":true,"path":"Vue1-1.html","link":"","permalink":"https://blog.crainyday.com/Vue1-1.html","excerpt":"计算属性—&gt;computed 监视—&gt;watch","text":"计算属性—&gt;computed 监视—&gt;watch 1.计算属性 在computed属性对象中定义计算属性的方法, 在页面中使用{{方法名}}来显示计算的结果. 在使用计算属性时, 都会用到缓存. 如果你不希望有缓存, 请用方法来替代. 123456789101112131415161718192021222324252627282930&lt;body&gt;&lt;div id=\"demo\"&gt; 姓: &lt;input type=\"text\" placeholder=\"First Name\" v-model=\"firstName\"&gt;&lt;br&gt; 名: &lt;input type=\"text\" placeholder=\"Last Name\" v-model=\"lastName\"&gt;&lt;br&gt; &lt;!--fullName1是根据fistName和lastName计算产生--&gt; 姓名1(单向): &lt;input type=\"text\" placeholder=\"Full Name1\" readonly=\"readonly\" v-model=\"fullName1\"&gt;&lt;br&gt; &lt;p&gt;&#123;&#123;fullName1&#125;&#125;&lt;/p&gt;&lt;!--注意:fullName1计算属性不一定每次都会调用--&gt; &lt;p&gt;&#123;&#123;fullName()&#125;&#125;&lt;/p&gt;&lt;!--注意:这里用方法也可以实现想要达到的效果,不同的是方法没有缓存--&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; const vm = new Vue(&#123; el:\"#demo\", data:&#123; firstName:\"A\", lastName:\"B\", &#125;, methods:&#123; fullName()&#123; return this.firstName + \" \" + this.lastName; &#125; &#125;, computed:&#123; fullName1(vmObj)&#123;//当前vm对象,即this return this.firstName + \" \" + vmObj.lastName; &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 2.监视属性 通过vm对象的$watch()或watch配置来监视指定的属性, 当属性变化时, 回调函数自动调用, 在函数内部进行计算 &emsp;&emsp;在计算一些页面中的数据时, 计算属性与监视相比更简单一些. 但监视常用来做深度监视. ①配置监视1234567891011121314151617181920212223242526&lt;body&gt;&lt;div id=\"demo\"&gt; 姓: &lt;input type=\"text\" placeholder=\"First Name\" v-model=\"firstName\"&gt;&lt;br&gt; 名: &lt;input type=\"text\" placeholder=\"Last Name\" v-model=\"lastName\"&gt;&lt;br&gt; &lt;!--fullName1是根据fistName和lastName计算产生--&gt; 姓名2(单向): &lt;input type=\"text\" placeholder=\"Full Name2\" readonly=\"readonly\" v-model=\"fullName2\"&gt;&lt;br&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; const vm = new Vue(&#123; el:\"#demo\", data:&#123; firstName:\"A\", lastName:\"B\", fullName2:\"A B\" &#125; watch:&#123; //监视firstName firstName:function (newVal,oldVal) &#123; this.fullName2 = newVal + \" \" + this.lastName; &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; ②$watch()监视123456789101112131415161718192021222324252627282930&lt;body&gt;&lt;div id=\"demo\"&gt; 姓: &lt;input type=\"text\" placeholder=\"First Name\" v-model=\"firstName\"&gt;&lt;br&gt; 名: &lt;input type=\"text\" placeholder=\"Last Name\" v-model=\"lastName\"&gt;&lt;br&gt; &lt;!--fullName1是根据fistName和lastName计算产生--&gt; 姓名2(单向): &lt;input type=\"text\" placeholder=\"Full Name2\" readonly=\"readonly\" v-model=\"fullName2\"&gt;&lt;br&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; const vm = new Vue(&#123; el:\"#demo\", data:&#123; firstName:\"A\", lastName:\"B\", fullName2:\"A B\" &#125;, watch:&#123; //监视firstName firstName:function (newVal,oldVal) &#123; this.fullName2 = newVal + \" \" + this.lastName; &#125; &#125; &#125;); vm.$watch(\"lastName\",function (newVal,oldVal) &#123; //监视lastName this.fullName2 = this.firstName + \" \" + newVal; &#125;);&lt;/script&gt;&lt;/body&gt; 3.计算属性高级 通过getter/setter实现对属性数据的显示和监视, 计算属性存在缓存, 多次读取只执行一次getter计算 12345678910111213141516171819202122232425262728293031323334&lt;body&gt;&lt;div id=\"demo\"&gt; 姓: &lt;input type=\"text\" placeholder=\"First Name\" v-model=\"firstName\"&gt;&lt;br&gt; 名: &lt;input type=\"text\" placeholder=\"Last Name\" v-model=\"lastName\"&gt;&lt;br&gt; &lt;!--fullName1是根据fistName和lastName计算产生--&gt; 姓名3(双向): &lt;input type=\"text\" placeholder=\"Full Name3\" v-model=\"fullName3\"&gt;&lt;br&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; const vm = new Vue(&#123; el:\"#demo\", data:&#123; firstName:\"A\", lastName:\"B\", &#125; computed:&#123; fullName3:&#123; //回调函数,计算当初始化或该属性的相关属性值改变时,计算当前的属性值 get()&#123; return this.firstName + \" \" + this.lastName; &#125;, //回调函数,监视当前的属性值,当其改变时,更新与它相关的属性值 set(value)&#123; const names = value.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125; &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 实现页面中双向的数据更新, 可以用计算属性的setter/getter实现, 也可以用监视来实现.","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"Vue初识","slug":"Vue1-0","date":"2019-07-28T11:07:13.000Z","updated":"2019-10-06T09:44:04.000Z","comments":true,"path":"Vue1-0.html","link":"","permalink":"https://blog.crainyday.com/Vue1-0.html","excerpt":"初步认识VUE","text":"初步认识VUE 1. Vue.js是什么? 1) 一位华裔前Google工程师(尤雨溪)开发的前端js库 2) 作用: 动态构建用户界面即前端界面 3) 特点: ①遵循MVVM模式, M指Model数据, V指View, VM指的是view Model对象 ②编码简洁, 体积小, 运行效率高, 移动/PC端开发 ③它本身只关注UI, 可以轻松引入vue插件和其它第三库开发项目 4) 与其它框架的关联: ①借鉴angular的模板和数据绑定技术 ②借鉴react的组件化和虚拟DOM技术 5) Vue包含一系列的扩展插件(库): ①vue-cli: vue脚手架 ②vue-resource(axios): ajax请求 ③vue-router: 路由 ④vuex: 状态管理 ⑤vue-lazyload: 图片懒加载 ⑥vue-scroller: 页面滑动相关 ⑦mint-ui: 基于vue的组件库(移动端) ⑧element-ui: 基于vue的组件库(PC端) 2. 基本使用 引入vue.js文件 创建Vue实例对象(vm), 指定选项(配置)对象 el : 指定Dom标签容器的选择器data : 指定初始化状态数据的对象/函数(返回一个对象) 在页面模板中使用}}或vue指令, 来显示数据 例子: 1234567891011121314151617181920212223242526272829303132&lt;body&gt;&lt;!-- 1. 引入Vue.js 2. 创建Vue对象 el : 指定根element(选择器) data : 初始化数据(页面可以访问) 3. 双向数据绑定 : v-model 4. 显示数据 : &#123;&#123;xxx&#125;&#125; 5. 理解vue的mvvm实现--&gt; &lt;!--实现输入框与p标签的显示数据同步更新--&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"username\" /&gt; &lt;p&gt;Hello &#123;&#123;username&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //创建vm实例 const vm = new Vue(&#123;//配置对象 el:'#app', data:&#123; username:'Vue!' &#125; &#125;) &lt;/script&gt;&lt;!--MVVM:model:模型,即数据对象(data)view:视图,模板页面viewModel:视图模型,即Vue的一个实例--&gt;&lt;/body&gt; 3.模板的常见语法 模板(视图)的理解:动态的html页面, 包含了一些JS语法代码、大括号表达式、指令(以v-开头的自定义标签属性). (1)双大括号表达式语法: {{exp}} 或 {{{exp}}}功能: 向页面输出数据, 可以调用对象的方法 (2)VUE指令： ①强制数据绑定功能: 指定变化的属性值完整写法: v-bind:xxx=’yyy’ //yyy会作为表达式解析执行简洁写法: :xxx=’yyy’ ②绑定事件监听功能: 绑定指定事件名的回调函数完整写法: v-on:click=’xxx’简洁写法: @click=’xxx’ 例子: 123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"demo\"&gt; &lt;h2&gt;1. 双大括号表达式&lt;/h2&gt; &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;content.toUpperCase()&#125;&#125;&lt;/p&gt; &lt;p v-text=\"tag\"&gt;&lt;/p&gt; &lt;p v-html=\"tag\"&gt;&lt;/p&gt; &lt;h2&gt;2. 指令一: 强制数据绑定&lt;/h2&gt; &lt;a href=\"url\"&gt;访问指定站点&lt;/a&gt;&lt;br&gt; &lt;a v-bind:href=\"url\"&gt;访问指定站点2&lt;/a&gt;&lt;br&gt; &lt;a :href=\"url\"&gt;访问指定站点3&lt;/a&gt;&lt;br&gt; &lt;h2&gt;3. 指令二: 绑定事件监听&lt;/h2&gt; &lt;button v-on:click=\"test1\"&gt;点我&lt;/button&gt; &lt;button @click=\"test2(content)\"&gt;点我&lt;/button&gt;&lt;!--带参的方法--&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el:\"#demo\", data:&#123; content:\"Hello Vue!!!\", tag:\"&lt;a href='https://www.baidu.com/'&gt;test&lt;/a&gt;\", url:\"https://www.baidu.com/\" &#125;, methods:&#123; test1(event)&#123;//默认事件参数 alert(event); alert(\"test1()\"); &#125;, test2(value)&#123; alert(\"test2(\"+value+\")\"); &#125; &#125; &#125;);&lt;/script&gt; 4. Vue对象的常用配置选项 ①el: 指定dom标签容器的选择器, Vue就会管理对应的标签及其子标签 ②data: 对象或函数类型指定初始化状态属性数据的对象, vm也会自动拥有data中所有属性, 页面中可以直接访问使用数据代理: 由vm对象来代理对data中所有属性的操作(读/写) ③methods: 包含多个方法的对象供页面中的事件指令来绑定回调, 回调函数默认有event参数, 但也可以指定自己的参数所有的方法由vue对象来调用, 访问data中的属性直接使用 this.xxx ④computed: 包含多个方法的对象对状态属性进行计算返回一个新的数据, 供页面获取显示一般情况下是相当于是一个只读的属性利用set/get方法来实现属性数据的计算读取, 同时监视属性数据的变化如何给对象定义get/set属性 在创建对象时指定: get name () {return xxx} / set name (value) {} 对象创建之后指定: Object.defineProperty(obj, age, {get(){}, set(value){}}) ⑤watch: 包含多个属性监视的对象分为一般监视和深度监视 xxx: function(value){} xxx : { deep : true, handler : fun(value) } 另一种添加监视方式: vm.$watch(‘xxx’, function(value){})","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/categories/Vue/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.crainyday.com/tags/Vue/"}]},{"title":"JDBC-DBUtils","slug":"JDBC1-10","date":"2019-05-14T15:15:11.000Z","updated":"2019-10-06T09:39:15.000Z","comments":true,"path":"JDBC1-10.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-10.html","excerpt":"DBUtils——Apache下的一个JDBC开源工具类库","text":"DBUtils——Apache下的一个JDBC开源工具类库 1.Apache—DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能. API介绍: &emsp;&emsp;–org.apache.commons.dbutils.QueryRunner &emsp;&emsp;–org.apache.commons.dbutils.ResultSetHandler &emsp;&emsp;–工具类: org.apache.commons.dbutils.DbUtils、… DbUtils类: 提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下: &emsp;&emsp;–public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet. &emsp;&emsp;–public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception. &emsp;&emsp;–public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常. &emsp;&emsp;–public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true. 使用该方法，你不需要捕捉这个异常ClassNotFoundException. 2.DBUtils的更新操作 通过QueryRunner类执行SQL语句, 并将结果集按指定要求返回. QueryRunner类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量. QueryRunner类提供了两个构造方法: &emsp;&emsp;–默认的构造方法 &emsp;&emsp;–需要一个 javax.sql.DataSource 来作参数的构造方法. QueryRunner类的主要方法: &emsp;&emsp;–public Object query(Connection conn, String sql, Object[] params, ResultSetHandler rsh) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭. &emsp;&emsp;–public Object query(String sql, Object[] params, ResultSetHandler rsh) throws SQLException: 几乎与第一种方法一样；唯一的不同在于它不将数据库连接提供给方法，并且它是从提供给构造方法的数据源(DataSource) 或使用的setDataSource 方法中重新获得 Connection. &emsp;&emsp;–public Object query(Connection conn, String sql, ResultSetHandler rsh) throws SQLException : 执行一个不需要置换参数的查询操作. &emsp;&emsp;–public int update(Connection conn, String sql, Object[] params) throws SQLException:用来执行一个更新（插入、更新或删除）操作. &emsp;&emsp;–public int update(Connection conn, String sql) throws SQLException：用来执行一个不需要置换参数的更新操作. 123456789101112131415161718@Testpublic void testDBUtils() &#123; //1. 创建执行SQL的 QueryRunner 对象 QueryRunner qr = new QueryRunner(); //2. 准备SQL语句,SQL可以是DELETE INSERT UPDATE操作 String sql = \"delete from Student where id in (?,?)\"; Connection conn = null; try &#123; //4. 准备数据库连接 conn = JDBCTools.getConnection(); //5. 传入相应参数,执行SQL qr.update(conn, sql, 1,2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(null, null, conn); &#125;&#125; 3.DBUtils的查询操作 通过DBUtils的QueryRunner类的query()方法实现数据库查询, 但是这里要给query方法的第三个参数传一个 ResultSetHandler 接口的实现类. 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式. ResultSetHandler 接口提供了一个单独的方法: Object handle (java.sql.ResultSet .rs), 处理结果集时就是调用的该方法, 且query()方法的返回值就是 ResultSetHandler 实现类的 handle() 方法的返回值. DBUtils提供的 ResultSetHandler 的实现类: BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中. BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里. MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值. MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List. ScalarHandler: 把结果集转换为一个值(该值可以是任意基本类型和String、Date 等)返回 ArrayHandler：把结果集中的第一行数据转成对象数组. ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中. ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key. A.BeanListHandler123456789101112131415@Testpublic void testBeanListHandler() &#123; QueryRunner qr = new QueryRunner(); String sql = \"SELECT id,name,email,birth date from Student where id in (?,?)\"; Connection conn = null; try &#123; conn = JDBCTools.getConnection(); List&lt;Student&gt; list = qr.query(conn, sql, new BeanListHandler&lt;Student&gt;(Student.class),3,4); System.out.println(list); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(null, null, conn); &#125;&#125; B.MapListHandler123456789101112131415@Testpublic void testMapListHandler() &#123; QueryRunner qr = new QueryRunner(); String sql = \"SELECT id,name,email,birth date from Student where id in (?,?)\"; Connection conn = null; try &#123; conn = JDBCTools.getConnection(); List&lt;Map&lt;String, Object&gt;&gt; map = qr.query(conn, sql, new MapListHandler(),3,4); System.out.println(map); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(null, null, conn); &#125;&#125; C.ScalarHandler12345678910111213141516@Testpublic void testScalarHandler() &#123; QueryRunner qr = new QueryRunner(); String sql = \"SELECT name,birth date from Student where id in (?,?)\"; Connection conn = null; try &#123; conn = JDBCTools.getConnection(); //注意: 这个查询结果只是一个值 Object obj = qr.query(conn, sql, new ScalarHandler&lt;&gt;(),3,4); System.out.println(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(null, null, conn); &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"JDBC-数据库连接池","slug":"JDBC1-9","date":"2019-05-13T12:40:42.000Z","updated":"2019-10-06T09:39:05.000Z","comments":true,"path":"JDBC1-9.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-9.html","excerpt":"JAVA——数据库连接池","text":"JAVA——数据库连接池 1.JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤: –在主程序（如servlet、beans）中建立数据库连接. –进行sql操作 –断开数据库连接 这种模式开发，存在的问题: –普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用.若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃. –对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库. –这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 2.数据库连接池 在真正的开发中, 我们几乎不用之前的方法获取数据库连接. 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术. 数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去. 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个. 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中. 数据库连接池的优点: -1. 资源重用 -2. 更快的系统反应速度 -3. 新的资源分配手段 -4. 统一的连接管理，避免数据库连接泄露 两种常用的开源数据库连接池: JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： –DBCP 数据库连接池 –C3P0 数据库连接池 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 注意: 使用数据库连接池后 ,在关闭数据库连接池返回的Connection对象时, 并不是真正的把数据库连接关闭, 而是将该连接还给数据库连接池. 3.DBCP数据源 DBCP数据源即DBCP数据库连接池 •DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool. 如需使用该连接池实现，应在系统中增加如下两个 jar 文件: –Commons-dbcp.jar：连接池的实现 –Commons-pool.jar：连接池实现的依赖库 •Tomcat 的连接池正是采用该连接池来实现的, 该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用. A.通过BasicDataSource1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.sql.Connection;import java.sql.SQLException;import org.apache.commons.dbcp2.BasicDataSource;import org.junit.Test;public class test &#123; @Test public void testDataSource() &#123; //1. 创建 DBCP 数据源实例 BasicDataSource dataSource = null; dataSource = new BasicDataSource(); //2. 为数据源实例指定必需的属性值 dataSource.setUsername(\"root\"); dataSource.setPassword(\"root\"); dataSource.setUrl(\"jdbc:sqlserver://localhost:1433;DatabaseName=SPJDB\"); dataSource.setDriverClassName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"); Connection conn = null; //3. 为数据源指定一些可选的属性值 //1) 指定数据库连接池中初始化连接数的个数 dataSource.setInitialSize(10); //2) 指定最小连接数: 在数据库连接池中保存的最少的空闲连接的数量 dataSource.setMinIdle(5); //3) 等待数据库连接池分配连接的最长时间(ms). 超时将出现异常 dataSource.setMaxWaitMillis(5000); try &#123; //4. 从数据源中获取数据库连接 conn = dataSource.getConnection(); System.out.println(conn.getClass()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(dataSource != null) &#123; try &#123; dataSource.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; B.通过DataSourceFactory123456789101112131415/*1. 加载 dbcp 的properties配置文件: 文件中的键需要来自 BasicDataSource 的属性 *2. 调用 BasicDataSourceFactory 的 createDataSource 方法创建 DataSource 实例 *3. 从 DataSource 实例中获取数据库连接 */@Testpublic void testDataSourceFactory() throws Exception &#123; //注意dbcp.properties在项目的src目录下 InputStream inStream = test.class.getClassLoader() .getResourceAsStream(\"dbcp.properties\"); Properties properties = new Properties(); properties.load(inStream); DataSource dataSource = null; dataSource = BasicDataSourceFactory.createDataSource(properties); System.out.println(dataSource.getConnection());&#125; 12345678#dbcp.properties:driverClassName=com.microsoft.sqlserver.jdbc.SQLServerDriverurl=jdbc:sqlserver://localhost:1433;DatabaseName=SPJDBusername=rootpassword=rootinitialSize=10minIdle=5maxWaitMillis=5000 4.C3P0数据源 需要的外部jar包: -1. c3p0-0.9.5.2.jar -2. mchange-commons-java-0.2.12.jar A.不使用配置文件123456789@Testpublic void testC3P0() throws Exception &#123; ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass( \"com.microsoft.sqlserver.jdbc.SQLServerDriver\" ); cpds.setJdbcUrl( \"jdbc:sqlserver://localhost:1433;DatabaseName=SPJDB\" ); cpds.setUser(\"root\"); cpds.setPassword(\"root\"); System.out.println(cpds.getConnection());&#125; B.使用配置文件 可以使用 properties 配置文件, 也可以使用 xml 配置文件, 建议使用 xml 文件 xml 文件名为: c3p0-config.xml, 该xml文件在项目的src目录下 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;c3p0-config&gt; &lt;named-config name=\"helloc3p0\"&gt; &lt;!-- 指定数据源的基本属性 --&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;root&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.microsoft.sqlserver.jdbc.SQLServerDriver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:sqlserver://localhost:1433;DatabaseName=SPJDB&lt;/property&gt; &lt;!-- 若数据库中连接数不足时,一次向数据库服务器申请多少个连接 --&gt; &lt;property name=\"acquireIncrement\"&gt;5&lt;/property&gt; &lt;!-- 初始化数据库连接池时连接的数量 --&gt; &lt;property name=\"initialPoolSize\"&gt;50&lt;/property&gt; &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt; &lt;property name=\"minPoolSize\"&gt;50&lt;/property&gt; &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt; &lt;property name=\"maxPoolSize\"&gt;1000&lt;/property&gt; &lt;!-- C3P0数据库连接池可以维护的Statement的个数 --&gt; &lt;property name=\"maxStatements\"&gt;20&lt;/property&gt; &lt;!-- 每个连接同时可以使用的Statement对象的个数 --&gt; &lt;property name=\"maxStatementsPerConnection\"&gt;5&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 12345@Testpublic void testC3P0() throws Exception &#123; DataSource ds = new ComboPooledDataSource(\"helloc3p0\"); System.out.println(ds.getConnection());&#125; 5.重构JDBCTools类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;/* * 操作 JDBC 的工具类,封装了一些常用的方法 */public class JDBCTools &#123; //数据库连接池 private static DataSource ds = null; static &#123; ds = new ComboPooledDataSource(\"helloc3p0\"); &#125; /** * 获取数据库连接: * 通过读取配置文件,根据配置信息从数据库服务器获取一个连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123; return ds.getConnection(); &#125; /** * 开始事务 * @param conn */ public static void beginTx(Connection conn) &#123; if(conn != null) &#123; try &#123; conn.setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 提交事务 * @param conn */ public static void commit(Connection conn) &#123; if(conn != null) &#123; try &#123; conn.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 回滚事务 * @param conn */ public static void rollback(Connection conn) &#123; if(conn != null) &#123; try &#123; conn.rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 关闭 ResultSet Statement 和 Connection 资源 * @param rs * @param state * @param conn */ public static void release(ResultSet rs,Statement state,Connection conn) &#123; if(rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(state != null) &#123; try &#123; state.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"JDBC-批处理","slug":"JDBC1-8","date":"2019-05-13T03:45:30.000Z","updated":"2019-10-06T09:38:57.000Z","comments":true,"path":"JDBC1-8.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-8.html","excerpt":"批处理 JDBC 语句提高处理速度","text":"批处理 JDBC 语句提高处理速度 批处理: 向数据库表中插入n多条SQL语句, 如何处理一下, 提高执行的性能. 先看一下几种方式的对比, 向表中插入10万条数据: 1.只使用Statement123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//JDBCTools.class:import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/* * 操作 JDBC 的工具类,封装了一些常用的方法 */public class JDBCTools &#123; /** * 获取数据库连接: * 通过读取配置文件,根据配置信息从数据库服务器获取一个连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123; InputStream is = JDBCTools.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties pro = new Properties(); pro.load(is); String url = pro.getProperty(\"jdbc\"); String user = pro.getProperty(\"user\"); String password = pro.getProperty(\"password\"); Class.forName(pro.getProperty(\"driver\")); Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125; /** * 开始事务 * @param conn */ public static void beginTx(Connection conn) &#123; if(conn != null) &#123; try &#123; conn.setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 提交事务 * @param conn */ public static void commit(Connection conn) &#123; if(conn != null) &#123; try &#123; conn.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 回滚事务 * @param conn */ public static void rollback(Connection conn) &#123; if(conn != null) &#123; try &#123; conn.rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 关闭 ResultSet Statement 和 Connection 资源 * @param rs * @param state * @param conn */ public static void release(ResultSet rs,Statement state,Connection conn) &#123; if(rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(state != null) &#123; try &#123; state.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172//DAO.class:import java.lang.reflect.InvocationTargetException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.beanutils.BeanUtils;public class DAO &#123; /** * 通用的更新方法,包括: Insert Delete Update * @param sql * @param args */ public void update(String sql, Object ... args) &#123; Connection conn = null; PreparedStatement psmt = null; try &#123; //1. 获取数据库连接 conn = JDBCTools.getConnection(); psmt = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; psmt.setObject(i+1, args[i]); &#125; //2. 执行 SQL语句 psmt.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(null, psmt, conn); &#125; &#125; /** * 通用的查询方法,SQL为select类型. * 查询结果最多是一行记录. * @param clazz * @param sql * @param args * @return */ public &lt;T&gt; T get(Class&lt;T&gt; clazz, String sql, Object ... args) &#123; List&lt;T&gt; list = getForList(clazz, sql, args); if(list.size()&gt;0) &#123; return list.get(0); &#125; return null; &#125; /** * 通用的查询方法,SQL为select类型. * 查询结果可以为多行记录(0~n). * @param clazz * @param sql * @param args * @return */ public &lt;T&gt; List&lt;T&gt; getForList(Class&lt;T&gt; clazz, String sql, Object ... args)&#123; List&lt;T&gt; list = new ArrayList&lt;&gt;(); Connection conn = null; PreparedStatement psmt = null; ResultSet rs = null; try &#123; conn = JDBCTools.getConnection(); psmt = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; psmt.setObject(i+1, args[i]); &#125; //1. 获取连接再获取结果集 rs = psmt.executeQuery(); //2. 将结果集转换为Map的List List&lt;Map&lt;String, Object&gt;&gt; values = handleResultSetToMapList(rs); //3. 将 Map 的List 转换为 JavaBean 对应的List list = transferMapListToBeanList(clazz, values); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return list; &#125; /** * 查询方法,结果为一行中的一列 * @param sql * @param args * @return */ @SuppressWarnings(\"unchecked\") public &lt;E&gt; E getForValue(String sql, Object ... args) &#123; Connection conn = null; PreparedStatement psmt = null; ResultSet rs = null; try &#123; conn = JDBCTools.getConnection(); psmt = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; psmt.setObject(i+1, args[i]); &#125; rs = psmt.executeQuery(); if(rs.next()) &#123; return (E)rs.getObject(1); &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125;finally &#123; JDBCTools.release(rs, psmt, conn); &#125; return null; &#125; /** * 获取结果集的 ColumnLabel 对应的 List * @param rs * @return * @throws Exception */ private List&lt;String&gt; getColumnLabels(ResultSet rs) throws SQLException&#123; List&lt;String&gt; labels = new ArrayList&lt;&gt;(); ResultSetMetaData rsmd = rs.getMetaData(); for(int i = 0;i &lt; rsmd.getColumnCount();i++) &#123; labels.add(rsmd.getColumnLabel(i+1)); &#125; return labels; &#125; /** * 处理结果集得到一个 Map 的List, 其中一个 Map 代表一个记录. * @param rs * @return * @throws Exception */ private List&lt;Map&lt;String, Object&gt;&gt; handleResultSetToMapList(ResultSet rs) throws SQLException&#123; List&lt;String&gt; labels = this.getColumnLabels(rs); List&lt;Map&lt;String,Object&gt;&gt; values = new ArrayList&lt;&gt;(); Map&lt;String,Object&gt; map = null; while(rs.next())&#123; map = new HashMap&lt;&gt;(); for(String key :labels) &#123; Object value = rs.getObject(key); map.put(key, value); &#125; values.add(map); &#125; return values; &#125; /** * 将 Map 的 List 转换为 JavaBean对象的 List * @param clazz * @param values * @return * @throws InstantiationException * @throws IllegalAccessException * @throws InvocationTargetException */ private &lt;T&gt; List&lt;T&gt; transferMapListToBeanList(Class&lt;T&gt; clazz, List&lt;Map&lt;String, Object&gt;&gt; values) throws InstantiationException, IllegalAccessException, InvocationTargetException &#123; List&lt;T&gt; list = new ArrayList&lt;&gt;(); T bean = null; if(values.size()&gt;0) &#123; for(Map&lt;String,Object&gt; m:values) &#123; bean = clazz.newInstance(); for(Map.Entry&lt;String, Object&gt; entry:m.entrySet()) &#123; String propertyName = entry.getKey(); Object propertyValue = entry.getValue(); BeanUtils.setProperty(bean, propertyName, propertyValue); &#125; list.add(bean); &#125; &#125; return list; &#125;&#125; 12345678910111213141516171819202122232425@Testpublic void testBatchWithStatement() &#123; Connection conn = null; Statement state = null; String sql = null; try &#123; conn = JDBCTools.getConnection(); JDBCTools.beginTx(conn); state = conn.createStatement(); long begin = System.currentTimeMillis(); for(int i = 0;i &lt; 100000;i ++) &#123; sql = \"INSERT INTO Student VALUES(\"+(i+1) +\",'\"+\"name_\"+i+\"','alian@qq.com','1999-09-09')\"; state.executeUpdate(sql); &#125; long end = System.currentTimeMillis(); System.out.println(\"Time:\"+(end-begin));//Time:30442 左右 JDBCTools.commit(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); JDBCTools.rollback(conn); &#125;finally &#123; JDBCTools.release(null, state, conn); &#125;&#125; 2.只使用PreparedStatement1234567891011121314151617181920212223242526272829@Testpublic void testBatchWithPreparedStatement() &#123; Connection conn = null; PreparedStatement psmt = null; String sql = null; try &#123; conn = JDBCTools.getConnection(); JDBCTools.beginTx(conn); sql = \"INSERT INTO Student VALUES(?,?,?,?)\"; Date date = new Date(new java.util.Date().getTime()); psmt = conn.prepareStatement(sql); long begin = System.currentTimeMillis(); for(int i = 0;i &lt; 100000;i ++) &#123; psmt.setInt(1, i+1); psmt.setString(2, \"name_\"+i); psmt.setString(3, \"name_\"+i+\"@qq.cp.com\"); psmt.setDate(4, date); psmt.executeUpdate(); &#125; long end = System.currentTimeMillis(); System.out.println(\"Time:\"+(end-begin));//Time:19754 JDBCTools.commit(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); JDBCTools.rollback(conn); &#125;finally &#123; JDBCTools.release(null, psmt, conn); &#125;&#125; 3.使用Batch123456789101112131415161718192021222324252627282930313233343536373839@Testpublic void testBatch() &#123; Connection conn = null; PreparedStatement psmt = null; String sql = null; try &#123; conn = JDBCTools.getConnection(); JDBCTools.beginTx(conn); sql = \"INSERT INTO Student VALUES(?,?,?,?)\"; Date date = new Date(new java.util.Date().getTime()); psmt = conn.prepareStatement(sql); long begin = System.currentTimeMillis(); for(int i = 0;i &lt; 100000;i ++) &#123; psmt.setInt(1, i+1); psmt.setString(2, \"name_\"+i); psmt.setString(3, \"name_\"+i+\"@qq.cp.com\"); psmt.setDate(4, date); // \"积攒\" SQL psmt.addBatch(); //当\"积攒\"到一定程度时,统一向数据库发送一次SQL 并清空\"积攒\" if((i+1)%300==0) &#123; psmt.executeBatch(); psmt.clearBatch(); &#125; &#125; if(100000%300 != 0) &#123; psmt.executeBatch(); psmt.clearBatch(); &#125; long end = System.currentTimeMillis(); System.out.println(\"Time:\"+(end-begin));//Time:2546 JDBCTools.commit(conn); &#125; catch (Exception e) &#123; e.printStackTrace(); JDBCTools.rollback(conn); &#125;finally &#123; JDBCTools.release(null, psmt, conn); &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"JDBC-数据库事务","slug":"JDBC1-7","date":"2019-05-12T15:20:12.000Z","updated":"2019-10-06T09:38:50.000Z","comments":true,"path":"JDBC1-7.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-7.html","excerpt":"数据库事务","text":"数据库事务 1.事务的简介 在数据库中,所谓事务是指一组逻辑操作单元,使数据从一种状态变换到另一种状态. 为确保数据库中数据的一致性,数据的操纵应当是离散的成组的逻辑单元:当它全部完成时,数据的一致性可以保持,而当这个单元中的一部分操作失败,整个事务应全部视为错误,所有从起始点以后的操作应全部回退到开始状态. 事务的操作:先定义开始一个事务,然后对数据作修改操作,这时如果提交(COMMIT),这些修改就永久地保存下来,如果回退(ROLLBACK),数据库管理系统将放弃所作的所有修改而回到开始事务时的状态. 2.事务的属性 事务的ACID(acid)属性: –1. 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生. –2. 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态. –3. 隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰. –4. 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响. 3.JDBC事务处理 事务：指构成单个逻辑工作单元的操作集合 事务处理：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，要么整个事务回滚(rollback)到最初状态 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚 为了让多个 SQL 语句作为一个事务执行: –调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 –在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 –在出现异常时，调用 rollback(); 方法回滚事务 –若此时 Connection 没有被关闭, 则需要恢复其自动提交状态 123456789101112/** 账户1给账户2转账1000元. * 若两个执行的SQL之间有异常,则有的SQL不能执行,而出现数据不同步. */@Testpublic void testJDBC() &#123; DAO dao = new DAO(); String sql = \"UPDATE Account SET balance = balance-? WHERE id = ?\"; dao.update(sql,1000,1); //int i = 10/0;//若打开这行代码的注释,则不能给账户2添加1000元. sql = \"UPDATE Account SET balance = balance+? WHERE id = ?\"; dao.update(sql,1000,2);&#125; 关于事务: –1. 如果是执行了多个SQL操作, 每个SQL操作都有自己单独的连接, 则无法保证事务. –2. 具体步骤: 1) 事务操作开始前, 要开启事务(即关闭默认commit): conn.setAutoCommit(false); 2) 如果事务的操作都成功, 则提交事务: conn.commit(); 3) 若出现异常, 则在catch块中回滚事务: conn.rollback(); 1234567891011121314151617181920212223242526272829303132333435363738//1. 修改之前的DAO的update()方法,使其能够支持事务.import java.lang.reflect.InvocationTargetException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.beanutils.BeanUtils;public class DAO &#123; /** * 通用的更新方法,包括: Insert Delete Update * @param conn * @param sql * @param args */ public void update(Connection conn,String sql, Object ... args) &#123; PreparedStatement psmt = null; try &#123; psmt = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; psmt.setObject(i+1, args[i]); &#125; //2. 执行 SQL语句 psmt.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //在这里不能关闭数据库连接,之后可能会用到 JDBCTools.release(null, psmt, null); &#125; &#125;&#125; 123456789101112131415161718192021222324252627@Testpublic void testJDBC() &#123; Connection conn = null; try &#123; conn = JDBCTools.getConnection(); //1. 开启事务 conn.setAutoCommit(false); String sql = \"UPDATE Account SET balance = balance-? WHERE id = ?\"; update(conn,sql,1000,1); int i = 10/0; sql = \"UPDATE Account SET balance = balance+? WHERE id = ?\"; update(conn,sql,1000,2); //2. 提交事务 conn.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //3. 回滚事务 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;finally &#123; //关闭数据库连接 JDBCTools.release(null, null, conn); &#125;&#125; 4.数据库的隔离级别 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: –脏读: 对于两个事物 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的. –不可重复读: 对于两个事物 T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了. –幻读: 对于两个事物 T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行. 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题. 一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱 数据库提供的4种隔离级别: Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE. Oracle 默认的事务隔离级别为: READ COMMITED Mysql 支持 4 中事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ 修改数据库的隔离级别: JDBC程序中修改: 调用 Connection 的 setTransactionIsolation(); 方法 在MySQL中设置隔离级别: &emsp;&emsp;设置当前 MySQL 连接的隔离级别: &emsp;&emsp;–set transaction isolation level read committed; &emsp;&emsp;设置数据库系统的全局的隔离级别: &emsp;&emsp;– set global transaction isolation level read committed; 查看当前的隔离级别: SELECT @@tx_isolation;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"JDBC-获取主键值","slug":"JDBC1-6","date":"2019-05-12T13:40:40.000Z","updated":"2019-10-06T09:38:42.000Z","comments":true,"path":"JDBC1-6.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-6.html","excerpt":"获取数据库自动生成的主键的值","text":"获取数据库自动生成的主键的值 1.getGeneratedKeys() 这里我只测试过可以获取 MySQL和SQL Server数据库的自增主键值 设置主键: mysql: create table student(id int auto_increment primary key not null, name varchar(15)); sqlserver: create table student(id int identity(1,1) primary key not null, name varchar(15)); oracle: 要通过触发器来设置主键自增. 123456789101112131415161718192021222324252627282930313233343536373839404142import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.Date;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.Statement;import org.junit.Test;public class test &#123; @Test public void testGetKeyValue() &#123; Connection conn = null; PreparedStatement ps = null; String sql = \"INSERT INTO Student VALUES(?,?,?)\"; ResultSet rs = null; try &#123; conn = JDBCTools.getConnection(); ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); ps.setString(1, \"Jhon\"); ps.setString(2, \"jhon@qq.com\"); ps.setDate(3, new Date(new java.util.Date().getTime())); ps.executeUpdate(); //通过 getGeneratedKeys() 方法获取新生成的主键的 ResultSet 对象 //在 ResultSet 中只有一列 GENERATED_KEYS ,用于存放新生成的主键值 rs = ps.getGeneratedKeys(); if(rs.next()) &#123; System.out.println(rs.getObject(1)); &#125; ResultSetMetaData rsmd = rs.getMetaData(); for(int i = 0;i &lt; rsmd.getColumnCount();i ++) &#123; System.out.println(rsmd.getColumnName(i+1)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(rs, ps, conn); &#125; &#125;&#125; 2.元数据获取数据库相关信息12345678910111213141516171819202122232425262728293031323334353637import java.sql.Connection;import java.sql.DatabaseMetaData;import java.sql.Date;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.Statement;import org.junit.Test;public class test &#123; @Test public void testJDBC() &#123; Connection conn = null; DatabaseMetaData db = null; ResultSet rs = null; try &#123; conn = JDBCTools.getConnection(); //获取数据库元数据 db = conn.getMetaData(); //获取数据库版本号 System.out.println(db.getDatabaseProductVersion()); //获取当前连接的用户名 System.out.println(db.getUserName()); //获取当前数据库连接中的所有数据库名 rs = db.getCatalogs(); while(rs.next()) &#123; System.out.println(rs.getString(1)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(rs, null, conn); &#125; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"JDBC-DAO设计模式","slug":"JDBC1-5","date":"2019-05-11T15:23:08.000Z","updated":"2019-10-06T09:38:34.000Z","comments":true,"path":"JDBC1-5.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-5.html","excerpt":"JDBC中的DAO设计模式——Data Access Object(数据访问对象)","text":"JDBC中的DAO设计模式——Data Access Object(数据访问对象) 1.DAO简介 什么是DAO? DAO即Data Access Object, 是用来访问数据信息的类. 包含了对数据的 CRUD(即create,read,update,delete) 操作. 而不包含任何业务相关的信息. DAO其实就是对一些常用的 JDBC 方法的封装(就像之前写的JDBC工具类, 也有不同的地方). DAO的意义? 为了实现代码功能的模块化, 更有利于代码的维护与升级. DAO要实现哪些数据相关操作的方法? 若是要处理一些事务的操作, 下列方法还应该在最前面添加一个数据库连接Connection参数 void update(String sql, Object … args);执行对数据库的 Insert Update Delete 操作 \\&lt;T> T get(Class\\&lt;T> clazz, String sql, Object … args);查询一条记录, 返回对应的JavaBean对象 \\&lt;T> List\\&lt;T> getForList(Class\\&lt;T> clazz, String sql, Object … args);查询多条记录, 返回对应对象的集合 \\&lt;E> E getForValue(String sql, Object … args);返回某一条记录的某一个字段的值 或 一个统计的值(即聚集函数的结果) 2.beanutils工具类 beanutils工具类是Apache的产品之一, 是一个用来操作JavaBean对象的开源jar. 回想之前, 我们是用的 Java 原始的反射机制来操作的JavaBean对象. JavaBean: 是一个特殊的 Java 类, 类必须是具体的和公共的, 并且具有无参数的构造器, 通过提供的公共方法(即setter和getter方法)来操作成员变量. Java 类的属性: ① 在 JavaEE 开发中, Java类的属性通过类的 getter(或setter) 方法来定义, 即去除方法 get(或set), 将之后字母的首字母小写, 即为 Java 类的属性.例: public String getIdCard(); 所代表的属性是 idCard. ② 而之前我们常说的属性(即类的成员变量), 这里称之为字段. ③ 注意, 我们写的时候, 字段一般都与属性一一对应; 当然, 也会有不对应的情况. 和之前用 JDBC 驱动时一样, 要将 commons-beanutils-1.9.3.jar和commons-logging-1.2.jar 两个 jar包添加到当前项目的 “构建路径”. 步骤: ①没有 lib 目录的在当前项目下新建目录 lib,将要添加的 jar 包放在里面. ②在想要添加的 jar 上右键单击, 之后单击 “构建路径”(即 “Build Path”) ③之后再单击 “添加至构建路径” 即 “Add to Build Path” 经常用到的两个方法: setProperty() 为JavaBean对象指定属性赋值. getProperty() 获取 JavaBean 对象的指定属性 1234567891011121314public class TestBeanUtils &#123; @Test public void testBeanUtils() throws Exception&#123; //Student类还是之前写的类 Object obj = new Student(); System.out.println(obj); BeanUtils.setProperty(obj, \"name\", \"Bob\"); System.out.println(obj); /*输出: Student [id=0, name=null, email=null, date=null] Student [id=0, name=Bob, email=null, date=null] */ &#125;&#125; 3.DAO 要学会使用编辑器, 可快速重构代码. 学会将代码模块化, 可将功能性的代码片段抽取成一个方法, 方便维护和管理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172import java.lang.reflect.InvocationTargetException;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.beanutils.BeanUtils;public class DAO &#123; /** * 通用的更新方法,包括: Insert Delete Update * @param sql * @param args */ public void update(String sql, Object ... args) &#123; Connection conn = null; PreparedStatement psmt = null; try &#123; //1. 获取数据库连接 conn = JDBCTools.getConnection(); psmt = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; psmt.setObject(i+1, args[i]); &#125; //2. 执行 SQL语句 psmt.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(null, psmt, conn); &#125; &#125; /** * 通用的查询方法,SQL为select类型. * 查询结果最多是一行记录. * @param clazz * @param sql * @param args * @return */ public &lt;T&gt; T get(Class&lt;T&gt; clazz, String sql, Object ... args) &#123; List&lt;T&gt; list = getForList(clazz, sql, args); if(list.size()&gt;0) &#123; return list.get(0); &#125; return null; &#125; /** * 通用的查询方法,SQL为select类型. * 查询结果可以为多行记录(0~n). * @param clazz * @param sql * @param args * @return */ public &lt;T&gt; List&lt;T&gt; getForList(Class&lt;T&gt; clazz, String sql, Object ... args)&#123; List&lt;T&gt; list = new ArrayList&lt;&gt;(); Connection conn = null; PreparedStatement psmt = null; ResultSet rs = null; try &#123; conn = JDBCTools.getConnection(); psmt = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; psmt.setObject(i+1, args[i]); &#125; //1. 获取连接再获取结果集 rs = psmt.executeQuery(); //2. 将结果集转换为Map的List List&lt;Map&lt;String, Object&gt;&gt; values = handleResultSetToMapList(rs); //3. 将 Map 的List 转换为 JavaBean 对应的List list = transferMapListToBeanList(clazz, values); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return list; &#125; /** * 查询方法,结果为一行中的一列 * @param sql * @param args * @return */ @SuppressWarnings(\"unchecked\") public &lt;E&gt; E getForValue(String sql, Object ... args) &#123; Connection conn = null; PreparedStatement psmt = null; ResultSet rs = null; try &#123; conn = JDBCTools.getConnection(); psmt = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; psmt.setObject(i+1, args[i]); &#125; rs = psmt.executeQuery(); if(rs.next()) &#123; return (E)rs.getObject(1); &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125;finally &#123; JDBCTools.release(rs, psmt, conn); &#125; return null; &#125; /** * 获取结果集的 ColumnLabel 对应的 List * @param rs * @return * @throws Exception */ private List&lt;String&gt; getColumnLabels(ResultSet rs) throws SQLException&#123; List&lt;String&gt; labels = new ArrayList&lt;&gt;(); ResultSetMetaData rsmd = rs.getMetaData(); for(int i = 0;i &lt; rsmd.getColumnCount();i++) &#123; labels.add(rsmd.getColumnLabel(i+1)); &#125; return labels; &#125; /** * 处理结果集得到一个 Map 的List, 其中一个 Map 代表一个记录. * @param rs * @return * @throws Exception */ private List&lt;Map&lt;String, Object&gt;&gt; handleResultSetToMapList(ResultSet rs) throws SQLException&#123; List&lt;String&gt; labels = this.getColumnLabels(rs); List&lt;Map&lt;String,Object&gt;&gt; values = new ArrayList&lt;&gt;(); Map&lt;String,Object&gt; map = null; while(rs.next())&#123; map = new HashMap&lt;&gt;(); for(String key :labels) &#123; Object value = rs.getObject(key); map.put(key, value); &#125; values.add(map); &#125; return values; &#125; /** * 将 Map 的 List 转换为 JavaBean对象的 List * @param clazz * @param values * @return * @throws InstantiationException * @throws IllegalAccessException * @throws InvocationTargetException */ private &lt;T&gt; List&lt;T&gt; transferMapListToBeanList(Class&lt;T&gt; clazz, List&lt;Map&lt;String, Object&gt;&gt; values) throws InstantiationException, IllegalAccessException, InvocationTargetException &#123; List&lt;T&gt; list = new ArrayList&lt;&gt;(); T bean = null; if(values.size()&gt;0) &#123; for(Map&lt;String,Object&gt; m:values) &#123; bean = clazz.newInstance(); for(Map.Entry&lt;String, Object&gt; entry:m.entrySet()) &#123; String propertyName = entry.getKey(); Object propertyValue = entry.getValue(); BeanUtils.setProperty(bean, propertyName, propertyValue); &#125; list.add(bean); &#125; &#125; return list; &#125;&#125; 4.TestDAO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.sql.Date;import java.util.List;import java.util.Scanner;import org.junit.Test;public class DAOTest &#123; DAO dao = new DAO(); @Test public void testUpdate() &#123; Student stu = getStudentFromConsole(); addStudent(stu); &#125; private Student getStudentFromConsole() &#123; Student stu = new Student(); Scanner scanner = new Scanner(System.in); System.out.print(\"请输入学生ID:\"); stu.setId(scanner.nextInt()); System.out.print(\"请输入学生Name:\"); stu.setName(scanner.next()); System.out.print(\"请输入学生Email:\"); stu.setEmail(scanner.next()); System.out.print(\"请输入学生Birth:\"); stu.setDate(Date.valueOf(scanner.next())); scanner.close(); return stu; &#125; public void addStudent(Student stu) &#123; String sql = \"INSERT INTO Student VALUES(?,?,?,?)\"; dao.update(sql,stu.getId(),stu.getName(),stu.getEmail(),stu.getDate()); &#125; @Test public void testGet() &#123; String sql = \"SELECT id, name, email, birth date FROM Student \" + \"WHERE id = ?\"; Student stu = dao.get(Student.class, sql,3); System.out.println(stu); &#125; @Test public void testGetForList() &#123; String sql = \"SELECT id, name, email, birth date FROM Student\"; List&lt;Student&gt; list = dao.getForList(Student.class, sql); for(Student stu:list) &#123; System.out.println(stu); &#125; &#125; @Test public void testGetForValue() &#123; String sql = \"SELECT COUNT(*) FROM Student\"; int result = dao.getForValue(sql); System.out.println(result); &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"JDBC-一个通用的JDBC查询方法","slug":"JDBC1-4","date":"2019-05-08T00:41:50.000Z","updated":"2019-10-06T09:38:26.000Z","comments":true,"path":"JDBC1-4.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-4.html","excerpt":"利用反射及 JDBC 元数据编写通用的查询方法.","text":"利用反射及 JDBC 元数据编写通用的查询方法. 1.观察之前的查询方法 方法返回值不一定,要根据具体的运行时类确定 创建的对象不一定,要根据具体的运行时类确定 具体对象的属性与结果集的字段之间没有什么关系:如何获取结果集中的字段?并给字段对应的对象的属性赋值? 1234567891011121314151617181920212223242526272829private Student getStudent(String sql,Object ... args) &#123; //1.方法返回值不一定,要根据具体的运行时类确定 Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; Student stu = null;//2.创建的对象不一定,要根据具体的运行时类确定 try &#123; conn = JDBCTools.getConnection(); ps = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; ps.setObject(i+1, args[i]); &#125; rs = ps.executeQuery(); if(rs.next()) &#123; stu = new Student( rs.getInt(1), rs.getString(2).trim(), rs.getString(3).trim(), rs.getDate(4)); //3.具体对象的属性与结果集的字段之间没有什么关系, //如何获取结果集中的字段?并给字段对应对象的属性复制? &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCTools.release(rs, ps, conn); &#125; return stu;&#125; 2.利用反射创建对象 之前我们知道 Java 的反射是动态语言的关键. 忘记如何用反射的可以看一下 , Java反射 1234567891011121314151617181920212223242526public static &lt;T&gt; T get(Class&lt;T&gt; clazz,String sql,Object ... args) &#123; //1.由于不能确定返回值,利用泛型实现,通过传过来的clazz参数确定返回值 Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; T entity = null; try &#123; conn = JDBCTools.getConnection(); ps = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; ps.setObject(i+1, args[i]); &#125; rs = ps.executeQuery(); if(rs.next()) &#123; //2.利用反射创建对象 entity = clazz.newInstance(); //3.通过解析SQL语句来判断到底选择查询了哪些列, //以及需要为 entity 对象的哪些属性赋值 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCTools.release(rs, ps, conn); &#125; return entity;&#125; 3.对应列与属性 注意到: SQL查询的数据表的列与对象的属性没有什么关系. 我们要修改一下查询时的SQL语句, 查询时为每一列起一个别名, 该别名与对象的属性一一对应. 4.获取列名(别名)A.数据库元数据 Java 通过JDBC获得连接以后，得到一个Connection 对象，可以从这个对象获得有关数据库管理系统的各种信息，包括数据库中的各个表，表中的各个列，数据类型，触发器，存储过程等各方面的信息。根据这些信息，JDBC可以访问一个实现事先并不了解的数据库。 获取这些信息的方法都是在DatabaseMetaData类的对象上实现的，而DatabaseMetaData对象是在Connection对象上获得的. 可通过Connection 对象的 getMetaData()方法获取 DatabaseMetaData 对象 DatabaseMetaData 类中提供了许多方法用于获得数据源的各种信息，通过这些方法可以非常详细的了解数据库的信息:&emsp;&emsp;–getURL(): 返回一个String类对象，代表数据库的URL。&emsp;&emsp;–getUserName(): 返回连接当前数据库管理系统的用户名。&emsp;&emsp;–isReadOnly(): 返回一个boolean值，指示数据库是否只允许读操作。&emsp;&emsp;–getDatabaseProductName(): 返回数据库的产品名称。&emsp;&emsp;–getDatabaseProductVersion(): 返回数据库的版本号。&emsp;&emsp;–getDriverName(): 返回驱动驱动程序的名称。&emsp;&emsp;–getDriverVersion(): 返回驱动程序的版本号。&emsp;&emsp;–getCatalogs(): 返回数据库连接对应的数据库的结果集。 B.结果集元数据 ResultSetMetaData类 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象: –getColumnName(int column)：获取指定列的名称 –getColumnCount()：返回当前 ResultSet 对象中的列数。 –getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 –getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 –isNullable(int column)：指示指定列中的值是否可以为 null。 – isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 可通过 ResultSet 对象的 getMetaData()方法获取 ResultSetMetaData 对象 12345//rs为ResultSet对象ResultSetMetaData rsmd = rs.getMetaData();for (int i = 0; i &lt; rsmd.getColumnCount(); i++) &#123; System.out.println(rsmd.getColumnName(i+1));//打印出列名&#125; 5.利用反射创建对象并赋值A.反射工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;/** * 反射的 Utils 函数集合 * 提供访问私有变量, 获取泛型类型 Class, 提取集合中元素属性等 Utils 函数 * @author Administrator */public class ReflectionUtils &#123; /** * 通过反射, 获得定义 Class 时声明的父类的泛型参数的类型 * 如: public EmployeeDao extends BaseDao&lt;Employee, String&gt; * @param clazz * @param index * @return */ @SuppressWarnings(\"unchecked\") public static Class&lt;Object&gt; getSuperClassGenricType(Class&lt;Object&gt; clazz, int index)&#123; Type genType = clazz.getGenericSuperclass(); if(!(genType instanceof ParameterizedType))&#123; return Object.class; &#125; Type [] params = ((ParameterizedType)genType).getActualTypeArguments(); if(index &gt;= params.length || index &lt; 0)&#123; return Object.class; &#125; if(!(params[index] instanceof Class))&#123; return Object.class; &#125; return (Class&lt;Object&gt;) params[index]; &#125; /** * 通过反射, 获得 Class 定义中声明的父类的泛型参数类型 * 如: public EmployeeDao extends BaseDao&lt;Employee, String&gt; * @param &lt;T&gt; * @param clazz * @return */ public static Class&lt;Object&gt; getSuperGenericType(Class&lt;Object&gt; clazz)&#123; return getSuperClassGenricType(clazz, 0); &#125; /** * 循环向上转型, 获取对象的 DeclaredMethod * @param object * @param methodName * @param parameterTypes * @return */ public static Method getDeclaredMethod(Object object, String methodName, Class&lt;?&gt;[] parameterTypes)&#123; for(Class&lt;?&gt; superClass = object.getClass(); superClass != Object.class; superClass = superClass.getSuperclass())&#123; try &#123; //superClass.getMethod(methodName, parameterTypes); return superClass.getDeclaredMethod(methodName, parameterTypes); &#125; catch (NoSuchMethodException e) &#123; //Method 不在当前类定义, 继续向上转型 &#125; //.. &#125; return null; &#125; /** * 使 filed 变为可访问 * @param field */ public static void makeAccessible(Field field)&#123; if(!Modifier.isPublic(field.getModifiers()))&#123; field.setAccessible(true); &#125; &#125; /** * 循环向上转型, 获取对象的 DeclaredField * @param object * @param filedName * @return */ public static Field getDeclaredField(Object object, String filedName)&#123; for(Class&lt;?&gt; superClass = object.getClass(); superClass != Object.class; superClass = superClass.getSuperclass())&#123; try &#123; return superClass.getDeclaredField(filedName); &#125; catch (NoSuchFieldException e) &#123; //Field 不在当前类定义, 继续向上转型 &#125; &#125; return null; &#125; /** * 直接调用对象方法, 而忽略修饰符(private, protected) * @param object * @param methodName * @param parameterTypes * @param parameters * @return * @throws InvocationTargetException * @throws IllegalArgumentException */ public static Object invokeMethod(Object object, String methodName, Class&lt;?&gt; [] parameterTypes, Object [] parameters) throws InvocationTargetException&#123; Method method = getDeclaredMethod(object, methodName, parameterTypes); if(method == null)&#123; throw new IllegalArgumentException(\"Could not find method [\" + methodName + \"] on target [\" + object + \"]\"); &#125; method.setAccessible(true); try &#123; return method.invoke(object, parameters); &#125; catch(IllegalAccessException e) &#123; System.out.println(\"不可能抛出的异常\"); &#125; return null; &#125; /** * 直接设置对象属性值, 忽略 private/protected 修饰符, 也不经过 setter * @param object * @param fieldName * @param value */ public static void setFieldValue(Object object, String fieldName, Object value)&#123; Field field = getDeclaredField(object, fieldName); if (field == null) throw new IllegalArgumentException(\"Could not find field [\" + fieldName + \"] on target [\" + object + \"]\"); makeAccessible(field); try &#123; field.set(object, value); &#125; catch (IllegalAccessException e) &#123; System.out.println(\"不可能抛出的异常\"); &#125; &#125; /** * 直接读取对象的属性值, 忽略 private/protected 修饰符, 也不经过 getter * @param object * @param fieldName * @return */ public static Object getFieldValue(Object object, String fieldName)&#123; Field field = getDeclaredField(object, fieldName); if (field == null) throw new IllegalArgumentException(\"Could not find field [\" + fieldName + \"] on target [\" + object + \"]\"); makeAccessible(field); Object result = null; try &#123; result = field.get(object); &#125; catch (IllegalAccessException e) &#123; System.out.println(\"不可能抛出的异常\"); &#125; return result; &#125;&#125; B.利用反射赋值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class JDBCTools &#123; /** * 通用的查询方法,SQL为select类型. * 查询结果最多是一行记录. * @param clazz * @param sql * @param args * @return */ public static &lt;T&gt; T get(Class&lt;T&gt; clazz,String sql,Object ... args) &#123; //由于不能确定返回值,利用泛型实现,通过传过来的clazz参数确定返回值 Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; T entity = null; try &#123; conn = JDBCTools.getConnection(); ps = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; ps.setObject(i+1, args[i]); &#125; rs = ps.executeQuery(); ResultSetMetaData rsmd = rs.getMetaData(); //用HashMap暂时存放查询结果 //键:列的别名即对象属性名; 值:记录中对应列的值 Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); if(rs.next()) &#123; for (int i = 0; i &lt; rsmd.getColumnCount(); i++) &#123; result.put(rsmd.getColumnLabel(i+1), rs.getObject(i+1)); &#125; &#125; if(result.size()&gt;0) &#123; entity = clazz.newInstance(); //利用反射创建对象 for(Map.Entry&lt;String, Object&gt; entry:result.entrySet()) &#123; //利用反射为对象的各属性赋值 String fieldName = entry.getKey(); Object value = entry.getValue(); setFieldValue(entity, fieldName, value); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCTools.release(rs, ps, conn); &#125; return entity; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"JDBC-PreparedStatement","slug":"JDBC1-3","date":"2019-05-07T14:08:47.000Z","updated":"2019-10-06T09:38:17.000Z","comments":true,"path":"JDBC1-3.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-3.html","excerpt":"通过 PreparedStatement 来执行 SQL 语句","text":"通过 PreparedStatement 来执行 SQL 语句 一.PreparedStatement初识 之前我们都是通过 Statement 来执行的 SQL 语句 可以通过调用 Connection 对象的 preparedStatement() 方法获取PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口, 它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示, 调用PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数, 第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始), 第二个是设置的 SQL 语句中的参数的值 1.为什么要用PreparedStatement 看之前用Statement的程序, SQL语句需要我们去拼接, 很麻烦, 而PreparedStatement 就不需要我们拼接. 使用 PreparedStatement 代码的可读性和可维护性好. PreparedStatement 能最大可能提高性能: &emsp;– DBServer会对预编译语句提供性能优化. 因为预编译语句有可能被重复调用, 所以语句在被DBServer的编译器编译后的执行代码被缓存下来, 那么下次调用时只要是相同的预编译语句就不需要编译, 只要将参数直接传入编译过的语句执行代码中就会得到执行. &emsp;– 在statement语句中, 即使是相同操作但因为数据内容不一样, 所以整个语句本身不能匹配, 没有缓存语句的意义. 事实是没有数据库会对普通语句编译后的执行代码缓存. 这样每执行一次都要对传入的语句编译一次. &emsp;– (语法检查, 语义检查, 翻译成二进制命令, 缓存) PreparedStatement 可以有效防止 SQL 注入 2.SQL 注入 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查, 而在用户输入数据中注入非法的 SQL 语句段或命令, 从而利用系统的 SQL 引擎完成恶意行为的做法 对于 Java 而言, 要防范 SQL 注入, 只要用 PreparedStatement 取代 Statement 就可以了 &emsp;&emsp;例, 在数据库的UserInfo表中查询, 是否有某个用户名及对应密码. 用户名为: a’OR PASSWORD = ;密码为: OR ‘1’=’1’ 用 Statement 方式, 拼接的 SQL 语句如下: 12SELECT UserName,Password FROM UserInfo WHERE UserName = 'a'OR PASSWORD = ' AND Password = ' OR '1'='1'; 而 PreparedStatement 方式, 生成的 SQL 语句如下: 123SELECT UserName,Password FROM UserInfo WHERE UserName = \"a'OR PASSWORD = \"AND Password = \" OR '1'='1'\"; 二.使用PreparedStatement1.executeUpdate() 在 JDBCTools类中, 重载之前用Statement写的update(String sql)方法, 重载函数为update(String sql,Object … args). 这里的sql是带有占位符的SQL语句, 后面利用可变个数形参的方法传递参数. 若用数组的话, 在传递参数的时候还要将那些参数封装为数组. 这里的SQL语句是 insert delete update 语句, 不能是select语句. 之后用 PreparedStatement 的 executeUpdate() 方法执行生成的 SQL 语句. 1234567891011121314151617181920212223public class JDBCTools &#123; /** * 上述update()的重载,以PreparedStatement方式执行SQL * @param sql * @param args:SQL中占位符对应的值 */ public static void update(String sql,Object ... args) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; conn = JDBCTools.getConnection(); ps = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; ps.setObject(i+1, args[i]); &#125; ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(null,ps, conn); &#125; &#125;&#125; 2.executeQuery() 使用 PreparedStatement 的executeQuery()方法, 执行带有 select 的SQL语句. 当然, 你也可以和执行 JDBCTools 里的update()方法一样, 将查询数据库的代码抽取成一个工具方法, 之后会讲如何写一个通用的查询方法, 放在 JDBCTools 类里面. 我就直接测试了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.io.FilterInputStream;import java.io.IOException;import java.sql.Connection;import java.sql.Date;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.Scanner;import org.junit.Test;public class TestJDBCTools &#123; @Test public void testAddStudent() &#123; Student stu = getStudentFromConsole(); addStudent(stu); &#125; private Student getStudentFromConsole() &#123; Student stu = new Student(); Scanner scanner = new Scanner(System.in); System.out.print(\"请输入学生ID:\"); stu.setId(scanner.nextInt()); System.out.print(\"请输入学生Name:\"); stu.setName(scanner.next()); System.out.print(\"请输入学生Email:\"); stu.setEmail(scanner.next()); System.out.print(\"请输入学生Birth:\"); stu.setDate(Date.valueOf(scanner.next())); System.out.println(stu.getDate()); scanner.close(); return stu; &#125; public void addStudent(Student stu) &#123; String sql = \"INSERT INTO Student VALUES(?,?,?,?)\"; JDBCTools.update(sql,stu.getId(),stu.getName(),stu.getEmail(),stu.getDate()); &#125; //上边是测试的 PreparedStatement 实现的 update()方法 @Test public void testSearchStudent() &#123; int type = getSearchType(); Student stu = searchStudent(type); showMsg(stu); &#125; private void showMsg(Student stu) &#123; if(stu == null) &#123; System.out.println(\"查无此人!\"); &#125;else &#123; System.out.println(stu); &#125; &#125; private int getSearchType() &#123; System.out.print(\"请输入查询类型:1.id查询 2.姓名查询\"); Scanner scanner = new Scanner(new FilterInputStream(System.in)&#123; @Override public void close() throws IOException &#123; &#125; &#125;); int type = scanner.nextInt(); scanner.close(); if(type != 1 &amp;&amp; type != 2) &#123; System.out.println(\"输入的查询类型有误!\"); throw new RuntimeException(); &#125; return type; &#125; public Student searchStudent(int type) &#123; String sql = null; Student stu = null; Scanner scanner = new Scanner(System.in); if(type == 1) &#123; System.out.print(\"请输入要查询的id:\"); int id = scanner.nextInt(); sql = \"SELECT * FROM Student WHERE id = ?\"; stu = getStudent(sql,id); &#125;else &#123; System.out.print(\"请输入要查询的Name:\"); String name = scanner.next(); sql = \"SELECT * FROM Student WHERE name = '?'\"; stu = getStudent(sql,name); &#125; scanner.close(); return stu; &#125; private Student getStudent(String sql,Object ... args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; Student stu = null; try &#123; conn = JDBCTools.getConnection(); ps = conn.prepareStatement(sql); for(int i = 0;i &lt; args.length;i ++) &#123; ps.setObject(i+1, args[i]); &#125; rs = ps.executeQuery(); if(rs.next()) &#123; stu = new Student( rs.getInt(1), rs.getString(2).trim(), rs.getString(3).trim(), rs.getDate(4)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCTools.release(rs, ps, conn); &#125; return stu; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"JDBC-以OOP编写JDBC程序","slug":"JDBC1-2","date":"2019-05-07T09:20:15.000Z","updated":"2019-10-06T09:38:09.000Z","comments":true,"path":"JDBC1-2.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-2.html","excerpt":"以OOP(即面向对象编程)编写 JDBC 程序","text":"以OOP(即面向对象编程)编写 JDBC 程序 1.JDBC工具类 将一些常用的 JDBC 方法封装成一个 JDBC 工具类, 方便管理及调用. 下面程序中的配置文件 jdbc.properties 必须在当前项目的 src 目录下. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/* * 操作 JDBC 的工具类,封装了一些常用的方法 */public class JDBCTools &#123; /** * 获取数据库连接: * 通过读取配置文件,根据配置信息从数据库服务器获取一个连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123; InputStream is = JDBCTools.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties pro = new Properties(); pro.load(is); String url = pro.getProperty(\"jdbc\"); String user = pro.getProperty(\"user\"); String password = pro.getProperty(\"password\"); Class.forName(pro.getProperty(\"driver\")); Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125; /** * 通用的执行SQL更新语句,包括: Insert Delete Update语句, 不能执行select语句 * @param sql */ public static void update(String sql) &#123; Connection conn = null; Statement state = null; try &#123; conn = JDBCTools.getConnection(); state = conn.createStatement(); state.executeUpdate(sql); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(null,state, conn); &#125; &#125; /** * 关闭 ResultSet 和 Statement 和 Connection * @param rs * @param state * @param conn */ public static void release(ResultSet rs,Statement state,Connection conn) &#123; if(rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(state != null) &#123; try &#123; state.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.操作Student数据表中的数据 利用 Java 的对象操作数据表中的记录, 这里的 Java 对象之后会有个专业名词: JavaBean 处理表的记录时, 不再一个字段一个字段的处理, 而是把它们封装成一个对象, 统一处理. 可以称为 O-R映射 即 对象与关系(也可以说数据表)之间的映射, 对象的属性与数据表的字段一一对应. A.DB中的Student表 id name email birth 1 Bob bob@qq.com 1997-01-01 2 Jane jane@qq.com 1999-09-09 3 Jhon jhon@qq.com 2000-10-01 B.Java中的Student对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.sql.Date;public class Student &#123; private int id; private String name; private String email; private Date date; public Student() &#123; super(); &#125; public Student(int id, String name, String email, Date date) &#123; super(); this.id = id; this.name = name; this.email = email; this.date = date; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; @Override public String toString() &#123; return \"Student [id=\" + id + \", name=\" + name + \", email=\" + email + \", date=\" + date + \"]\"; &#125;&#125; C.插入一条Student记录12345678910111213141516171819202122232425262728293031323334353637import java.sql.Date;import java.util.Scanner;import org.junit.Test;public class TestJDBCOOP &#123; @Test public void testAddStudent() &#123; Student stu = getStudentFromConsole(); addStudent(stu); &#125; private Student getStudentFromConsole() &#123; Student stu = new Student(); Scanner scanner = new Scanner(System.in); System.out.print(\"请输入学生ID:\"); stu.setId(scanner.nextInt()); System.out.print(\"请输入学生Name:\"); stu.setName(scanner.next()); System.out.print(\"请输入学生Email:\"); stu.setEmail(scanner.next()); System.out.print(\"请输入学生Birth:\"); stu.setDate(Date.valueOf(scanner.next())); System.out.println(stu.getDate()); scanner.close(); return stu; &#125; public void addStudent(Student stu) &#123; String sql = \"INSERT INTO Student VALUES(\" + stu.getId() +\",'\" + stu.getName() + \"','\" + stu.getEmail() + \"','\" + stu.getDate() + \"')\"; System.out.println(sql); JDBCTools.update(sql); &#125;&#125; D.查询数据表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.io.FilterInputStream;import java.io.IOException;import java.sql.Connection;import java.sql.Date;import java.sql.ResultSet;import java.sql.Statement;import java.util.Scanner;import org.junit.Test;public class TestJDBCOOP &#123; @Test public void testSearchStudent() &#123; int type = getSearchType(); Student stu = searchStudent(type); showMsg(stu); &#125; private void showMsg(Student stu) &#123; if(stu == null) &#123; System.out.println(\"查无此人!\"); &#125;else &#123; System.out.println(stu); &#125; &#125; private int getSearchType() &#123; System.out.print(\"请输入查询类型:1.id查询 2.姓名查询\"); /*这里注意,若仍采用 Scanner scanner = new Scanner(System.in); *当 scanner.close()时 System.in流也会被关闭,之后再用到该流时, *会报 java.util.nosuchelementexception 异常 */ Scanner scanner = new Scanner(new FilterInputStream(System.in)&#123; @Override public void close() throws IOException &#123; &#125; &#125;); int type = scanner.nextInt(); scanner.close(); if(type != 1 &amp;&amp; type != 2) &#123; System.out.println(\"输入的查询类型有误!\"); throw new RuntimeException(); &#125; return type; &#125; public Student searchStudent(int type) &#123; String sql = null; Scanner scanner = new Scanner(System.in); if(type == 1) &#123; System.out.print(\"请输入要查询的id:\"); int id = scanner.nextInt(); sql = \"SELECT * FROM Student WHERE id = \" + id; &#125;else &#123; System.out.print(\"请输入要查询的Name:\"); String name = scanner.next(); sql = \"SELECT * FROM Student WHERE name = '\" + name +\"'\"; &#125; scanner.close(); return getStudent(sql); &#125; private Student getStudent(String sql) &#123; Connection conn = null; Statement state = null; ResultSet rs = null; Student stu = null; try &#123; conn = JDBCTools.getConnection(); state = conn.createStatement(); rs = state.executeQuery(sql); if(rs.next()) &#123; stu = new Student( rs.getInt(1), rs.getString(2).trim(), rs.getString(3).trim(), rs.getDate(4)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCTools.release(rs, state, conn); &#125; return stu; &#125;&#125; &emsp;&emsp;注意: 一个方法A中使用了Scanner, 且在里面把它关闭了, 然后又在方法B里再用Scanner时Scanner in = new Scanner(System.in); 会报 java.util.nosuchelementexception 异常. Java提供的IO包中, 一般都会处理资源级联关闭, 即关闭最外层包装的流, 内层被包被的流也会被关闭. 在Scanner类中使用了一个InputStreamReader()输入流, 对System.in进行再次包装. 当调用Scanner的close()方法时, 会执行InputStreamReader的关闭操作, 即调用用该包装类的close(). 该操作又会调用其内部包装的Sysetm.in的close操作. 若想解决关闭Scanner而不关闭System.in, 只需要对传入Scanner构造方法的System.in做下包装就可以了, 新包装的流要注意: 1.不产生新的流资源 2.是一个InputStream的实现类 3.close方法为空实现 你也可以利用上述方法, 解决其他类似的问题. 如下: 123456Scanner scanner = new Scanner(new FilterInputStream(System.in)&#123; //当关闭到 FilterInputStream 对应的流时, 便不再向内层流关闭 @Override public void close() throws IOException &#123; &#125;&#125;);","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"JDBC-DriverManger","slug":"JDBC1-1","date":"2019-05-06T00:42:45.000Z","updated":"2019-10-06T09:38:00.000Z","comments":true,"path":"JDBC1-1.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-1.html","excerpt":"JDBC——通过DriverManger获取数据库连接","text":"JDBC——通过DriverManger获取数据库连接 一.驱动管理类&emsp;&emsp;之前使用的是原始的方法即 Driver 接口获取数据库连接, 但是我们在开发中一般都用 DriverManger即驱动管理类来实现不同数据库的连接. 1.建立连接 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 JDBC URL 用于标识一个被注册的驱动程序, 驱动程序管理器通过这个 URL 选择正确的驱动程序, 从而建立到数据库的连接. JDBC URL的标准由三部分组成, 各部分间用冒号分隔.——jdbc: &lt;子协议&gt;:&lt;子名称&gt;——协议: JDBC URL中的协议总是jdbc——子协议: 子协议用于标识一个数据库驱动程序——子名称: 一种标识数据库的方法. 子名称可以依不同的子协议而变化, 用子名称的目的是为了定位数据库提供足够的信息 2.加载与注册JDBC驱动 加载 JDBC 驱动需调用 Class 类的静态方法 forName(), 向其传递要加载的 JDBC 驱动的类名. DriverManager 类是驱动程序管理器类, 负责管理驱动程序. 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例, 因为 Driver 接口的驱动程序类都包含了静态代码块, 在这个静态代码块中, 会调用DriverManager.registerDriver() 方法来注册自身的一个实例. 1234567891011121314151617181920212223242526272829303132import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.util.Properties;import org.junit.Test;public class Test &#123; @Test public void TestDriverManger() throws Exception &#123; //1.准备连接数据库的4个string String driverClass = null; String url = null; String user = null; String password = null; //读取类路径下的 jdbc.properties 文件 InputStream in = getClass().getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties properties = new Properties(); properties.load(in); driverClass = properties.getProperty(\"driver\"); url = properties.getProperty(\"jdbc\"); user = properties.getProperty(\"user\"); password = properties.getProperty(\"password\"); //2.加载驱动程序(实际上对应的Driver实现类中有注册驱动的静态代码块) Class.forName(driverClass); //3.通过 DriverManger的getConnection方法获取数据库的连接 Connection connection = DriverManager.getConnection(url, user, password); System.out.println(connection); connection.close(); &#125;&#125; 使用DriverManger的好处: 可以通过重载的 getConnection() 方法获取数据库连接, 较为方便 可以同时管理多个驱动程序: 若注册了多个数据库连接, 根据调用 getConnection() 方法时传入的参数来连接不同的数据库, 并返回不同的数据库连接. 123456789101112131415161718192021222324252627import java.sql.Connection;import java.sql.DriverManager;import org.junit.Test;public class Test &#123; @Test public void TestDriverManger() throws Exception &#123; String driver1 = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"; String driver2 = \"com.mysql.cj.jdbc.Driver\"; String url1 = \"jdbc:sqlserver://127.0.0.1:1433;DatabaseName=SPJDB\"; String url2 = \"jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\"; String user1 = \"root\"; String user2 = \"root\"; String password1 = \"root\"; String password2 = \"root\"; Class.forName(driver1); Connection conn1 = DriverManager.getConnection(url1, user1, password1); System.out.println(conn1); Class.forName(driver2); Connection conn2 = DriverManager.getConnection(url2, user2, password2); System.out.println(conn2); conn1.close(); conn2.close(); &#125;&#125; 二.访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，在连接建立后，需要对数据库进行访问，执行 sql 语句 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式: &emsp;–Statement &emsp;&emsp;–PrepatedStatement &emsp;&emsp;&emsp;–CallableStatement 1.Statement 通过调用 Connection 对象的 createStatement() 方法获取该对象 该对象用于执行静态的 SQL 语句, 并且返回执行结果 Statement 接口中定义了下列方法用于执行 SQL 语句: &emsp;&emsp;–ResultSet excuteQuery(String sql): 传入的sql可以是 select &emsp;&emsp;–int excuteUpdate(String sql): 传入的sql可以是 insert update delete, 不能是 select 更新数据库 数据库的更新操作一般指: Insert Delete Update SQL操作 1234567891011121314151617181920import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;import org.junit.Test;public class Test &#123; @Test public void TestDriverManger() throws Exception &#123; String driver = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"; String url = \"jdbc:sqlserver://localhost:1433;DatabaseName=SPJDB\"; String user = \"root\"; String password = \"root\"; String sql = \"Insert into SPJ values(1,1,2,1000);\"; Class.forName(driver); Connection conn = DriverManager.getConnection(url, user, password); Statement statement = conn.createStatement(); statement.executeUpdate(sql); statement.close(); conn.close(); &#125;&#125; &emsp;&emsp;在这里, 我们想写一个通用的方法, 该方法可以执行 INSERT UPDATE DELETE 语句. 同时, 我们还想将一些常用的 JDBC 操作封装在一起, 方便管理与使用. JDBCTools类: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/* * 操作 JDBC 的工具类,封装了一些常用的方法 */public class JDBCTools &#123; /** * 获取数据库连接: * 通过读取配置文件,根据配置信息从数据库服务器获取一个连接 * 现在这个方法每执行一次都会获取和释放一次数据库连接,这样不太好,之后会修改 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123; InputStream is = JDBCTools.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties pro = new Properties(); pro.load(is); String url = pro.getProperty(\"jdbc\"); String user = pro.getProperty(\"user\"); String password = pro.getProperty(\"password\"); Class.forName(pro.getProperty(\"driver\")); Connection conn = DriverManager.getConnection(url, user, password); return conn; &#125; /** * 关闭 Statement 和 Connection * @param state * @param conn */ public static void release(Statement state,Connection conn) &#123; if(state != null) &#123; try &#123; state.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; TestJDBCTools类: 123456789101112131415161718192021222324252627282930import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;import org.junit.Test;public class TestJDBCTools &#123; @Test public void test01() &#123; String sql = \"DELETE from SPJ where S_num=1 and P_num=1 and J_num=2;\"; update(sql); &#125; /** * 通用的更新方法,包括: Insert Delete Update * @param sql */ public void update(String sql) &#123; Connection conn = null; Statement state = null; try &#123; conn = JDBCTools.getConnection(); state = conn.createStatement(); state.executeUpdate(sql); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCTools.release(state, conn); &#125; &#125;&#125; 查询数据库 我在这里说的查询数据库, 指的是 Select SQL操作 通过 ResultSet 对象来操作查询的结果集 通过调用 Statement 对象的 excuteQuery() 方法创建该对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集, ResultSet 接口由数据库厂商实现 ResultSet 对象维护了一个指向当前数据行的游标, 初始的时候, 游标在第一行之前, 可以通过 ResultSet 对象的 next() 方法移动到下一行 ResultSet 接口的常用方法: &emsp;&emsp;&emsp;–boolean next() &emsp;&emsp;&emsp;–getXxx() , Xxx 可以是: String Int Time Date … &emsp;&emsp;&emsp;…… 12345678910111213141516171819202122232425262728293031323334353637import java.sql.Connection;import java.sql.Date;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;import org.junit.Test;public class TestJDBCTools &#123; @Test public void test02() &#123; Connection conn = null; Statement state = null; ResultSet rs = null; String sql = \"select * from Student\"; try &#123; conn = JDBCTools.getConnection(); state = conn.createStatement(); rs = state.executeQuery(sql); while(rs.next()) &#123; int id = rs.getInt(1); String name = rs.getString(\"name\"); String eamil = rs.getString(3); Date date = rs.getDate(4); System.out.print(id+\";\"); System.out.print(name+\";\"); System.out.print(eamil+\";\"); System.out.println(date); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //在这里, 别忘了去修改一下 JDBCTools 类里的 release() 方法 JDBCTools.release(rs, state, conn); &#125; &#125;&#125;","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"JDBC初识","slug":"JDBC1-0","date":"2019-05-06T00:00:35.000Z","updated":"2019-10-06T09:37:52.000Z","comments":true,"path":"JDBC1-0.html","link":"","permalink":"https://blog.crainyday.com/JDBC1-0.html","excerpt":"JDBC——Java Database Connectivity","text":"JDBC——Java Database Connectivity 一.数据持久化 持久化(persistence): 把数据保存到可掉电式存储设备中以供之后使用. 大多数情况下, 特别是企业级应用, 数据持久化意味着将内存中的数据保存到硬盘上加以”固化”, 而持久化的实现过程大多通过各种关系数据库来完成. 持久化的主要应用是将内存中的数据存储在关系型数据库中, 当然也可以存储在磁盘文件、XML数据文件中. 二.Java中的数据存储技术 ① JDBC直接访问数据库② JDO技术(即Java Data Object)③ 第三方O/R工具, 如: Hibernate, ibatis等 JDBC是Java访问数据库的基石, JDO、Hibernate等只是更好的封装了JDBC. 三.JDBC基础 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口(一组API), 定义了用来访问数据库的标准Java类库, 使用这个类库可以以一种标准的方法、方便地访问数据库资源. JDBC为访问不同的数据库提供了一种统一的途径, 为开发者屏蔽了一些细节问题. JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统, 这样就使得程序员无需对特定的数据库系统的特点有过多的了解, 从而大大简化和加快了开发过程. JDBC驱动程序由数据库厂商实现. JDBC编程是一种面向接口的编程, 我们在程序中用的是java.sql下的Connection接口, 但是该接口在java包里并没有具体的实现, 其实现就是JDBC驱动程序. 1.JDBC体系结构JDBC接口(API)包括两个层次: 面向应用的API: Java API, 抽象接口, 供应用程序开发人员使用(连接数据库, 执行SQL语句, 获得结果). 面向数据库的API: Java Driver API, 供开发商开发数据库驱动程序用. 2.JDBC驱动程序 JDBC驱动程序: 各个数据库厂商根据JDBC的规范制作的 JDBC 实现类的类库 JDBC分类: 第一类: JDBC-ODBC桥. 第二类: 部分本地API部分Java的驱动程序. 第三类: JDBC网络纯Java驱动程序. 第四类: 本地协议的纯 Java 驱动程序. 第三、四两类都是纯Java的驱动程序, 因此, 对于Java开发者来说, 它们在性能、可移植性、功能等方面都有优势. 第一类: JDBC-ODBC桥 第二类: 部分本地API部分Java的驱动程序. 第三类: JDBC网络纯Java驱动程序. 一般在做JSP网站开发时用. 第四类: 本地协议的纯 Java 驱动程序. 我们之后主要将的是第四类: 本地协议的纯 Java 驱动程序. 其实, 第三类和第四类差不多. 四.JDBC API JDBC API 是一系列的接口, 它使得应用程序能够进行数据库联接, 执行SQL语句, 并且得到返回结果. &emsp;&emsp;通过Driver Manger我们能获取到代表数据库连接的Connection, 通过Connection我们能获取到用于执行SQL语句的 Statement , 通过Statement 我们能获取到代表查询结果的 Result. 五.Driver接口 Java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口. 这个接口是提供给数据库厂商使用的, 不同数据库厂商提供不同的实现. 在程序中不需要直接去访问实现了 Driver 接口的类, 而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现 但是我们是可以通过Driver接口来获取数据库连接的. 注意: 数据库的连接是稀缺资源, 用完后必须要关闭连接. 1.将JDBC驱动引入项目 ①下载需要的 JDBC 驱动 ②在项目下新建一个 lib 目录. ③将用到的 JDBC 驱动(jar文件, 例: mysql-connector-java-8.0.15.jar)放入该目录. ④在 lib 目录下的 JDBC 驱动上, 右键单击, 依次选择 “构建路径”, “添加至构建路径”. 之后, JDBC驱动就成功导入项目了, 在 “引用的库” 里面可以看到. 2.Driver获取mysql的连接注意: 测试时要开启MySQL服务 1234567891011121314151617import java.sql.SQLException;import java.sql.Connection;import java.sql.Driver;public class Test&#123; public static void main(String[] args) throws SQLException&#123; //以前的mysql JDBC驱动 Driver实现类为: com.mysql.jdbc.Driver Driver driver = new com.mysql.cj.jdbc.Driver(); String url = \"jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\"; Properties info = new Properties(); info.put(\"user\", \"root\"); info.put(\"password\", \"root\"); Connection conn = driver.connect(url, info); System.out.println(conn); conn.close(); &#125;&#125; 3.Driver获取任何数据库的连接 编写一个通用的方法, 在不修改Java源码的情况下, 可以获取任何数据库的连接 解决方案: 将Driver接口实现类的全类名、要连接数据库的URL、数据库用户名user、用户名密码password放进一个配置文件里. 通过修改配置文件的方式实现和具体的数据库解耦. 在项目的src目录下, 新建一个 jdbc.properties 文件, 内容: 123456789101112131415161718#SQL Server DBdriver=com.microsoft.sqlserver.jdbc.SQLServerDriverjdbc=jdbc:sqlserver://127.0.0.1:1433;DatabaseName=SPJDBuser=rootpassword=root#MySQL DB#driver=com.mysql.jdbc.Driver#driver=com.mysql.cj.jdbc.Driver#jdbcUrl=jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false#user=root#password=root#Oracle DB#driver=oracle.jdbc.driver.OracleDriver#jdbcUrl=jdbc:oracle:thin:@localhost:1521:orcl#user=scott#password=java 123456789101112131415161718192021222324252627282930313233343536373839import java.sql.SQLException;import java.util.Properties;import org.junit.Test;import java.io.InputStream;import java.sql.Connection;import java.sql.Driver;public class Test &#123; //注意: 这里用到了 junit 单元测试类 @Test public void testConnection() throws Exception &#123; System.out.println(getConnection()); &#125; public Connection getConnection() throws Exception &#123; String driverClass = null; String jdbcUrl = null; String user = null; String password = null; //读取类路径下的 jdbc.properties 文件 InputStream in = getClass().getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties properties = new Properties(); properties.load(in); driverClass = properties.getProperty(\"driver\"); jdbcUrl = properties.getProperty(\"jdbc\"); user = properties.getProperty(\"user\"); password = properties.getProperty(\"password\"); //利用反射, 实例化全类名对应的类 即 创建不同驱动的Driver对象 Driver driver = (Driver) Class.forName(driverClass).newInstance(); Properties info = new Properties(); info.put(\"user\", user); info.put(\"password\", password); Connection connection = driver.connect(jdbcUrl, info); return connection; &#125;&#125; 你只需关闭properties文件里某个数据库配置的注释, 注释其他的数据库配置. 就可以得到不同的数据库连接 4.关于连接字符串 对于 MySQL 的连接字符串，自 Connector 8.0 新版本之后，jdbcUrl 必须添加 serverTimezone 属性。 当然，一般这样设置就OK了： 12&gt; jdbcUrl=jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&gt; 更多新增内容，详见 MySQL 官网 doc。","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://blog.crainyday.com/tags/JDBC/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"},{"name":"Database","slug":"Database","permalink":"https://blog.crainyday.com/tags/Database/"}]},{"title":"jQuery中的动画","slug":"jQuery1-6","date":"2019-04-28T07:16:20.000Z","updated":"2019-10-06T09:40:57.000Z","comments":true,"path":"jQuery1-6.html","link":"","permalink":"https://blog.crainyday.com/jQuery1-6.html","excerpt":"jQuery中的简单动画","text":"jQuery中的简单动画 一.hide()与show() 通过hide()与show()方法实现动画, 其中hide()相当于css(“display”,”none”). 以上两个方法不带任何参数时没有任何动画效果, 可以通过添加一个速度参数使元素”动起来”. 这两个方法会同时改变内容的高度、宽度、透明度 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; .panel &#123; width: 400px; margin: 0 auto; &#125; .head &#123; width: 400px; background-color: #bfa; &#125; .head:hover &#123; cursor: pointer; &#125; .content &#123; width: 400px; background-color: #98C8EF; display: none; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $(\".head\").hover(function() &#123; $(\".content\").show(1000); &#125;, function() &#123; $(\".content\").hide(1000); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"panel\"&gt; &lt;h2 class=\"head\"&gt;什么是jQuery?&lt;/h2&gt; &lt;div class=\"content\"&gt; jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 二.slideDown()与slideUp() 这两个方法只会改变元素的高度, 也可以传一个速度参数 12345678//html其余代码同上$(function() &#123; $(\".head\").hover(function() &#123; $(\".content\").slideDown(1000); &#125;, function() &#123; $(\".content\").slideUp(1000); &#125;);&#125;); 三.fadeIn()与fadeOut() 这两个方法只会改变元素的透明度 12345678//html其余代码同上$(function() &#123; $(\".head\").hover(function() &#123; $(\".content\").fadeIn(); &#125;, function() &#123; $(\".content\").fadeOut(); &#125;);&#125;); 四.切换元素的可见性1.toggle() 直接切换元素可见状态, 不传参数的话, 没有动画的效果.传一个速度参数, 便可看见动画的效果 这个方法相当于show()与hide()方法的组合 123456//html其余代码同上$(function() &#123; $(\".head\").click(function()&#123; $(\".content\").toggle(\"slow\"); &#125;);&#125;); 2.slideToggle() 通过高度的变化来切换元素的可见状态 想当于slideDown()与slideUp()方法的组合 123456//html其余代码同上$(function() &#123; $(\".head\").click(function()&#123; $(\".content\").slideToggle(\"slow\"); &#125;);&#125;); 3.fadeToggle() 通过透明度来切换元素的可见状态 相当于fadeIn()与fadeOut()方法的组合 123456//html其余代码同上$(function() &#123; $(\".head\").click(function()&#123; $(\".content\").fadeToggle(\"slow\"); &#125;);&#125;); 4.fadeTo() 把元素的透明度以渐近的方式调整到指定值(0-1之间) 12345678910//html其余代码同上$(function() &#123; $(\".content\").show(); var i = 1; $(\".head\").click(function()&#123; //每次点击透明度减少0.2 $(\".content\").fadeTo(\"slow\",i); i -= 0.2; &#125;);&#125;);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/tags/jQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"jQuery中的事件","slug":"jQuery1-5","date":"2019-04-28T02:52:48.000Z","updated":"2019-10-06T09:40:43.000Z","comments":true,"path":"jQuery1-5.html","link":"","permalink":"https://blog.crainyday.com/jQuery1-5.html","excerpt":"jQuery中的事件","text":"jQuery中的事件 一.加载DOM 在页面加载完毕后, 浏览器会通过JS为DOM元素添加事件. 在常规JS代码中, 通常使用window.onload方法, 而在jQuery中使用$(document).ready()方法, 可简写为$(). 两者区别: window.onload必须等待网页中的所有内容加载完毕后(包括图片)才能执行其中代码, 而且只会有一个window.onload会执行, 因为后续修改window.onload会覆盖之前的 $(document).ready()在网页中的DOM结构绘制完毕之后便会执行, 可能DOM元素关联的东西并没有加载完成, 而且这个函数可编写多个, 这多个中的代码均会执行. 二.绑定事件html部分: 1234567891011121314151617181920212223242526272829303132333435&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; .panel&#123; width: 400px; margin: 0 auto; &#125; .head&#123; width: 400px; background-color: #bfa; &#125; .head:hover&#123; cursor: pointer; &#125; .content&#123; width: 400px; background-color: #98C8EF; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"panel\"&gt; &lt;h2 class=\"head\"&gt;什么是jQuery?&lt;/h2&gt; &lt;div class=\"content\"&gt; jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 1.直接绑定 is()方法: 用来判断给定的某个jQuery对象是否符合指定的jQuery选择器 12345678910$(function()&#123; $(\".head\").click(function()&#123; var flag = $(\".content\").is(\":hidden\"); if(flag)&#123; $(\".content\").show(); &#125;else&#123; $(\".content\").hide(); &#125; &#125;);&#125;); 2.bind()绑定12345678910$(function()&#123; $(\".head\").bind(\"click\",function()&#123; var flag = $(\".content\").is(\":hidden\"); if(flag)&#123; $(\".content\").show(); &#125;else&#123; $(\".content\").hide(); &#125; &#125;);&#125;); 三.合成事件 hover(): 模拟光标悬停事件. 当光标移动到元素上时, 会触发指定的第一个函数, 当光标移出这个元素时, 会触发指定的第二个函数. toggle(): 用于模拟鼠标连续单击事件. 第一次单击元素, 触发第一个函数, 再次单击同一个元素, 触发第二个函数. 之后依次类推. 现在废除了之前说的作用, 只用来切换元素的可见性 1.hover()12345678//html代码还是上方的$(function()&#123; $(\".head\").hover(function()&#123; $(\".content\").show(); &#125;,function()&#123; $(\".content\").hide(); &#125;);&#125;); 四.移除事件 unbind()方法:移除某按钮上所有的click事件: $(“#btn”).unbind(“click”);移除某按钮上所有的事件: $(“#btn”).unbind(); one()方法:该方法可以为元素绑定处理函数. 当处理函数触发一次后, 便会被立即删除. 即在每个对象上, 事件处理函数只会被执行一次. 五.事件冒泡 事件会按照DOM层次结构像水泡一样不断向上, 直到传递到顶端 解决: 在事件处理函数中返回false, 会对事件停止冒泡, 还可以停止元素的默认行为. 由于事件的冒泡, 以下例子中, 点击p标签会向上传递点击事件, body和div的点击事件也会被触发. 123456789101112131415161718192021222324252627282930313233343536&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; .content&#123; width: 200px; height: 200px; background-color: #bfa; &#125; p&#123; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $(\"body\").click(function()&#123; alert(\"body click\"); &#125;); $(\".content\").click(function()&#123; alert(\"div click\"); &#125;); $(\"p\").click(function()&#123; alert(\"p click\"); //return false;//阻止事件冒泡 &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;body &lt;div class=\"content\"&gt;div &lt;p&gt;p&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 六.事件对象的属性 事件对象: 当事件被触发时, 事件对象就被创建了. 在程序中使用事件对象, 只需要为事件对象的响应函数添加一个参数来接收该事件对象. 该事件对象只有事件处理函数才能访问到. 事件处理函数执行完毕后, 事件对象便被销毁. 常用到的事件对象的属性: event.pageX, event.pageY: 获取光标相对于页面(而不是浏览器窗口)的x,y坐标","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/tags/jQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"jQuery的DOM","slug":"jQuery1-4","date":"2019-04-27T11:31:59.000Z","updated":"2019-10-06T09:40:38.000Z","comments":true,"path":"jQuery1-4.html","link":"","permalink":"https://blog.crainyday.com/jQuery1-4.html","excerpt":"jQUery中的DOM操作","text":"jQUery中的DOM操作 一.DOM简介 DOM(Document Object Model—文档对象模型): 一种与浏览器、平台、语言无关的接口, 使用该接口可以轻松地访问页面中所有的标准组件 DOM操作的分类: DOM Core: DOM Core并不专属于JS, 任何一种支持DOM的程序设计语言都可以使用它. 它的用途并非仅限于处理网页, 也可以用来处理任何一种用标记语言编写的文档, 如:XML HTML DOM: 使用JS和DOM为HTML文件编写脚本时, 有许多专属于HTML-DOM的属性 CSS-DOM: 针对于CSS操作, 在JS中, CSS-DOM主要用于获取和设置style对象的各种属性 二.jQuery操作HTML-DOM1.查找结点 查找属性结点: 通过jQuery选择器完成 操作属性节点: 查找到元素对应节点后, 通过jQuery对象的attr()方法来获取它的各属性值 操作文本节点: 通过text()方法 2.创建节点 使用jQuery的工厂函数$(str); 会根据传入的html格式str字符串, 创建一个DOM对象, 并把这个DOM对象包装成一个jQuery对象返回. 注意: 创建的新元素节点不会被自动添加到文档中, 需要手动调用jQuery的方法插入到当前文档. 当创建单个元素时, 标签开始, 必须要结束该标签.例: $(““) 创建文本节点就是在创建元素节点时直接将文本内容写进去; 创建属性节点也是这样. 3.插入节点 方法 描述 append() 向每个匹配的元素的内容的结尾处追加内容 appendTo() 将每个匹配的元素追加到指定元素的内部的结尾处 prepend() 向每个匹配的元素的内容的开始处插入内容 prependTo() 将每个匹配的元素插入到指定元素的内部的开始处 这些方法插入的节点都将成为文档中某个节点的子节点. 方法 描述 after() 向每个匹配的元素的之后插入内容 insertAfter() 将匹配的元素的插入到指定的元素之后 before() 向每个匹配的元素的之前插入内容 insertBefore() 将匹配的元素的插入到指定的元素之首 以上方法不但能将新创建的DOM元素插入到文档中, 也能对原有的DOM元素进行移动. 123456//下面两种方法等价:$(\"#id\").append(\"&lt;p&gt;我是追加的内容&lt;/p&gt;\");$(\"&lt;p&gt;我是追加的内容&lt;/p&gt;\").appendTo($(\"#id\"));//prepend与prependTo和上述方法类似//after与insertAfter和上述方法类似//before与insertBefore和上述方法类似 4.删除节点 remove(): 从DOM中删除所有匹配的元素, 传入的参数用于根据jQuery表达式来筛选元素. 当某个节点用remove()方法删除后, 该节点以及所包含的所有后代节点将被同时删除. 这个方法的返回值是一个指向已被删除的节点的引用. empty(): 清空节点—清空元素中的所有后代节点(不包括属性节点). 5.复制节点 clone(): 克隆匹配的DOM元素, 返回值为克隆后的副本. 此时复制的节点不具有任何行为. clone(true): 复制元素的同时也可复制元素中的事件. 6.替换节点 replaceWith(): 将所有匹配到的元素都替换为指定的HTML或DOM元素 replaceAll(): 颠倒了的replaceWith()方法, 与append()与appendTo()方法类似 注意: 若在替换之前, 已在元素上绑定了事件, 替换之后原先绑定的事件会与原来的元素一起消失. 若想互换文档中的两个节点的话, 要先克隆其中一个节点. 7.包裹节点 做一些网页特效时, 往往会用到这些方法. wrap(): 将匹配到的所有元素一个个用其他元素包裹起来 wrapAll(): 将匹配到的所有元素作为整体用一个元素包裹起来 wrapInner(): 将每一个匹配元素的内容用其他结构化标记包裹起来 123//例:$(\"li\").wrap(\"&lt;font color='red'&gt;&lt;/font&gt;\");//之后所有的li将变为:&lt;font color='red'&gt;&lt;li&gt;...&lt;/li&gt;&lt;/font&gt; 三.jQuery操作CSS-DOM1.操作class属性 获取和设置class属性都可以使用attr()方法, 也可以使用专门的 方法 描述 addClass() 为class属性添加一个值 removeClass() 从匹配元素中删除全部或指定class属性的值 toggleClass() 切换class属性的值, 有则删除, 无则添加 hasClass() 判断元素class属性是否有某个值 2.操作元素样式 操作元素的css样式, 均可通过 css() 方法实现 通过opacity属性操作元素透明度: css(“opacity”,value); 通过width和height属性操作元素宽高, 也可直接用width()和height()方法操作 获取元素在当前视窗中的相对位移: offset()方法. 其返回的对象包含两个属性: top和left. 该方法只对可见元素有效","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/tags/jQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"jQuery选择器续2","slug":"jQuery1-3","date":"2019-04-24T00:21:23.000Z","updated":"2019-10-06T09:40:26.000Z","comments":true,"path":"jQuery1-3.html","link":"","permalink":"https://blog.crainyday.com/jQuery1-3.html","excerpt":"jQuery过滤选择器续","text":"jQuery过滤选择器续 1.子元素过滤选择器 选择器 描述 返回 :nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或奇偶元素(index&gt;=1) 集合元素 :first-child 选取每个父元素的第一个子元素 集合元素 :last-child 选取每个父元素的最后一个子元素 集合元素 :only-child 若某元素是其父元素中唯一的子元素, 那么它将被匹配 集合元素 :nth-child()详解: :nth-child(even/odd):能选取每个父元素下的索引值为偶/奇数的元素 :nth-child(2):能选取每个父元素下的索引值为2的元素 :nth-child(3n):能选取每个父元素下索引值为3的倍数的元素 :nth-child(3n+1):能选取每个父元素下索引值为3n+1的元素 选取子元素时, 需要在选择器前添加一个空格 html部分: 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"选取每个class为one的div父元素下的第2个子元素.\" id=\"btn1\"/&gt; &lt;input type=\"button\" value=\"选取每个class为one的div父元素下的第一个子元素.\" id=\"btn2\"/&gt; &lt;input type=\"button\" value=\"选取每个class为one的div父元素下的最后一个子元素.\" id=\"btn3\"/&gt; &lt;input type=\"button\" value=\"如果class为one的div父元素下的仅仅只有一个子元素，那么选中这个子元素.\" id=\"btn4\"/&gt; &lt;br&gt;&lt;br&gt; &lt;div class=\"one\" id=\"one\"&gt; id 为 one,class 为 one 的div &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\" id=\"two\" title=\"test\"&gt; id为two,class为one,title为test的div &lt;div class=\"mini\" title=\"other\"&gt;class为mini,title为other&lt;/div&gt; &lt;div class=\"mini\" title=\"test\"&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\" title=\"tesst\"&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=\"display:none;\" class=\"none\"&gt;style的display为\"none\"的div&lt;/div&gt; &lt;div class=\"hide\"&gt;class为\"hide\"的div&lt;/div&gt; &lt;div&gt; 包含input的type为\"hidden\"的div&lt;input type=\"hidden\" value=\"123456789\" size=\"8\"&gt; &lt;/div&gt; &lt;div id=\"mover\"&gt;正在执行动画的div元素.&lt;/div&gt;&lt;/body&gt; JS部分: 123456789101112131415$(document).ready(function()&#123; $(\"#btn1\").click(function()&#123; //选取子元素, 需要在选择器前添加一个空格. $(\"div.one :nth-child(2)\").css(\"background\", \"#ffbbaa\"); &#125;); $(\"#btn2\").click(function()&#123; $(\"div.one :first-child\").css(\"background\", \"#ffbbaa\"); &#125;); $(\"#btn3\").click(function()&#123; $(\"div.one :last-child\").css(\"background\", \"#ffbbaa\"); &#125;); $(\"#btn4\").click(function()&#123; $(\"div.one :only-child\").css(\"background\", \"#ffbbaa\"); &#125;);&#125;); 2.表单对象属性过滤选择器 选择器 描述 返回 :enabled 选取所有可用元素 集合元素 :disabled 选取所有不可用元素 集合元素 :checked 选取所有被选中的元素(单选框,复选框) 集合元素 :selected 选取所有被选中选项元素(下拉列表) 集合元素 html部分: 点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;表单对象属性过滤选择器&lt;/h3&gt; &lt;button id=\"btn1\"&gt;对表单内 可用input 赋值操作.&lt;/button&gt; &lt;button id=\"btn2\"&gt;对表单内 不可用input 赋值操作.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=\"btn3\"&gt;获取多选框选中的个数.&lt;/button&gt; &lt;button id=\"btn4\"&gt;获取多选框选中的内容.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;button id=\"btn5\"&gt;获取下拉框选中的内容.&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;form id=\"form1\" action=\"#\"&gt; 可用元素: &lt;input name=\"add\" value=\"可用文本框1\"/&gt;&lt;br&gt; 不可用元素: &lt;input name=\"email\" disabled=\"true\" value=\"不可用文本框\"/&gt;&lt;br&gt; 可用元素: &lt;input name=\"che\" value=\"可用文本框2\"/&gt;&lt;br&gt; 不可用元素: &lt;input name=\"name\" disabled=\"true\" value=\"不可用文本框\"/&gt;&lt;br&gt; &lt;br&gt; 多选框: &lt;br&gt; &lt;input type=\"checkbox\" name=\"newsletter\" checked=\"checked\" value=\"test1\" /&gt;test1 &lt;input type=\"checkbox\" name=\"newsletter\" value=\"test2\" /&gt;test2 &lt;input type=\"checkbox\" name=\"newsletter\" value=\"test3\" /&gt;test3 &lt;input type=\"checkbox\" name=\"newsletter\" checked=\"checked\" value=\"test4\" /&gt;test4 &lt;input type=\"checkbox\" name=\"newsletter\" value=\"test5\" /&gt;test5 &lt;br&gt;&lt;br&gt; 下拉列表1: &lt;br&gt; &lt;select name=\"test\" multiple=\"multiple\" style=\"height: 100px\"&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option selected=\"selected\"&gt;辽宁&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option selected=\"selected\"&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; 下拉列表2: &lt;br&gt; &lt;select name=\"test2\"&gt; &lt;option&gt;浙江&lt;/option&gt; &lt;option&gt;辽宁&lt;/option&gt; &lt;option selected=\"selected\"&gt;北京&lt;/option&gt; &lt;option&gt;天津&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;湖北&lt;/option&gt; &lt;/select&gt; &lt;textarea rows=\"\" cols=\"\"&gt;&lt;/textarea&gt; &lt;/form&gt; &lt;/body&gt; js部分: 12345678910111213141516171819202122232425262728293031323334$(function()&#123; $(\"#btn1\").click(function()&#123; //使所有的可用的单行文本框的 value 值变为 已重新赋值 alert($(\":text:enabled\").val()); $(\":text:enabled\").val(\"已重新赋值\"); &#125;); $(\"#btn2\").click(function()&#123; $(\":text:disabled\").val(\"www.baidu.com\"); &#125;); $(\"#btn3\").click(function()&#123; var num = $(\":checkbox[name='newsletter']:checked\").length; alert(num); &#125;); $(\"#btn5\").click(function()&#123; //实际被选择的不是 select, 而是 select 的 option 子节点 //所以要加一个 空格. //var len = $(\"select :selected\").length //alert(len); //因为 $(\"select :selected\") 选择的是一个数组 //当该数组中有多个元素时, 通过 .val() 方法就只能获取第一个被选择的值了. //alert($(\"select :selected\").val()); //jQuery 对象遍历的方式使 each, 在 each 内部的 this 是正在 //得到的 DOM 对象, 而不是一个 jQuery 对象 $(\"select :selected\").each(function()&#123; alert(this.value); &#125;); &#125;); $(\"#btn4\").click(function()&#123; $(\":checkbox[name='newsletter']:checked\").each(function()&#123; alert(this.value); &#125;); &#125;);&#125;) 3.表单选择器 选择器 描述 返回 :input 选取所有的input, textarea,select,button元素 集合元素 :text 选取所有的单行文本框 集合元素 :password 选取所有的密码框元素 集合元素 :radio 选取所有的单选框 集合元素 :checkbox 选取所有的多选框 集合元素 :submit 选取所有的提交按钮 集合元素 :image 选取所有的图像按钮 集合元素 :reset 选取所有的重置按钮 集合元素 :button 选取所有的按钮 集合元素 :file 选取所有的上传域 集合元素 :hidden 选取所有的不可见元素 集合元素","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/tags/jQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"jQuery选择器续","slug":"jQuery1-2","date":"2019-04-22T13:51:34.000Z","updated":"2019-10-06T09:40:12.000Z","comments":true,"path":"jQuery1-2.html","link":"","permalink":"https://blog.crainyday.com/jQuery1-2.html","excerpt":"jQuery选择器续","text":"jQuery选择器续 过滤选择器 1.内容过滤选择器 内容过滤选择器的过滤规则主要体现在它所包含的子元素和文本上 选择器 描述 返回 :contains(text) 选取含有文本内容为text的元素 集合元素 :empty 选取不包含子元素或文本为空的元素 集合元素 :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 :parent 选取含有子元素或者文本的元素 集合元素 html部分: 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"选择 含有文本 'di' 的 div 元素\" id=\"btn1\" /&gt; &lt;input type=\"button\" value=\"选择不包含子元素(或者文本元素) 的 div 空元素\" id=\"btn2\" /&gt; &lt;input type=\"button\" value=\"选择含有 class 为 mini 元素的 div 元素\" id=\"btn3\" /&gt; &lt;input type=\"button\" value=\"选择含有子元素(或者文本元素)的div元素\" id=\"btn4\" /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=\"one\" id=\"one\"&gt; id 为 one,class 为 one 的div &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\" id=\"two\" title=\"test\"&gt; id为two,class为one,title为test的div &lt;div class=\"mini\" title=\"other\"&gt;class为mini,title为other&lt;/div&gt; &lt;div class=\"mini\" title=\"test\"&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\" title=\"tesst\"&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=\"display:none;\" class=\"none\"&gt;style的display为\"none\"的div&lt;/div&gt; &lt;div class=\"hide\"&gt;class为\"hide\"的div&lt;/div&gt; &lt;div&gt; 包含input的type为\"hidden\"的div&lt;input type=\"hidden\" size=\"8\"&gt; &lt;/div&gt; &lt;div id=\"mover\"&gt;正在执行动画的div元素.&lt;/div&gt;&lt;/body&gt; JS部分: 123456789101112131415$(document).ready(function()&#123; $(\"#btn1\").click(function()&#123; $(\"div:contains('di')\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn2\").click(function()&#123; $(\"div:empty\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn3\").click(function()&#123; $(\"div:has(.mini)\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn4\").click(function()&#123; $(\"div:parent\").css(\"background\", \"#bfa\"); //$(\"div:not(:empty)\").css(\"background\", \"#bfa\"); &#125;);&#125;); 2.可见性过滤选择器 可见性过滤选择器是根据元素的可见和不可见状态来选择相应的元素 可见选择器: hidden不仅包括样式属性display为none的元素, 也包含文本隐藏域(\\&lt;input type=’hidden’/>)和 visible:hidden之类的元素 选择器 描述 返回 :hidden 选取所有不可见元素 集合元素 :visible 选取所有可见元素 集合元素 html部分: 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"选取所有可见的 div 元素\" id=\"btn1\"&gt; &lt;input type=\"button\" value=\"选择所有不可见的 div 元素\" id=\"btn2\" /&gt; &lt;input type=\"button\" value=\"选择所有不可见的 input 元素\" id=\"btn3\" /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=\"one\" id=\"one\"&gt; id 为 one,class 为 one 的div &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\" id=\"two\" title=\"test\"&gt; id为two,class为one,title为test的div &lt;div class=\"mini\" title=\"other\"&gt;class为mini,title为other&lt;/div&gt; &lt;div class=\"mini\" title=\"test\"&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\" title=\"tesst\"&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=\"display:none;\" class=\"none\"&gt;style的display为\"none\"的div&lt;/div&gt; &lt;div class=\"hide\"&gt;class为\"hide\"的div&lt;/div&gt; &lt;div&gt; 包含input的type为\"hidden\"的div &lt;input type=\"hidden\" value=\"123456789000\" size=\"8\"&gt; &lt;/div&gt; &lt;div id=\"mover\"&gt;正在执行动画的div元素.&lt;/div&gt;&lt;/body&gt; JS部分: 1234567891011121314151617$(document).ready(function()&#123; $(\"#btn1\").click(function()&#123; $(\"div:visible\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn2\").click(function()&#123; //alert($(\"div:hidden\").length); //show(time):可以使不可见的元素变为可见,time表示时间,以ms为单位 //jQuery的很多方法支持方法的连缀,即一个方法的返回值仍然是调用该 //方法的 jQuery 对象:可以继续调用该对象的其他方法. $(\"div:hidden\").show(2000).css(\"background\",\"#bfa\"); &#125;); $(\"#btn3\").click(function()&#123; //attr()方法,传一个参数表示获取属性值 //val() 方法可以返回某一个表单元素的 value 属性值. alert($(\"input:hidden\").val()); &#125;);&#125;); 3.属性过滤选择器 属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素, 属性过滤选择器不以”:”开头 选择器 描述 返回 [attribute] 选取拥有此属性的元素 集合元素 [attribute=value] 选取指定属性的值为value的元素 集合元素 [attribute!=value] 选取指定属性的值不等于value的元素 集合元素 [attribute^=value] 选取指定属性的值以value开始的元素 集合元素 [attribute$=value] 选取指定属性的值以value结束的元素 集合元素 [attribute*=value] 选取指定属性的值含有value的元素 集合元素 [selector1]…[selectorn] 用属性选择器合并成一个复合属性选择器,满足多个条件,每选择一次,缩小一次范围 集合元素 html部分: 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"选取含有 属性title 的div元素.\" id=\"btn1\"/&gt; &lt;input type=\"button\" value=\"选取 属性title值等于'test'的div元素.\" id=\"btn2\"/&gt; &lt;input type=\"button\" value=\"选取 属性title值不等于'test'的div元素(没有属性title的也将被选中).\" id=\"btn3\"/&gt; &lt;input type=\"button\" value=\"选取 属性title值 以'te'开始 的div元素.\" id=\"btn4\"/&gt; &lt;input type=\"button\" value=\"选取 属性title值 以'est'结束 的div元素.\" id=\"btn5\"/&gt; &lt;input type=\"button\" value=\"选取 属性title值 含有'es'的div元素.\" id=\"btn6\"/&gt; &lt;input type=\"button\" value=\"组合属性选择器,首先选取有属性id的div元素，然后在结果中 选取属性title值 含有'es'的 div 元素.\" id=\"btn7\"/&gt; &lt;input type=\"button\" value=\"选取 含有 title 属性值, 且title 属性值不等于 test 的 div 元素.\" id=\"btn8\"/&gt; &lt;br&gt;&lt;br&gt; &lt;div class=\"one\" id=\"one\"&gt; id 为 one,class 为 one 的div &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\" id=\"two\" title=\"test\"&gt; id为two,class为one,title为test的div &lt;div class=\"mini\" title=\"other\"&gt;class为mini,title为other&lt;/div&gt; &lt;div class=\"mini\" title=\"test\"&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\" title=\"tesst\"&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=\"display:none;\" class=\"none\"&gt;style的display为\"none\"的div&lt;/div&gt; &lt;div class=\"hide\"&gt;class为\"hide\"的div&lt;/div&gt; &lt;div&gt; 包含input的type为\"hidden\"的div&lt;input type=\"hidden\" value=\"123456789\" size=\"8\"&gt; &lt;/div&gt; &lt;div id=\"mover\"&gt;正在执行动画的div元素.&lt;/div&gt;&lt;/body&gt; JS部分: 123456789101112131415161718192021222324252627$(function()&#123; $(\"#btn1\").click(function()&#123; $(\"div[title]\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn2\").click(function()&#123; $(\"div[title='test']\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn3\").click(function()&#123; //选取的元素中包含没有 title 的 div 元素. $(\"div[title!='test']\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn4\").click(function()&#123; $(\"div[title^='te']\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn5\").click(function()&#123; $(\"div[title$='est']\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn6\").click(function()&#123; $(\"div[title*='es']\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn7\").click(function()&#123; $(\"div[id][title*='es']\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn8\").click(function()&#123; $(\"div[title][title!='test']\").css(\"background\", \"#bfa\"); &#125;);&#125;)","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/tags/jQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"jQuery选择器","slug":"jQuery1-1","date":"2019-04-22T12:12:56.000Z","updated":"2019-10-06T09:40:04.000Z","comments":true,"path":"jQuery1-1.html","link":"","permalink":"https://blog.crainyday.com/jQuery1-1.html","excerpt":"jQuery选择器","text":"jQuery选择器 选择器是jQuery的根基, 在jQuery中, 对事件处理, 遍历DOM和Ajax操作都依赖于选择器 jQuery选择器的优点: 写法简洁 完善的事件处理机制 一.基本选择器 基本选择器是jQuery中最常用的选择器, 也是最简单的选择器, 它通过元素的id, class 和标签名来查找DOM元素(注意: 在一个网页中id只能用一次, class允许重复) 选择器 描述 返回 $(“#id”) 根据id匹配一个元素 单个元素 $(“.class”) 根据class匹配多个元素 集合元素 $(“element”) 根据元素名匹配元素 集合元素 $(“*”) 匹配所有元素 集合元素 $(“selector1,…,selectorn”) 将每一个选择器匹配到的元素合并一起返回 集合元素 上述选择器直接放在 $(“”) 的引号之间 1.基本选择器示例html部分: 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"选择 id 为 one 的元素\" id=\"btn1\" /&gt; &lt;input type=\"button\" value=\"选择 class 为 mini 的所有元素\" id=\"btn2\" /&gt; &lt;input type=\"button\" value=\"选择 元素名是 div 的所有元素\" id=\"btn3\" /&gt; &lt;input type=\"button\" value=\"选择 所有的元素\" id=\"btn4\" /&gt; &lt;input type=\"button\" value=\"选择 所有的 span 元素和id为two的元素\" id=\"btn5\" /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=\"one\" id=\"one\"&gt; id 为 one,class 为 one 的div &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\" id=\"two\" title=\"test\"&gt; id为two,class为one,title为test的div &lt;div class=\"mini\" title=\"other\"&gt;class为mini,title为other&lt;/div&gt; &lt;div class=\"mini\" title=\"test\"&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\" title=\"tesst\"&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=\"display:none;\" class=\"none\"&gt;style的display为\"none\"的div&lt;/div&gt; &lt;div class=\"hide\"&gt;class为\"hide\"的div&lt;/div&gt; &lt;div&gt; 包含input的type为\"hidden\"的div&lt;input type=\"hidden\" size=\"8\"&gt; &lt;/div&gt; &lt;span id=\"span\"&gt;^^span元素^^&lt;/span&gt;&lt;/body&gt; JS部分: 123456789101112131415161718//一定不要忘记引入jQuery库$(function()&#123; $(\"#btn1\").click(function()&#123; $(\"#one\").css(\"background-color\",\"#bfa\"); &#125;); $(\"#btn2\").click(function()&#123; $(\".mini\").css(\"background-color\",\"#bfa\"); &#125;); $(\"#btn3\").click(function()&#123; $(\"div\").css(\"background-color\",\"#bfa\"); &#125;); $(\"#btn4\").click(function()&#123; $(\"*\").css(\"background-color\",\"#bfa\"); &#125;); $(\"#btn5\").click(function()&#123; $(\"span,#two\").css(\"background-color\",\"#bfa\"); &#125;);&#125;); 二.层次选择器 若想通过DOM元素之间的层次关系来获取特定的元素, 例如: 后代元素 子元素 相邻元素 兄弟元素等, 则需要用层次选择器. 选择器 描述 返回 $(“ancestor descendant”) 选取ancestor的所有descendant(后代)元素 集合元素 $(“parent &gt; child”) 选取parent的所有child(子)元素 集合元素 $(“prev + next”) 选取紧接在prev元素后的下一个next元素 集合元素 $(“prev ~ siblings”) 选取prev元素后的所有siblings元素 集合元素 注意: $(“prev ~ siblings”)选择器只能选择#prev元素后的同辈元素; 而jQuery中的 siblings()方法与前后位置无关, 只要是同辈节点即可选取. > + - ~ 前后都有一个空格 1.层次选择器示例html部分: 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"选择 body 内的所有 div 元素\" id=\"btn1\" /&gt; &lt;input type=\"button\" value=\"在 body 内, 选择子元素是 div 的.\" id=\"btn2\" /&gt; &lt;input type=\"button\" value=\"选择 id 为 one 的下一个 div 元素\" id=\"btn3\" /&gt; &lt;input type=\"button\" value=\"选择 id 为 two 的元素后面的所有 div 兄弟元素\" id=\"btn4\" /&gt; &lt;input type=\"button\" value=\"选择 id 为 two 的元素所有 div 兄弟元素\" id=\"btn5\" /&gt; &lt;input type=\"button\" value=\"选择 id 为 one 的下一个 span 元素\" id=\"btn6\" /&gt; &lt;input type=\"button\" value=\"选择 id 为 two 的元素前边的所有的 div 兄弟元素\" id=\"btn7\" /&gt; &lt;br&gt;&lt;br&gt; &lt;div class=\"one\" id=\"one\"&gt; id 为 one,class 为 one 的div &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\" id=\"two\" title=\"test\"&gt; id为two,class为one,title为test的div &lt;div class=\"mini\" title=\"other\"&gt;class为mini,title为other&lt;/div&gt; &lt;div class=\"mini\" title=\"test\"&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\" title=\"tesst\"&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=\"display:none;\" class=\"none\"&gt;style的display为\"none\"的div&lt;/div&gt; &lt;div class=\"hide\"&gt;class为\"hide\"的div&lt;/div&gt; &lt;div&gt; 包含input的type为\"hidden\"的div&lt;input type=\"hidden\" size=\"8\"&gt; &lt;/div&gt; &lt;span id=\"span\"&gt;^^span元素^^&lt;/span&gt; &lt;span id=\"span\"&gt;--span元素--&lt;/span&gt;&lt;/body&gt; JS部分: 1234567891011121314151617181920212223242526$(function()&#123; $(\"#btn1\").click(function()&#123; $(\"body div\").css(\"background-color\",\"#bfa\"); &#125;); $(\"#btn2\").click(function()&#123; $(\"body &gt; div\").css(\"background-color\",\"#bfa\"); &#125;); $(\"#btn3\").click(function()&#123; $(\"#one + div\").css(\"background-color\",\"#bfa\"); &#125;); $(\"#btn4\").click(function()&#123; $(\"#two ~ div\").css(\"background-color\",\"#bfa\"); &#125;); $(\"#btn5\").click(function()&#123; $(\"#two\").siblings(\"div\").css(\"background-color\",\"#bfa\"); &#125;); $(\"#btn6\").click(function()&#123; //下面的选择器选择的是与 #one 相邻的 span 元素 //若 span 与 #one 不相邻,则选择器无效 //$(\"#one + span\").css(\"background-color\",\"#bfa\"); $(\"#one\").nextAll(\"span:first\").css(\"background-color\",\"#bfa\"); &#125;); $(\"#btn7\").click(function()&#123; $(\"#two\").prevAll(\"div\").css(\"background-color\",\"#bfa\"); &#125;);&#125;); 三.过滤选择器 通过特定的规则来筛选出所需的DOM元素, 该选择器都以 “:” 开头 按不同过滤规则, 过滤选择器可分为: 基本过滤、内容过滤、可见性过滤、属性过滤、子元素过滤和表单对象属性过滤选择器. 1.基本过滤选择器 选择器 描述 返回 :first 选取第一个元素 单个元素 :last 选取最后一个元素 集合元素 :not(selector) 去除所有与给定选择器匹配的元素 集合元素 :even 选取索引为偶数的所有元素, 索引从0开始 集合元素 :odd 选取索引为奇数的所有元素, 索引从0开始 集合元素 :eq(index) 选取索引等于index, 索引从0开始 集合元素 :gt(index) 选取索引大于index, 索引从0开始 集合元素 :lt(index) 选取索引小于index, 索引从0开始 集合元素 :header 选取所有的标题元素, 如: h1,h2等 集合元素 :animated 选取当前正在执行动画的所有元素 集合元素 示例: html部分: 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; div, span, p &#123; width: 140px; height: 140px; margin: 5px; background: #aaa; border: #000 1px solid; float: left; font-size: 17px; font-family: Verdana; &#125; div.mini &#123; width: 55px; height: 55px; background-color: #aaa; font-size: 12px; &#125; div.hide &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"选择第一个 div 元素\" id=\"btn1\" /&gt; &lt;input type=\"button\" value=\"选择最后一个 div 元素\" id=\"btn2\" /&gt; &lt;input type=\"button\" value=\"选择class不为 one 的所有 div 元素\" id=\"btn3\" /&gt; &lt;input type=\"button\" value=\"选择索引值为偶数的 div 元素\" id=\"btn4\" /&gt; &lt;input type=\"button\" value=\"选择索引值为奇数的 div 元素\" id=\"btn5\" /&gt; &lt;input type=\"button\" value=\"选择索引值为大于 3 的 div 元素\" id=\"btn6\" /&gt; &lt;input type=\"button\" value=\"选择索引值为等于 3 的 div 元素\" id=\"btn7\" /&gt; &lt;input type=\"button\" value=\"选择索引值为小于 3 的 div 元素\" id=\"btn8\" /&gt; &lt;input type=\"button\" value=\"选择所有的标题元素\" id=\"btn9\" /&gt; &lt;input type=\"button\" value=\"选择当前正在执行动画的所有元素\" id=\"btn10\" /&gt; &lt;input type=\"button\" value=\"选择 id 为 two 的下一个 span 元素\" id=\"btn11\" /&gt; &lt;h3&gt;基本选择器.&lt;/h3&gt; &lt;br&gt;&lt;br&gt; &lt;div class=\"one\" id=\"one\"&gt; id 为 one,class 为 one 的div &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\" id=\"two\" title=\"test\"&gt; id为two,class为one,title为test的div &lt;div class=\"mini\" title=\"other\"&gt;class为mini,title为other&lt;/div&gt; &lt;div class=\"mini\" title=\"test\"&gt;class为mini,title为test&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"one\"&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\"&gt;class为mini&lt;/div&gt; &lt;div class=\"mini\" title=\"tesst\"&gt;class为mini,title为tesst&lt;/div&gt; &lt;/div&gt; &lt;div style=\"display:none;\" class=\"none\"&gt;style的display为\"none\"的div&lt;/div&gt; &lt;div class=\"hide\"&gt;class为\"hide\"的div&lt;/div&gt; &lt;div&gt; 包含input的type为\"hidden\"的div&lt;input type=\"hidden\" size=\"8\"&gt; &lt;/div&gt; &lt;span id=\"span\"&gt;^^span元素 111^^&lt;/span&gt; &lt;span id=\"span\"&gt;^^span元素 222^^&lt;/span&gt; &lt;div id=\"mover\"&gt;正在执行动画的div元素.&lt;/div&gt;&lt;/body&gt; JS部分: 12345678910111213141516171819202122232425262728293031323334353637383940$(document).ready(function()&#123; //之后会说jQuery的动画 function anmateIt()&#123; $(\"#mover\").slideToggle(\"slow\", anmateIt); &#125; anmateIt(); $(\"#btn1\").click(function()&#123; $(\"div:first\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn2\").click(function()&#123; $(\"div:last\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn3\").click(function()&#123; $(\"div:not(.one)\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn4\").click(function()&#123; $(\"div:even\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn5\").click(function()&#123; $(\"div:odd\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn6\").click(function()&#123; $(\"div:gt(3)\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn7\").click(function()&#123; $(\"div:eq(3)\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn8\").click(function()&#123; $(\"div:lt(3)\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn9\").click(function()&#123; $(\":header\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn10\").click(function()&#123; $(\":animated\").css(\"background\", \"#bfa\"); &#125;); $(\"#btn11\").click(function()&#123; $(\"#two\").nextAll(\"span:first\").css(\"background\", \"#bfa\"); &#125;);&#125;);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/tags/jQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"jQuery简介","slug":"jQuery1-0","date":"2019-04-22T05:14:12.000Z","updated":"2019-10-06T09:39:56.000Z","comments":true,"path":"jQuery1-0.html","link":"","permalink":"https://blog.crainyday.com/jQuery1-0.html","excerpt":"jQuery——write less, do more","text":"jQuery——write less, do more 一.jQuery简介 为了简化JS开发, 出现了一些JS库. 这些库封装了很多预定义的对象和实用函数. 能帮助使用者建立有高难度交互的Web 2.0特性的富客户端页面, 并兼容大部分浏览器. 常见的JS库: prototype、dojo、Ext JS、mootools、jQuery jQuery是继prototype之后又一个优秀的JS库 jQuery理念: 写的少, 做的多. 优点: 轻量级 强大的选择器 出色的DOM操作封装 可靠的事件处理机制 完善的Ajax 出色的浏览器兼容性 链式操作方式…… 二.jQuery的Hello World 应用jQuery, 第一步就是引入jQuery库 jQuery的 $(function(){}) 就相当于 JS 的window.onload jQuery的神奇之处: 有非常多的、非常有用的选择器 12345678910111213141516171819&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;!--1.必须引入jQuery库--&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; //1.选取btn按钮 //2.为id为btn添加onclick响应函数 $(\"#btn\").click(function()&#123; //3.弹出Hello World! alert(\"Hello World!\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;按钮&lt;/button&gt;&lt;/body&gt; 三.jQuery对象 jQuery对象就是通过jQuery的 $() 包装的DOM对象后产生的对象 jQuery对象是jQuery特有的. jQuery对象可以使用jQuery里的方法, 例: $(“#box”).html() jQuery对象无法使用DOM对象的任何方法, 同样DOM对象无法使用jQuery对象里的任何方法 约定: 若获取的对象为jQuery对象, 在变量面前加上$表示.例: var $variable = jQuery对象;var variable = DOM对象; 1.jQuery对象—&gt;DOM对象 jQuery对象不能用DOM中的方法, 但若jQuery没有封装想要的方法, 不得不用DOM中的方法时, 要将jQUery对象转化为DOM对象. ①jQuery对象是一个数组对象, 可以通过[index]的方法的到对应的DOM对象.var $cr = $(“#cr”);var cr = $cr[0]; ②使用jQuery中的get(index)方法得到相应的DOM对象var $cr = $(“#cr”);var cr = $cr.get(0); 2.DOM对象—&gt;jQuery对象 对于一个DOM对象, 只需要用 $() 把DOM对象包装起来, 就可以得到一个jQuery对象, 之后就可以用jQuery对象的方法. var cr = document.getElementById(“cr”);var $cr = $(cr); 四.jQuery对象的几个常用方法 方法 描述 val([value]) 获取或设置表单元素的value属性值 attr(name[,val]) 获取或设置元素节点的指定属性值 each() 对jQuery对象进行遍历,其参数为function,函数内部this代表当前DOM对象 text([str]) 获取或设置元素节点的文本节点的值 html([str]) 获取或设置元素的内部html代码 height() 设置元素CSS的高度 width() 设置元素CSS的宽度 css(attr,val) 设置元素指定属性(attr)的值为val removeAttr() 删除指定元素的指定属性","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/tags/jQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"Ajax-jQuery","slug":"Ajax1-2","date":"2019-04-21T08:08:52.000Z","updated":"2019-10-06T09:39:48.000Z","comments":true,"path":"Ajax1-2.html","link":"","permalink":"https://blog.crainyday.com/Ajax1-2.html","excerpt":"利用jQuery实现Ajax","text":"利用jQuery实现Ajax 1.注意不了解 jQuery 的可以先了解一下，本站上也有一些 jQuery 的学习笔记 jQuery中的Ajax, 最底层$.ajax() 第二层$.load() $.get() $.post(), 第三层$.getScript() $.getJSON() 最常用的方法是$.load() $.get() $.post() 一.$.load() load()方法是jQuery中最为简单和常见的Ajax方法, 能载入远程的HTML代码并插入到DOM中.我们只需用jQuery选择器为HTML片段指定目标位置即可.默认使用 GET 方式 - 传递附加参数时自动转换为 POST 方式 如果我们只需要返回的全部HTML代码的一部分, 可以将url参数设置为”url selector”(注意url与选择器间有一个空格) 任何一个HTML的节点都可以使用load()方法来加载Ajax, 结果将直接插入到该节点中的innerHTML中 参数 说明 url 待装入 HTML 网页网址 data(可选,对象) 发送至服务器的 key/value 数据. 在jQuery 1.3中也可以接受一个字符串了. callback(可选) 载入成功时回调函数 12345678910111213141516171819202122232425262728293031323334353637383940&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;exer&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; $(\"a\").click(function()&#123; var url = this.href; //var url = this.href + \" a\";//只选择返回的html代码中的a //var args = &#123;\"time\":new Date()&#125;;//args为JSON格式 //若向本地服务器发送POST请求时,本地服务器需要具备处理POST请求的能力 $(\".detail\").load(url);//get请求 //$(\".detail\").load(url,args);//post请求 return false; &#125;); &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; .brief &#123; width: 200px; margin: 0 auto; &#125; .brief a&#123; font-size: 20px; &#125; .detail &#123; width: 200px; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"brief\"&gt; &lt;a href=\"sun.html\"&gt;孙悟空&lt;/a&gt; &lt;a href=\"zhu.html\"&gt;猪八戒&lt;/a&gt; &lt;a href=\"sha.html\"&gt;沙和尚&lt;/a&gt; &lt;/div&gt; &lt;div class=\"detail\"&gt; &lt;/div&gt;&lt;/body&gt; 二.$.get()和$.post() $.get()方法使用GET方式来进行异步请求. 结构: $.get(url[,data][,callback][,type]) $.get()方法中的回调函数只有两个参数: data表示返回的数据, 可以是XML、JSON、HTML等; textstatus表示请求状态, 其值可能是: success, error, notmodify, timeout 4种 请求成功时可调用回调函数, 如果需要在出错时执行函数, 请使用 $.ajax() $.get()和$.post()方法是jQuery中的全局函数, 而find()等方法都是对jQuery对象进行操作的方法. 参数 描述 url 待载入页面的URL地址 data 待发送 Key/value 参数 callback 载入成功时回调函数 type 返回内容格式:xml, html, script, json, text, _default 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src=\"js/jquery-3.4.0.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"a\").click(function()&#123; var url = this.href; var args = &#123;\"time\":new Date()&#125;; $.get(url,args,function(data)&#123; //现在的$.get()方法会根据url识别data格式,此处为xml //用$(data)包装data,变为jQuery对象 //若data为json格式,这样用:var name = data.person.name; var name = $(data).find(\"name\").text(); var website = $(data).find(\"website\").text(); var address = $(data).find(\"address\").text(); $(\".detail\").empty() .append(\"&lt;p&gt;姓名:\"+name+\"&lt;/p&gt;\") .append(\"&lt;p&gt;网址:&lt;a href=\"+ website +\" target='_blank'&gt;简介&lt;/a&gt;&lt;/p&gt;\") .append(\"&lt;p&gt;住址:\"+address+\"&lt;/p&gt;\"); &#125;);//为了明确,建议在第四个参数处指明返回数据的格式,例:\"json\" return false; &#125;); &#125;); &lt;/script&gt; &lt;style type=\"text/css\"&gt; .brief &#123; width: 200px; margin: 0 auto; &#125; .brief a&#123; font-size: 20px; &#125; .detail &#123; width: 200px; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"brief\"&gt; &lt;a href=\"sun.xml\"&gt;孙悟空&lt;/a&gt; &lt;a href=\"zhu.xml\"&gt;猪八戒&lt;/a&gt; &lt;a href=\"sha.xml\"&gt;沙和尚&lt;/a&gt; &lt;/div&gt; &lt;div class=\"detail\"&gt; &lt;/div&gt;&lt;/body&gt; $.post()方法和$.get()方法类似, 但是若向本地服务器发送POST请求, 本地服务器需要具备处理POST请求的能力","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://blog.crainyday.com/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://blog.crainyday.com/tags/Ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/tags/jQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"Ajax数据格式","slug":"Ajax1-1","date":"2019-04-21T04:52:01.000Z","updated":"2019-10-06T09:39:40.000Z","comments":true,"path":"Ajax1-1.html","link":"","permalink":"https://blog.crainyday.com/Ajax1-1.html","excerpt":"Ajax——常用的数据格式 XML JSON HTML","text":"Ajax——常用的数据格式 XML JSON HTML 三种数据格式: XML、JSON、HTML 一.HTML格式 HTML由一些普通文本组成.若服务器通过XMLHttpRequest发送HTML, 文本将存储在responseText属性中. 可以直接将responseText赋值给节点的innerHTML属性. 优点: 从服务器发送的HTML代码在浏览器端不需要用JS再解析 HTML的可读性好 HTML代码块与innerHTML属性搭配, 效率高 缺点: 若需通过Ajax更新一篇文档的多个部分, HTML不合适 innerHTML并非DOM标准 同目录下四个html文件: index.html、sun.html、zhu.html、sha.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--index.html--&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var briefA = document.getElementsByTagName(\"a\"); for(var i = 0; i &lt; briefA.length; i++) &#123; briefA[i].onclick = function() &#123; var request = new XMLHttpRequest(); request.open(\"GET\", this.href, true); request.send(null); request.onreadystatechange = function() &#123; if(request.readyState == 4) &#123; if(request.status == 200) &#123; document.getElementsByClassName(\"detail\")[0].innerHTML = request.responseText; &#125; &#125; &#125;; return false; &#125;; &#125; &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; .brief &#123; width: 200px; margin: 0 auto; &#125; .brief a&#123; font-size: 20px; &#125; .detail &#123; width: 200px; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"brief\"&gt; &lt;a href=\"sun.html\"&gt;孙悟空&lt;/a&gt; &lt;a href=\"zhu.html\"&gt;猪八戒&lt;/a&gt; &lt;a href=\"sha.html\"&gt;沙和尚&lt;/a&gt; &lt;/div&gt; &lt;div class=\"detail\"&gt; &lt;/div&gt;&lt;/body&gt; 1234&lt;!--sun.html--&gt;&lt;p&gt;姓名:孙悟空&lt;/p&gt;&lt;p&gt;网址:&lt;a href=\"https://baike.baidu.com/item/%E5%AD%99%E6%82%9F%E7%A9%BA/5576?fr=aladdin\" target=\"_blank\"&gt;简介&lt;/a&gt;&lt;/p&gt;&lt;p&gt;住址:花果山&lt;/p&gt; 1234&lt;!--zhu.html--&gt;&lt;p&gt;姓名:猪八戒&lt;/p&gt;&lt;p&gt;网址:&lt;a href=\"https://baike.baidu.com/item/%E7%8C%AA%E5%85%AB%E6%88%92/769?fr=aladdin\" target=\"_blank\"&gt;简介&lt;/a&gt;&lt;/p&gt;&lt;p&gt;住址:高老庄&lt;/p&gt; 1234&lt;!--sha.html--&gt;&lt;p&gt;姓名:沙和尚&lt;/p&gt;&lt;p&gt;网址:&lt;a href=\"https://baike.baidu.com/item/%E6%B2%99%E6%82%9F%E5%87%80/29248?fromtitle=%E6%B2%99%E5%92%8C%E5%B0%9A&amp;fromid=6472043&amp;fr=aladdin\" target=\"_blank\"&gt;简介&lt;/a&gt;&lt;/p&gt;&lt;p&gt;住址:流沙河&lt;/p&gt; 二.XML XML就是为了传输数据而生的优点: XML是一种通用的数据格式 XML可以为数据自定义标记 利用DOM就可以完全掌控文档 缺点: 若XML文档来自服务器, 就必须得保证文档文档含有正确的部首信息. 若文档类型不正确, 那么responseXML的值将为空 当浏览器接收到的XML很大时, DOM解析可能会很复杂 同目录下四个文件: index.html、sun.xml、zhu.xml、sha.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var briefA = document.getElementsByTagName(\"a\"); var detail = document.getElementsByClassName(\"detail\")[0]; for(var i = 0; i &lt; briefA.length; i++) &#123; briefA[i].onclick = function() &#123; var request = new XMLHttpRequest(); request.open(\"GET\", this.href, true); request.send(null); request.onreadystatechange = function() &#123; if(request.readyState == 4&amp;&amp;request.status == 200) &#123; //1.接受XML格式数据 var result = request.responseXML; //2.解析XML数据 /* 目标格式 * &lt;p&gt;姓名:&lt;/p&gt; * &lt;p&gt;网址:&lt;a href=\"\"&gt;简介&lt;/a&gt;&lt;/p&gt; * &lt;p&gt;住址:&lt;/p&gt; */ detail.innerHTML = \"\"; var name = result.getElementsByTagName(\"name\")[0].firstChild.nodeValue; var web = result.getElementsByTagName(\"website\")[0].firstChild.nodeValue; var address = result.getElementsByTagName(\"address\")[0].firstChild.nodeValue; var p1 = document.createElement(\"p\"); p1.innerHTML = \"姓名:\"+name; var p2 = document.createElement(\"p\"); p2.innerHTML = \"网址:\"; var p3 = document.createElement(\"p\"); p3.innerHTML = \"住址:\" + address; var a = document.createElement(\"a\"); a.href = web; a.target = \"_blank\"; a.innerHTML = \"简介\"; p2.appendChild(a); detail.appendChild(p1); detail.appendChild(p2); detail.appendChild(p3); &#125; &#125;; return false; &#125;; &#125; &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; .brief &#123;width: 200px;margin: 0 auto;&#125; .brief a&#123;font-size: 20px;&#125; .detail &#123;width: 200px;margin: 0 auto;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"brief\"&gt; &lt;a href=\"sun.xml\"&gt;孙悟空&lt;/a&gt; &lt;a href=\"zhu.xml\"&gt;猪八戒&lt;/a&gt; &lt;a href=\"sha.xml\"&gt;沙和尚&lt;/a&gt; &lt;/div&gt; &lt;div class=\"detail\"&gt; &lt;/div&gt;&lt;/body&gt; 12345678&lt;!--sun.xml--&gt;&lt;!--一定不要忘记XML的部首信息--&gt;&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;detail&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;website&gt;https://baike.baidu.com/item/%E5%AD%99%E6%82%9F%E7%A9%BA/5576?fr=aladdin&lt;/website&gt; &lt;address&gt;花果山&lt;/address&gt;&lt;/detail&gt; 1234567&lt;!--zhu.xml--&gt;&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;detail&gt; &lt;name&gt;猪八戒&lt;/name&gt; &lt;website&gt;https://baike.baidu.com/item/%E7%8C%AA%E5%85%AB%E6%88%92/769?fr=aladdin&lt;/website&gt; &lt;address&gt;高老庄&lt;/address&gt;&lt;/detail&gt; 1234567&lt;!--sha.xml--&gt;&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;detail&gt; &lt;name&gt;沙和尚&lt;/name&gt; &lt;website&gt;https://baike.baidu.com/item/%E6%B2%99%E6%82%9F%E5%87%80/29248?fr=aladdin&lt;/website&gt; &lt;address&gt;流沙河&lt;/address&gt;&lt;/detail&gt; 三.JSON 优点: 也是一种数据传输的格式, JSON与XML很相似, 但是JSON更轻巧 JSON不需要从服务端发送含有特定内容类型的首部信息. 缺点: 语法严谨 代码不太易读 用eval函数解析JSON字符串存在风险 同目录下四个文件: index.html、sun.json、zhu.json、sha.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var briefA = document.getElementsByTagName(\"a\"); var detail = document.getElementsByClassName(\"detail\")[0]; for(var i = 0; i &lt; briefA.length; i++) &#123; briefA[i].onclick = function() &#123; var request = new XMLHttpRequest(); request.open(\"GET\", this.href, true); request.send(null); request.onreadystatechange = function() &#123; if(request.readyState == 4&amp;&amp;request.status == 200) &#123; //1.接受json格式数据 var result = request.responseText; var obj = JSON.parse(result); detail.innerHTML = \"\"; var p1 = document.createElement(\"p\"); p1.innerHTML = \"姓名:\"+obj.person.name; var p2 = document.createElement(\"p\"); p2.innerHTML = \"网址:\"; var p3 = document.createElement(\"p\"); p3.innerHTML = \"住址:\" + obj.person.address; var a = document.createElement(\"a\"); a.href = obj.person.website; a.target = \"_blank\"; a.innerHTML = \"简介\"; p2.appendChild(a); detail.appendChild(p1); detail.appendChild(p2); detail.appendChild(p3); &#125; &#125;; return false; &#125;; &#125; &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; .brief &#123; width: 200px; margin: 0 auto; &#125; .brief a&#123; font-size: 20px; &#125; .detail &#123; width: 200px; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"brief\"&gt; &lt;a href=\"sun.json\"&gt;孙悟空&lt;/a&gt; &lt;a href=\"zhu.json\"&gt;猪八戒&lt;/a&gt; &lt;a href=\"sha.json\"&gt;沙和尚&lt;/a&gt; &lt;/div&gt; &lt;div class=\"detail\"&gt; &lt;/div&gt;&lt;/body&gt; 123456&#123;\"person\":&#123; \"name\":\"孙悟空\", \"website\":\"https://baike.baidu.com/item/%E5%AD%99%E6%82%9F%E7%A9%BA/5576?fr=aladdin\", \"address\":\"花果山\" &#125;&#125; 123456&#123;\"person\":&#123; \"name\":\"猪八戒\", \"website\":\"https://baike.baidu.com/item/%E7%8C%AA%E5%85%AB%E6%88%92/769?fr=aladdin\", \"address\":\"高老庄\" &#125;&#125; 123456&#123;\"person\":&#123; \"name\":\"沙和尚\", \"website\":\"https://baike.baidu.com/item/%E6%B2%99%E6%82%9F%E5%87%80/29248?fr=aladdin\", \"address\":\"流沙河\" &#125;&#125;","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://blog.crainyday.com/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://blog.crainyday.com/tags/Ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/tags/jQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"Ajax简介","slug":"Ajax1-0","date":"2019-04-20T15:12:15.000Z","updated":"2019-10-06T09:39:31.000Z","comments":true,"path":"Ajax1-0.html","link":"","permalink":"https://blog.crainyday.com/Ajax1-0.html","excerpt":"关于 AJAX 你知道什么? 什么是 AJAX? AJAX是干什么的?","text":"关于 AJAX 你知道什么? 什么是 AJAX? AJAX是干什么的? 一.什么是AJAX ①AJAX, 即Asynchronous JavaScript and XML(异步的 JavaScript 和 XML). ②AJAX 不是新的编程语言, 而是一种使用现有标准的新方法或技术. ③AJAX 是与服务器交换数据并更新部分网页的技术, 在不重新加载整个页面的情况下. 现在, 凡是允许浏览器与服务器通信而无须刷新当前页面的技术都被称作 Ajax.Ajax最早是由Google使用的. 1.如何实现Ajax Flash Java applet 框架: 如果使用一组框架构造了一个网页, 可以只更新其中一个框架, 而不必惊动整个页面 隐藏的iframe XMLHttpRequest: 该对象是对JS的一个扩展, 可以使网页与服务器进行通信. 这是创建Ajax应用的最佳选择 实际上, 通常把Ajax当成XMLHttpRequest 2.Ajax原理 3.Ajax工具包 Ajax并不是一项新技术, 它实际上是几种技术, 每种技术各尽其职, 以一种全新的方式聚合在一起. 服务端语言: 服务器需具备向浏览器发送特定信息的能力. Ajax与服务器端语言无关 XML(eXtensible Markup Language, 可扩展标记语言)是一种描述数据的格式. Ajax程序需要某种格式化的格式来在服务器和客户端之间传递消息, XML是其中一种选择. XHTML(eXtensible HyperText Markup Language,可扩展超文本标记语言)(现在是HTML5.0)和CSS(Cascading Style Sheets,层叠样式表)标准化呈现在前端 DOM(Document Object Model,文档对象模型)实现动态的显示和交互 使用XMLHttpRequest对象进行异步数据读取 使用JS绑定和处理数据 4.Ajax的缺陷 由JS和Ajax引擎导致的浏览器的兼容问题 页面局部刷新, 导致后退等功能失效 对流媒体的支持没有Flash、Java applet好 一些手持设备(如手机等)支持性差 二.XMLHttpRequest XMLHttpRequest最早在IE5中以ActiveX组建形式出现, 非W3C标准 创建XMLHttpRequest对象的方法不一样: IE5将其实现为一个ActiveX对象, 其他浏览器实现为一个本地JS对象 虽然在不同浏览器上的实现方法是兼容的, 但是XMLHttpRequest实例的属性和方法是相同的. 1.创建方式123456789function getHTTPObject()&#123; var xhr = false; if(window.XMLHttpRequset)&#123; xhr = new XMLHttpRequest(); &#125;else if(window.ActiveXObject)&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; return xhr;&#125; 2.XMLHttpRequest的方法和属性 方法 描述 open(“method”,”url”) 建立对服务器的调用.Method参数可以是GET、POST或PUT.URL参数可以是相对URL或绝对URL send(content) 向服务器发送请求 setRequestHeader(“header”,”value”) 把指定首部设置为所提供的值, 在设置任何首部之前必须调用open() abort() 停止当前请求 getResponseHeader(‘’header’’) 返回指定首部的值 getAllResponseHeaders() 把http请求的所有响应首部作为键/值返回 属性 描述 onreadystatechange 每个状态的改变都会触发这个事件的处理器, 通常会调用一个JS函数 readyState 请求状态, 有五个: 0-&gt;未初始化, 1-&gt;正在加载, 2-&gt;已经加载, 3-&gt;交互中, 4-&gt;完成. responseText 服务器的响应, 表示一个串 responseXML 服务器的响应, 表示为XML, 这个对象可解析为DOM对象 status 服务器的http状态码(200-&gt;OK, 404-&gt;NotFound, 等) statusText http状态码的相应文本(OK或NotFound, 等) 3.简单的发送请求 利用XMLHttpRequest实例与服务器通信包含以下3个关键部分: onreadystatechange事件处理函数 open方法 send方法 123456789101112131415161718192021222324252627282930313233343536&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; //1.获取a节点并为其添加一个onclick响应函数 document.getElementsByTagName(\"a\")[0].onclick = function()&#123; //3.创建一个 XMLHttpRequest 对象 var request = new XMLHttpRequest(); //4.准备发送请求的数据: url var url = this.href; var method = \"GET\"; //5.调用 XMLHttpRequest 对象的open方法,准备请求 request.open(method,url); //6.调用 XMLHttpRequest 对象的send方法,发送请求 request.send(null); //7.为 XMLHttpRequest 对象添加 onreadystatechange响应函数 request.onreadystatechange = function()&#123; //8.判断响应是否完成: XMLHttpRequest 对象的readyState属性值为4时 if(request.readyState==4)&#123; //9.再判断响应是否可用: XMLHttpRequest 对象status属性值为200 if(request.status==200||request.status==304)&#123; //10.打印相应结果: responseText alert(request.responseText); &#125; &#125; &#125;; //2.取消a节点的默认行为 return false; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--在html文件的同级目录下的ajax.txt文件,内容:Hello Ajax!--&gt; &lt;a href=\"ajax.txt\"&gt;发送&lt;/a&gt;&lt;/body&gt; 注意: readyState 的值为4时响应成功, 但并不代表响应可用, 当status值(200，即OK)表示响应可用时才可使用 onreadystatechange: 该事件处理函数由服务器触发, 而不是用户触发 在Ajax执行过程中, 服务器会通知客户端当前的通信状态. 这依靠更新 XMLHttpRequest 对象的readyState属性来实现. 改变readyState属性是服务器对客户端连续操作的一种方式. 每次readyState属性值的改变都会触发onreadystatechange事件 open(method,url,asynch): 该方法允许我们用一个Ajax调用向服务器发送请求(其实是建立一个请求). method: 请求类型, 类似”GET”或”POST”的字符串. 若只想从服务器获取信息, 而不需发送信息, 使用GET(GET请求也可通过URL附加的查询字符串来发送数据, 但有长度限制). 若需向服务器发送数据, 用POST请求. 某些情况下, 有些浏览器会把多个XMLHttpRequest请求的结果缓存在同一个URL下. 如果对每个请求的响应不同, 就会带来不好的效果. 此时, 我们会在请求的URL后附加时间戳, 来确保URL的唯一性, 起到禁用缓存的效果. asynch: 表示请求是否异步, 一般取默认值true send(data):GET请求时, data = null; POST请求时, data为相应数据. 4.POST请求只需要在GET的基础上将method改为”POST”,并在open()和send()方法之间添加下面语句: 1setRequestHeader(\"ContentType\",\"application/x-www-form-urlencoded\"); 注意: 在开发过程中, 我们一般不用原生的方式来向服务器发送请求.一般用框架来实现, 例如: jQuery、axios等","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://blog.crainyday.com/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://blog.crainyday.com/tags/Ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"https://blog.crainyday.com/tags/jQuery/"},{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JS-JSON","slug":"JS-JSON","date":"2019-04-20T10:46:34.000Z","updated":"2019-10-06T09:43:49.000Z","comments":true,"path":"JS-JSON.html","link":"","permalink":"https://blog.crainyday.com/JS-JSON.html","excerpt":"JSON — JavaScript Object Notation","text":"JSON — JavaScript Object Notation 一.JSON简介 JSON 指的是 JavaScript 对象表示法(JavaScript Object Notation) JSON 是一个特殊的字符串, 它能被任意编程语言识别, 并可转换为任意语言中的对象 JSON 是轻量级的文本数据交换格式 JSON 使用 JavaScript 语法来描述数据对象, 但是 JSON 仍然独立于语言和平台. JSON 解析器和JSON 库支持许多不同的编程语言. 1.JSON与XMLJSON类似 XML(也是用来进行数据交换的) JSON 是纯文本 JSON 具有“自我描述性”(人类可读) JSON 具有层级结构(值中存在值) JSON 可通过 JavaScript 进行解析 JSON 数据可使用 AJAX 进行传输 相比 XML 的不同之处 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字 现在都用JS的JSON工具类来解析JSON 二.JSON语法 JSON 语法是 JavaScript 对象表示法语法的子集 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 1.JSON名值对JSON 数据的书写格式是: 名称/值对. 名称/值对包括字段名称(必须在双引号中), 后面写一个冒号, 然后是值: 123\"firstName\" : \"John\";//上面就等价于JS语句firstName = \"John\"; 2.JSON的值 数字(整数或浮点数) 字符串(在双引号中) 逻辑值(true 或 false) 数组(在方括号中) 对象(在花括号中) null 3.JSON对象 JSON 对象在花括号中书写:对象可以包含多个名称/值对: 1'&#123;\"name\":\"孙悟空\",\"age\":500,\"sex\":\"男\",\"status\":true&#125;' 4.JSON数组 JSON 数组在方括号中书写: 1'[1,2,3,4,5]' JSON对象与数组可以嵌套 5.JSON文件 JSON 文件的文件类型是 “.json” JSON 文本的 MIME 类型是 “application/json” 三.JSON与JS对象转换1.JSON—&gt;JS对象 JSON.parse()方法:将指定JSON字符串转换为JS对象并返回 eval()函数:这个函数可以用来执行一段字符串形式的JS代码, 并将执行结果返回 12345678910//法1:var jstr = '&#123;\"name\":\"孙悟空\",\"age\":500,\"sex\":\"男\",\"status\":true&#125;';var obj = JSON.parse(jstr);console.log(typeof obj);//objectconsole.log(obj.name);//孙悟空//IE7及以下浏览器不支持JSON类,可以用法2//法2:var obj2 = eval(\"(\"+jstr+\")\");console.log(typeof obj2);//objectconsole.log(obj2.name);//孙悟空 2.JS对象—&gt;JSON JSON.stringify()方法:将指定JS对象转换为JSON字符串并返回 1234var obj = &#123;name:\"孙悟空\",age:500,sex:\"男\",status:true&#125;;var jstr = JSON.stringify(obj);console.log(typeof jstr);//stringconsole.log(jstr);//'&#123;\"name\":\"孙悟空\",\"age\":500,\"sex\":\"男\",\"status\":true&#125;' 若想兼容IE7及以下浏览器, 可以引入外部JS(文件里实现了JSON工具类)","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JSclassName","slug":"JSclassName","date":"2019-04-19T11:17:46.000Z","updated":"2019-10-06T09:42:41.000Z","comments":true,"path":"JSclassName.html","link":"","permalink":"https://blog.crainyday.com/JSclassName.html","excerpt":"JS基础—类的相关操作","text":"JS基础—类的相关操作 一.JS直接修改style属性 通过style属性来修改元素的样式, 每修改一个样式, 浏览器需要重新渲染一次页面 这样的话, 执行性能是比较差的, 而且当我们要修改很多样式时, 用这种方式也很不方便 过多的使用这种方法, 网页的行为与表现也很大程度上耦合了 而我们希望, 一行JS代码就可以同时修改多个样式. 这时我们可以准备两套(或多套)CSS样式, 当需要修改时, 直接用JS替换为另一套就可以了 12345678910111213141516171819202122232425&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var btn01 = document.getElementById(\"btn01\"); var box = document.getElementById(\"box\"); btn01.onclick = function()&#123; box.style.width = 200 + \"px\"; box.style.height = 200 + \"px\"; box.style.backgroundColor = \"yellowgreen\"; &#125;; &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; .b1&#123; width: 100px; height: 100px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn01\"&gt;修改样式&lt;/button&gt; &lt;div id=\"box\" class=\"b1\"&gt;&lt;/div&gt;&lt;/body&gt; 二.修改class属性 我们可以通过修改元素的class属性来间接修改样式, 这样一来, 我们只需一行代码, 就可同时修改多个样式, 浏览器也只需重新渲染一次, 性能提升, 这种方式也可使表现和行为进一步分离. 在开发的过程中, 能通过class属性修改样式, 尽量这样使用. 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var btn01 = document.getElementById(\"btn01\"); var box = document.getElementById(\"box\"); btn01.onclick = function()&#123; box.className = \"b2\"; &#125;; &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; .b1&#123; width: 100px; height: 300px; background-color: red; &#125; .b2&#123; width: 200px; height: 200px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn01\"&gt;修改样式&lt;/button&gt; &lt;div id=\"box\" class=\"b1\"&gt;&lt;/div&gt;&lt;/body&gt; 三.操作元素的class属性1234567891011121314151617181920212223242526//为元素的class属性添加一个值function addClass(obj,cname)&#123; if(!hasClass(obj,cname))&#123; obj.className += \" \"+cname; &#125;&#125;//判断元素class属性是否有某个值function hasClass(obj,cname)&#123; //利用正则表达式检测 var reg = new RegExp(\"\\\\b\"+cname+\"\\\\b\"); return reg.test(obj.className);&#125;//删除元素class属性中的某个值function removeClass(obj,cname)&#123; //利用正则表达式替换为空串 var reg = new RegExp(\"\\\\b\"+cname+\"\\\\b\"); obj.className = obj.className.replace(reg,\"\");&#125;//替换元素class属性中的某个值(有则删除,无则添加)function toggleClass(obj,cname)&#123; if(hasClass(obj,cname))&#123; removeClass(obj,cname); &#125;else&#123; addClass(obj,cname); &#125;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JSBOM定时器","slug":"JSBOM1-1","date":"2019-04-18T07:28:15.000Z","updated":"2019-10-06T09:42:33.000Z","comments":true,"path":"JSBOM1-1.html","link":"","permalink":"https://blog.crainyday.com/JSBOM1-1.html","excerpt":"window对象的定时器","text":"window对象的定时器 一.setInterval()如果我们希望一段程序可以每隔一段时间执行一次, 这就用到了我们的定时器. setInterval()—— 可以将一个函数每隔一段时间执行一次.—— 参数:1. 回调函数, 该函数每隔一段时间会被调用一次—— 2. 调用回调函数的时间间隔—— 返回值: 一个Number型的数字, 这个数字作为定时器的唯一标识—— 注意, 第一次调用回调函数会等一个参数时间间隔 clearInterval(timer) 可以关闭一个timer标识的setInterval()定时器 1.定时调用示例123456789101112131415161718&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var text = document.getElementById(\"text\"); var num = 1; var timer = setInterval(function()&#123; text.innerHTML = num++; if(num==11)&#123; clearInterval(timer); &#125; &#125;,500); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span id=\"text\"&gt;&lt;/span&gt;&lt;/body&gt; 2.移动div123456789101112131415161718192021222324252627282930&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var box = document.getElementById(\"box\"); var div = 0; var speed = 10; var timer = setInterval(function() &#123; switch (div) &#123; case 37:box.style.left = box.offsetLeft - speed + \"px\";break; case 38:box.style.top = box.offsetTop - speed + \"px\";break; case 39:box.style.left = box.offsetLeft + speed + \"px\";break; case 40:box.style.top = box.offsetTop + speed + \"px\";break; &#125; &#125;, 30); document.onkeydown = function(event) &#123; event = event || window.event; if (event.altKey)speed = 100; else speed = 10; div = event.keyCode; document.onkeyup = function() &#123; div = 0; &#125;; &#125;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\" style=\"width:100px;height:100px;background-color:red;position:absolute;\"&gt;&lt;/div&gt;&lt;/body&gt; 二.延时调用 延时调用: 延时调用一个函数, 不会马上执行, 而是隔一段时间之后在执行, 且只会执行一次 延时调用与定时调用的区别, 定时调用会多次调用回调函数, 延时调用只会调用一次 延时调用和定时调用实际上可以互相代替 延时调用用setTimeout()函数实现 1.setTimeout()12345var num = 1;var timer = setTimeout(function()&#123; console.log(num++);//1s后打印&#125;,1000);cleanTimeout(timer);//关闭定时器","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JSBOM简介","slug":"JSBOM1-0","date":"2019-04-18T07:27:55.000Z","updated":"2019-10-06T09:42:24.000Z","comments":true,"path":"JSBOM1-0.html","link":"","permalink":"https://blog.crainyday.com/JSBOM1-0.html","excerpt":"JSBOM简介","text":"JSBOM简介 一.BOM简介 BOM—— 即浏览器对象模型—— BOM可以使我们通过JS来操作浏览器 BOM对象:—— Window, 代表的是整个浏览器窗口, 同时window也是网页中的全局对象—— Navigator, 代表当前浏览器的信息, 通过该对象可以识别不同浏览器—— Location, 代表当前浏览器的地址栏信息, 通过它可以获取地址栏信息, 或者操作浏览器跳转页面—— History, 代表浏览器的历史记录, 由于隐私, 该对象不能获取到具体的历史记录, 只能操作浏览器向前或向后翻页且该操作只在当次访问时有效.—— Screen, 代表用户的屏幕信息, 通过它可以获取到用户的显示器相关信息(一般用于手机端) 以上BOM对象在浏览器中都是作为window对象的属性保存, 可以通过window对象调用, 也可以直接调用. 1234console.log(window.navigator);console.log(location);console.log(history);console.log(screen); 二.Navigator 代表的是当前浏览器的信息, 通过该对象可以识别不同的浏览器 由于历史原因, Navigator对象中的大部分属性都已无法帮助我们识别不同的浏览器 一般我们使用userAgent(用户代理即浏览器)来判断浏览器信息, 它是一个字符串, 存储着浏览器的信息, 不同的浏览器有不同的userAgent, 但用userAgent不能区分IE11 若通过userAgent不能判断, 还可以用一些浏览器中特有的对象或属性, 来判断浏览器信息, 比如: IE特有的ActiveXObject 1234567891011121314/*navigator.userAgent *chrome:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36 *IE8:Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729) *IE9:Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729) *IE10:Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729) *IE11:Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; rv:11.0) like Gecko */if(\"ActiveXObject\" in window)&#123; alert(\"你是IE\");&#125;else if(/firefox/i.test(navigator.userAgent))&#123; alert(\"你是火狐\");&#125;else if(/chrome/i.test(navigator.userAgent))&#123; alert(\"你是谷歌\");&#125; 三.History 属性或方法 描述 length 返回浏览器历史列表中的URL数量 back() 加载history列表中的前一个 URL forward() 加载history列表中的下一个 URL go() 加载history列表中的某个具体页面(参数决定) history方法的功能相当于浏览器的前进和后退按钮的功能 go() 参数(整数): 1 相当于forward(); -1 相当于back(); 2 前进两次 四.location 代表地址栏信息, 若直接打印location, 则可以打印出地址栏当前页面的完整URL 若直接将location修改为一个绝对地址或相对地址, 则当前页面会自动跳转到该路径, 并会生成相应的历史记录. 属性或方法 描述 href 设置或返回完整的 URL host 设置或返回主机名和当前 URL 的端口号 hostname 设置或返回当前 URL 的主机名 port 设置或返回当前 URL 的端口号 pathname 设置或返回当前 URL 的路径部分 protocol 设置或返回当前 URL 的协议 search 设置或返回从问号(?)开始的URL(查询部分) assign() 加载新的文档, 相当于修改location reload() 重新加载当前文档 replace() 用新的文档替换当前文档 123456789101112131415161718192021&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var jump = document.getElementById(\"jump\"); jump.onclick = function() &#123; // location = \"index.html\"; // location = \"https://www.baidu.com\"; // 和修改location一样 // location.assign(\"https://www.baidu.com\"); // 效果和assign()类似,但不会产生历史记录 // location.replace(\"https://www.baidu.com\"); // 刷新当前页面,和浏览器刷新按钮以及F5一样,若参数为true,则会强制刷新页面缓存 location.reload(true); &#125;; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button type=\"button\" id=\"jump\"&gt;跳转&lt;/button&gt;&lt;/body&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JSDOM事件续","slug":"JSDOM1-6","date":"2019-04-17T10:36:36.000Z","updated":"2019-10-06T09:43:41.000Z","comments":true,"path":"JSDOM1-6.html","link":"","permalink":"https://blog.crainyday.com/JSDOM1-6.html","excerpt":"JSDOM事件续","text":"JSDOM事件续 一.事件的传播 事件的传播分为三个阶段:——1.捕获阶段——– 在捕获阶段时, 从最外层的祖先元素, 向目标元素进行事件捕获, 但此时默认不会触发事件——2.目标阶段——– 事件捕获到目标元素, 捕获结束, 并开始在目标元素上触发事件——3.冒泡阶段——– 事件从目标元素向他的祖先元素传递, 依次触发祖先元素上的相应事件 如果希望在捕获阶段就触发事件, 可以将addEventListener()方法中的第三个参数设置为true, 但一般情况下, 我们不会这么做, 所以一般这个参数都是false IE8及以下浏览器没有捕获阶段 12345678910111213141516171819202122232425262728293031323334&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; function bind(obj,event,callback)&#123; if(obj.addEventListener)&#123; obj.addEventListener(event,callback,true); &#125;else&#123; obj.attachEvent(\"on\"+event,function()&#123; callback.call(obj); &#125;); &#125; &#125; window.onload = function()&#123; var box1 = document.getElementById(\"box1\"); var box2 = document.getElementById(\"box2\"); var box3 = document.getElementById(\"box3\"); bind(box1,\"click\",function()&#123;alert(this.id);&#125;); bind(box2,\"click\",function()&#123;alert(this.id);&#125;); bind(box3,\"click\",function()&#123;alert(this.id);&#125;); &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; #box1&#123;width: 300px;height: 300px;background-color: #bfc;&#125; #box2&#123;width: 200px;height: 200px;background-color: red;&#125; #box3&#123;width: 100px;height: 100px;background-color: yellow;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box1\"&gt;box1 &lt;div id=\"box2\"&gt;box2 &lt;div id=\"box3\"&gt;box3&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 二.拖拽 流程: ——1.鼠标在被拖拽元素上按下时, 开始拖拽 onmousedown ——2.鼠标移动时, 被拖拽元素跟随鼠标移动 onmousemove ——3.鼠标松开时, 被拖拽元素固定在当前位置 onmouseup 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; function draw(obj)&#123; //1.鼠标在obj上按下时,开始拖拽 obj.onmousedown = function(event)&#123; //设置obj捕获第一次onmousedown事件 obj.setCapture &amp;&amp; obj.setCapture(); event = event||window.event; var ol = event.clientX - obj.offsetLeft; var ot = event.clientY - obj.offsetTop; //2.obj随鼠标移动 document.onmousemove = function(event)&#123; event = event||window.event; var top = event.clientY - ol; var left = event.clientX - ot; obj.style.left = left + \"px\"; obj.style.top = top + \"px\"; &#125;; //3.鼠标松开,固定obj document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; //鼠标松开时,取消obj对鼠标按下的捕获 obj.releaseCapture &amp;&amp; obj.releaseCapture(); &#125;; //当我们拖拽网页中的内容时,浏览器会默认到搜索引擎中搜索该内容 //此时会导致拖拽异常,可以通过return false;取消搜索 //IE8及以下不支持,可以用setCapture()实现 return false; &#125;; &#125; window.onload = function()&#123; var box1 = document.getElementById(\"box1\"); var box2 = document.getElementById(\"box2\"); draw(box1); draw(box2); &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; #box1&#123; width: 100px; height: 100px; background-color: #FF0000; position: absolute; &#125; #box2&#123; width: 100px; height: 100px; background-color: #bfa; position: absolute; left: 200px; top: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;文本内容&lt;/span&gt; &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;div id=\"box2\"&gt;&lt;/div&gt;&lt;/body&gt; 三.滚轮事件12345678910111213141516171819202122232425262728293031323334353637&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; function bind(obj,event,callback)&#123; if(obj.addEventListener)&#123; obj.addEventListener(event,callback,false); &#125;else&#123; obj.attachEvent(\"on\"+event,function()&#123; callback.call(obj); &#125;); &#125; &#125; window.onload = function()&#123; var box1 = document.getElementById(\"box1\"); //一般浏览器添加滚轮事件 box1.onmousewheel = function(event)&#123; if(event.wheelDelta&gt;0||event.detail&lt;0)&#123; box1.style.height = box1.clientHeight - 10 + \"px\"; &#125;else&#123; box1.style.height = box1.clientHeight + 10 + \"px\"; &#125; //取消Firefox附带滚动条的默认行为 event.preventDefault &amp;&amp; event.preventDefault(); //取消附带滚动条的默认行为 return false; &#125;; //Firefox添加滚轮事件 bind(box1,\"DomMouseScroll\",box1.onmousewheel); &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; #box1&#123;width: 100px;height: 100px;background-color: red;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box1\"&gt;&lt;/div&gt;&lt;/body&gt; 四.键盘事件 事件 描述 onkeydown 某个键盘的键被按下 onkeyup 某个键盘的键被松开 onkeypress 某个键盘的键被按下或按住 键盘事件一般绑定给一些可以获取焦点的对象(一般为表单项)或者document 对于onkeydown事件来说, 若一直按着某个键不松手, 则事件一直在被触发;当它被连续触发时, 第一次和第二次触发之间会间隔稍微长一些, 之后触发很快; 这种设计是为了防止误操作 键盘事件属性 描述 altKey 返回当事件被触发时，”ALT” 是否被按下 ctrlKey 返回当事件被触发时，”CTRL” 键是否被按下 shiftKey 返回当事件被触发时，”SHIFT” 键是否被按下 keyCode 对于keypress事件, 该属性声明了被敲击的键生成的Unicode字符码. 对于keydown和keyup事件, 它指定了被敲击的键的虚拟键盘码. 虚拟键盘码可能和使用的键盘的布局相关. 1.键盘事件示例1234567891011121314151617181920212223242526&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var text = document.getElementById(\"text\"); text.onkeydown = function(event)&#123; event = event||window.event; //主键区数字:48-57,数字键区:96-105 //禁止在文本框中输入数字 if(event.keyCode&gt;=48&amp;&amp;event.keyCode&lt;=57)&#123; //取消在文本框中输出文本的默认行为 return false; &#125; if(event.keyCode&gt;=96&amp;&amp;event.keyCode&lt;=105)&#123; return false; &#125; if(event.ctrlKey&amp;&amp;event.keyCode==65)&#123; console.log(\"ctrl + A 被按下\"); &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"text\" id=\"text\" value=\"\" /&gt;&lt;/body&gt; 2.使用键盘移动div这里用键盘移动div有个小问题, 假如一直按着→键, div在第一次移动之后会有一点卡顿(这时为了防止按键的误操作), 但这不是我们希望的, 之后会用定时器解决这个问题. 12345678910111213141516171819202122232425&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var box = document.getElementById(\"box\"); document.onkeydown = function(event)&#123; event = event||window.event; var speed = 10; //按住alt键加速 if(event.altKey)&#123; speed = 50; &#125;//左:37 上:38 右:40 下:41 switch(event.keyCode)&#123; case 37:box.style.left = box.offsetLeft - speed + \"px\";break; case 38:box.style.top = box.offsetTop - speed + \"px\";break; case 39:box.style.left = box.offsetLeft + speed + \"px\";break; case 40:box.style.top = box.offsetTop + speed + \"px\";break; &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\" style=\"width: 100px;height: 100px;background-color: red;position: absolute;\"&gt;&lt;/div&gt;&lt;/body&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JSDOM事件","slug":"JSDOM1-5","date":"2019-04-16T03:52:24.000Z","updated":"2019-10-06T09:43:33.000Z","comments":true,"path":"JSDOM1-5.html","link":"","permalink":"https://blog.crainyday.com/JSDOM1-5.html","excerpt":"DOM事件","text":"DOM事件 一.事件对象 事件对象: 当事件对应的响应函数被触发时, 浏览器每次都会将一个事件对象作为实参传递进响应函数, 在事件对象中封装了当前事件相关的一切信息, 比如: 鼠标坐标、键盘哪个按键被按下、鼠标滚轮滚动方向。。。 IE8及以下浏览器, 响应函数被触发时, 浏览器不会传递事件对象, 而把事件对象作为window对象的属性保存 事件句柄 描述 onmousemove 鼠标被移动 onunload 用户退出页面 onfocus 元素获得焦点 鼠标属性 描述 clientX 返回当事件被触发时，鼠标指针的水平坐标 clientY 返回当事件被触发时，鼠标指针的垂直坐标 pageX 鼠标相当于当前页面的水平坐标(IE9+) pageY 鼠标相当于当前页面的垂直坐标(IE9+) 注意: 所有的html代码, 均可直接复制, 然后粘贴到W3School 代码区, 点击提交代码在线执行. 1.div随鼠标移动1234567891011121314151617181920212223242526272829303132333435&lt;head&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var move = document.getElementById(\"move\"); document.onmousemove = function(event)&#123; event = event||window.event; var st = document.body.scrollTop||document.documentElement.scrollTop; var sl = document.body.scrollLeft||document.documentElement.scrollLeft; var left = event.clientX + sl; var top = event.clientY + st; //clientY是相对于浏览器原点鼠标的垂直坐标, //当页面中有滚动条时会出现错误,需要修改坐标 //你可以将+sl或+st去掉试试 move.style.left = left + \"px\"; move.style.top = top + \"px\"; &#125;; &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; body&#123; height: 1000px; width: 2000px; &#125; #move&#123; width: 100px; height: 100px; background-color: red; /*开启定位,否则设置div的left和top没用*/ position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"move\"&gt;&lt;/div&gt;&lt;/body&gt; 二.事件的冒泡 所谓事件冒泡, 就是指事件的向上传导, 当后代元素上的事件被触发时, 其祖先元素的相同事件也会被触发 而在开发中, 大部分情况下冒泡都是有用的, 但是有时候我们不希望事件冒泡. 取消冒泡: 通过将事件对象的cancelBubble属性设置为true, 即可取消冒泡. 例: 取消id为box的div的onmousemove事件的冒泡, 红色的div则不能随鼠标移动到box上 点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var move = document.getElementById(\"move\"); var box = document.getElementById(\"box\"); document.onmousemove = function(event)&#123; event = event||window.event; var st = document.body.scrollTop||document.documentElement.scrollTop; var sl = document.body.scrollLeft||document.documentElement.scrollLeft; var left = event.clientX + sl; var top = event.clientY + st; move.style.left = left + \"px\"; move.style.top = top + \"px\"; &#125;; box.onmousemove = function(event)&#123; event = event||window.event; //取消box的onmousemove的冒泡 event.cancelBubble = true; &#125;; &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; height: 1000px; width: 2000px; &#125; #move&#123; width: 100px; height: 100px; background-color: red; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\" style=\"width: 400px;height: 400px;background-color: #bfa;\"&gt; &lt;/div&gt; &lt;div id=\"move\"&gt;&lt;/div&gt;&lt;/body&gt; 三.事件的委派 所谓事件委派, 就是指将事件统一绑定给元素的共同的祖先元素, 这样当后代元素上的事件触发时, 会一直冒泡到祖先元素, 从而通过祖先元素的响应函数来处理事件, 但是这样的话有时候我们点击页面往往会出现不可预料的结果: 我们不知道到底是什么触发了这个事件. 事件委派就是利用了事件冒泡, 通过委派可以减少事件的绑定次数, 提高程序性能 通过事件对象的target属性, 可以获取触发此次事件的对象 123456789101112131415161718192021222324252627282930&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var btn01 = document.getElementById(\"btn01\"); var u1 = document.getElementById(\"u1\"); btn01.onclick = function() &#123; var li = document.createElement(\"li\"); li.innerHTML = \"&lt;a href='javascript:;' class='link'&gt;新超链接&lt;/a&gt;\"; u1.appendChild(li); &#125;; u1.onclick = function(event) &#123; event = event || window.event; alert(event.target); if (event.target.className.match(/\\blink\\b/)) &#123; alert(\"我是ul的单击响应函数\"); &#125; &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn01\"&gt;添加超链接&lt;/button&gt; &lt;ul id=\"u1\" style=\"background-color: #bfa;\"&gt; &lt;li&gt;&lt;p&gt;123&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" class=\"linkkk\"&gt;超链接一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" class=\"link\"&gt;超链接二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\" class=\"link\"&gt;超链接三&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 四.事件的绑定 使用 对象.事件 = 响应函数; 形式为元素绑定事件响应函数, 只能同时为一个元素的一个事件绑定一个响应函数, 不能绑定多个, 若绑定了多个, 则最后绑定的函数生效. 但是, 在有的时候, 我们就希望为一个元素的相同事件绑定多个响应函数, 此时可用元素的addEventListener()方法绑定响应函数 addEventListener()—— 参数:1.事件的字符串, 不要on, 例 :”onclick”应为”click”——2.回调函数, 当事件触发时调用——3.是否在捕获阶段触发事件, 需要一个布尔值, 一般传false可以绑定多个响应函数, 事件被触发时, 顺序执行绑定的响应函数IE8及以下要用attachEvent()方法代替, 但它的执行顺序与addEventListener()方法相反 addEventListener()中的this是绑定该事件的对象, 而attachEvent()中的this是window 想要兼容各种浏览器, 就需要自己写一个方法:——参数:——obj 要绑定事件的对象——eventStr 要绑定事件的字符串(不要”on”)——callback 回调函数 123456789101112131415161718192021222324252627282930313233&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;script type=\"text/javascript\"&gt; function bind(obj,event,callback)&#123; if(obj.addEventListener)&#123; //大部分浏览器 obj.addEventListener(event,callback,false); &#125;else&#123; //IE8及以下 /* 修改回调函数中的this为传入的obj对象 * this是由调用方式决定的 * 通过callback.call(obj)方式可以修改调用方法时的this */ obj.attachEvent(\"on\"+event,function()&#123; callback.call(obj); &#125;); &#125; &#125; window.onload = function() &#123; var btn01 = document.getElementById(\"btn01\"); bind(btn01,\"click\",function()&#123; alert(this); alert(1); &#125;); bind(btn01,\"click\",function()&#123; alert(2); &#125;); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button type=\"button\" id=\"btn01\"&gt;bind()&lt;/button&gt;&lt;/body&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"DOM操作网页样式","slug":"JSDOM1-4","date":"2019-04-15T06:48:58.000Z","updated":"2019-10-06T09:43:25.000Z","comments":true,"path":"JSDOM1-4.html","link":"","permalink":"https://blog.crainyday.com/JSDOM1-4.html","excerpt":"通过JS的DOM操作网页的样式","text":"通过JS的DOM操作网页的样式 一.JS操作元素内联样式 语法: 元素.style.样式名 = 样式值; 注意: 若CSS样式名中含有-, 例: background-color(即背景) &emsp;&emsp;这种名称在JS中不允许, 需要将其改为驼峰命名, 例: backgroundColor &emsp;&emsp;即, 去掉样式名中的-, 并将-后的字母改为大写. 忘记的话, 可以查看W3School手册中的CSS样式 注意: 通过JSDOM操作元素的style属性读取或修改的样式都是内联样式, 不能读或改CSS的样式, 内联样式拥有较高的优先级, 所以通过JS修改的样式会立即执行. &emsp;&emsp;但是, 若在样式中写了 !important ,则此时样式会有最高的优先级, 无法用JS覆盖该样式. 所以尽量不要用 !important 声明样式. 123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var box = document.getElementsByClassName(\"box\")[0]; var btn = document.getElementById(\"btn01\"); btn.onclick = function()&#123; box.style.width = \"300px\"; box.style.height = \"300px\"; box.style.backgroundColor = \"yellow\"; &#125;; &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; .box&#123; width: 100px; height: 100px; /* *若在red后加!important, *JS不能通过style修改背景颜色 */ background-color: red !important; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn01\"&gt;修改样式&lt;/button&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 二.读取元素的生效样式 语法: 元素.currentStyle.样式名; currentStyle只有IE和Opera支持, 通过currentStyle读取元素样式, 若改样式没有值, 则返回其默认值, 如: currentStyle.width 为auto 别的浏览器(IE9+)可以用window的getComputeStyle方法 &emsp;&emsp;该方法返回一个对象, 该对象封装了指定元素对应的样式 &emsp;&emsp;参数: ①要获取样式的元素②可以传递一个伪元素, 一般传null &emsp;&emsp;通过该对象读取的样式没有值, 也会返回默认值, 但有点不一样, 它返回的为具体的值. &emsp;&emsp;注意: 通过currentStyle和getComputeStyle()方式只能读取元素的样式, 不能修改.要想修改样式, 必须使用style属性 123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;index&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var box = document.getElementsByClassName(\"box\")[0]; var btn = document.getElementById(\"btn01\"); btn.onclick = function() &#123; var css = window.getComputedStyle(box, null); var w = css.width;//w为多少px var h = css.height; //正常浏览器的方式(IE8及一下): var bgc = css.backgroundColor;//bgc为rgb值 alert(\"宽:\" + w + \";高:\" + h + \";背景色:\" + bgc); w = box.currentStyle.with;//w为auto //IE浏览器的方式: bgc = box.currentStyle.backgroundColor;//bgc为样式的值 &#125;; &#125;; &lt;/script&gt; &lt;style type=\"text/css\"&gt; .box&#123; height: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn01\"&gt;显示样式值&lt;/button&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 三.getStyle() 二中提到的获取元素样式的方式, currentStyle只支持IE, 而getComputedStyle()方式不支持IE8及一下. 我们可以自己定义一个函数getStyle(), 用来获取指定元素的样式 1234567891011121314151617181920212223242526272829303132&lt;head&gt; &lt;style type=\"text/css\"&gt; .box &#123; height: 100px; background-color: rgb(255, 0, 0); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn01\"&gt;显示样式值&lt;/button&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function getStyle(obj, name) &#123; if(window.getComputedStyle) &#123; //一般浏览器调用 return getComputedStyle(obj, null)[name]; &#125; else &#123; //IE8及一下时调用 return obj.currentStyle[name]; &#125; &#125; var box = document.getElementsByClassName(\"box\")[0]; var btn = document.getElementById(\"btn01\"); btn.onclick = function() &#123; var w = getStyle(box,\"width\"); var h = getStyle(box,\"height\"); var bgc = getStyle(box,\"backgroundColor\"); alert(\"宽:\" + w + \";高:\" + h + \";背景色:\" + bgc); &#125;; &lt;/script&gt;&lt;/body&gt; 四.其他样式相关属性 属性 描述 element.clientHeight 返回元素的可见高度 element.clientWidth 返回元素的可见宽度 element.offsetHeight 返回元素的高度 element.offsetWidth 返回元素的宽度 element.offsetParent 返回元素的偏移容器 element.offsetLeft 返回元素的水平偏移位置 element.offsetTop 返回元素的垂直偏移位置 element.scrollHeight 返回元素的整体高度 element.scrollWidth 返回元素的整体宽度 element.scrollLeft 返回元素左边缘与视图之间的距离 element.scrollTop 返回元素上边缘与视图之间的距离 clientHeight、clientWidth: 获取元素可见宽度、高度值(返回数字, 不包括px), 不能修改可见高度和宽度指内容区和内边距(width/height+padding) offsetHeight、offsetWidth: 获取元素整个的宽度、高度(可见+boder) offsetParent: 获取当前元素的定位父元素, 即距当前元素最近的开启了定位的祖先元素, 若所有的祖先元素都没开启定位, 则返回body. offsetLeft、offsetTop: 获取当前元素相对于定位父元素的偏移量 scrollHeight、scrollWidth: 获取元素整个滚动区域的高度、宽度 scrollLeft、scrollTop: 获取滚动条滚动的距离, 注意: chrome认为浏览器的滚动条是body的, 火狐等浏览器认为浏览器的滚动条是html的. 当scrollHeight - scrollTop == clientHeight时, 说明垂直滚动条已经滚动到底当scrollWidth - scrollLeft == clientWidth时, 说明水平滚动条已经滚动到底","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JSDOM查询补充","slug":"JSDOM1-3","date":"2019-04-06T09:15:16.000Z","updated":"2019-10-06T09:43:17.000Z","comments":true,"path":"JSDOM1-3.html","link":"","permalink":"https://blog.crainyday.com/JSDOM1-3.html","excerpt":"DOM查询的剩余方法","text":"DOM查询的剩余方法 一.document属性 属性名 描述 body 对应网页的body标签 documentElement 对应网页的html根标签 all 对应网页中的所有标签 1.获取body12345678window.onload = function() &#123; //①通过getElementsByTagName()获取 var body1 = document.getElementsByTagName(\"body\")[0]; console.log(body);//object HTMLBodyElement //②通过document的body属性获取 var body2 = document.body; console.log(body1==body2);//true&#125;; 获取html根标签同理, 但用属性获取时要用document.documentElement获取 2.获取页面中的所有元素1234567891011window.onload = function() &#123; //①通过getElementsByTagName() var all1 = document.getElementsByTagName(\"*\"); //②通过all属性获取 var all2 = document.all; console.log(all1==all2);//false for(var i = 0;i &lt; all1.length;i ++)&#123; console.log(all1[i]==all2[i]);//true console.log(all1[i]); &#125;&#125;; 二.其他DOM查询方法 方法 描述 getElementsByClassName() 根据元素的class属性值查询一组节点对象 querySelector() 根据CSS选择器来查询第一个满足条件的元素节点对象 querySelectorAll() 根据CSS选择器来查询所有满足条件的元素节点对象 1.getElementsByClassName()根据元素的class属性值查询一组节点对象, 兼容性IE9+ 12345678910&lt;body&gt; &lt;div class=\"box\"&gt;One&lt;/div&gt; &lt;div class=\"box\"&gt;Two&lt;/div&gt; &lt;div id=\"mybox\"&gt;Three&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var boxs = document.getElementsByClassName(\"box\"); console.log(boxs);//object HTMLCollection console.log(boxs[0].innerText);//One &lt;/script&gt;&lt;/body&gt; 2.querySelector() 参数: 内容为CSS选择器的字符串 该方法只会查询满足条件的第一个元素对象 兼容性IE8+. 可以用来代替getElementsByClassName()方法 12345678&lt;body&gt; &lt;div class=\"box\"&gt;One&lt;/div&gt; &lt;div class=\"box\"&gt;Two&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var box = document.querySelector(\".box\"); console.log(box.innerText);//One &lt;/script&gt;&lt;/body&gt; 3.querySelectorAll() 和querySelector()方法类似, 只是它的返回值是一个数组 即使满足条件的元素只有一个, 返回的也是数组 12345678910&lt;body&gt; &lt;div class=\"box\"&gt;One&lt;/div&gt; &lt;div class=\"box\"&gt;Two&lt;/div&gt; &lt;div id=\"mybox\"&gt;Three&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var box = document.querySelectorAll(\"#mybox\"); console.log(box);//object NodeList console.log(box[0].innerText);//Three &lt;/script&gt;&lt;/body&gt; 三.DOM增删改 方法 描述 appendChild() 把新的子节点添加到指定节点 removeChild() 删除子节点 replaceChild() 替换子节点 insertBefore() 在指定的子节点前面插入新的子节点 createElement() 创建元素节点 createTextNode() 创建文本节点。 1.html点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; @CHARSET \"UTF-8\"; body &#123; width: 800px; margin-left: auto; margin-right: auto; &#125; button &#123; width: 300px; margin-bottom: 10px; &#125; #btnList &#123; float: left; &#125; #total &#123; width: 450px; float: left; &#125; ul &#123; list-style-type: none; margin: 0px; padding: 0px; &#125; .inner li &#123; border-style: solid; border-width: 1px; padding: 5px; margin: 5px; background-color: #99ff99; float: left; &#125; .inner &#123; width: 400px; border-style: solid; border-width: 1px; margin-bottom: 10px; padding: 10px; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"total\"&gt; &lt;div class=\"inner\"&gt; &lt;p&gt; 你喜欢哪个城市? &lt;/p&gt; &lt;ul id=\"city\"&gt; &lt;li id=\"bj\"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"btnList\"&gt; &lt;div&gt;&lt;button id=\"btn01\"&gt;创建一个\"广州\"节点,添加到#city下&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn02\"&gt;将\"广州\"节点插入到#bj前面&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn03\"&gt;使用\"广州\"节点替换#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn04\"&gt;删除#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn05\"&gt;读取#city内的HTML代码&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn06\"&gt;设置#bj内的HTML代码&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn07\"&gt;创建一个\"广州\"节点,添加到#city下&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.创建追加节点 appendChild() 将一个节点追加到指定加点之后 createElement() 创建指定名字的元素节点 createTextNode() 创建指定内容的文本节点 1234567891011121314151617181920212223242526272829303132function myClick(idStr, fun) &#123; var btn = document.getElementById(idStr); btn.onclick = fun;&#125;window.onload = function() &#123; //创建一个\"广州\"节点,添加到#city下 myClick(\"btn01\", function() &#123; var city = document.getElementById(\"city\"); var gz = document.createElement(\"li\"); var text = document.createTextNode(\"广州\"); gz.appendChild(text); city.appendChild(gz); &#125;); //读取#city内的HTML代码 myClick(\"btn02\",function()&#123; var city = document.getElementById(\"city\"); alert(city.innerHTML); &#125;); //设置#bj内的HTML代码 myClick(\"btn06\",function()&#123; var bj = document.getElementById(\"bj\"); bj.innerHTML = \"日本\"; &#125;); //向city中添加广州 myClick(\"btn06\",function()&#123; var city = document.getElementById(\"city\"); var gz = document.createElement(\"li\"); //不再创建文本节点 gz.innerHTML = \"广州\"; city.appendChild(gz); &#125;);&#125; 3.插入替换删除节点 insertBefore() 由父元素调用, 在第二个参数节点之前插入新节点(第一个参数) replaceChild() 由父元素调用, 将第二个参数节点替换为新节点(第一个参数) removeChild() 由父元素调用, 删除指定元素节点 123456789101112131415161718192021222324window.onload = function() &#123; //将\"广州\"节点插入到#bj前面 myClick(\"btn02\", function() &#123; var city = document.getElementById(\"city\"); var bj = document.getElementById(\"bj\"); var gz = document.createElement(\"li\"); gz.innerHTML = \"广州\"; city.insertBefore(gz,bj); &#125;); //使用\"广州\"节点替换#bj节点 myClick(\"btn03\", function() &#123; var city = document.getElementById(\"city\"); var bj = document.getElementById(\"bj\"); var gz = document.createElement(\"li\"); gz.innerHTML = \"广州\"; city.replaceChild(gz,bj); &#125;); //删除#bj节点 myClick(\"btn04\", function() &#123; var city = document.getElementById(\"city\"); var bj = document.getElementById(\"bj\"); city.removeChild(bj); &#125;);&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JSDOM练习","slug":"JSDOM1-2","date":"2019-04-06T07:41:24.000Z","updated":"2019-10-06T09:43:09.000Z","comments":true,"path":"JSDOM1-2.html","link":"","permalink":"https://blog.crainyday.com/JSDOM1-2.html","excerpt":"JS DOM实现切换图片、多选框全选","text":"JS DOM实现切换图片、多选框全选 一.图片切换CSS样式:1234567891011*&#123; margin: 0; padding: 0;&#125;.img&#123; width: 500px; margin: 50px auto; padding: 10px; text-align: center; background-color: yellowgreen;&#125; html的body:12345678&lt;body&gt; &lt;div class=\"img\"&gt; &lt;p id=\"info\"&gt;&lt;/p&gt; &lt;img src=\"img/1.jpg\" alt=\"冰棍\"/&gt; &lt;button id=\"prev\"&gt;上一张&lt;/button&gt; &lt;button id=\"next\"&gt;下一张&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 分析: 想要实现点击按钮时图片的切换, 只需给按钮添加一个点击事件, 点击时修改一下img标签的src就好了. 图片: JS实现图片切换:12345678910111213141516171819202122232425262728window.onload = function()&#123; //获取相应元素 var prev = document.getElementById(\"prev\"); var next = document.getElementById(\"next\"); var img = document.getElementsByTagName(\"img\")[0]; var info = document.getElementById(\"info\"); //添加图片的src var imgSrcs = [\"img/1.jpg\",\"img/2.jpg\",\"img/3.jpg\",\"img/4.jpg\",\"img/5.jpg\"]; var index = 0; var str = \"一共\"+imgSrcs.length+\"张图片,当前第\"; info.innerHTML = str + (index+1) + \"张\"; //点击上一张的事件 prev.onclick = function()&#123; if(--index==-1)&#123; index = imgSrcs.length-1; &#125; img.src = imgSrcs[index]; info.innerHTML = str + (index+1) + \"张\"; &#125;; //点击下一张的事件 next.onclick = function()&#123; if(++index==imgSrcs.length)&#123; index = 0; &#125; img.src = imgSrcs[index]; info.innerHTML = str + (index+1) + \"张\"; &#125;;&#125;; 二.全选练习html的body: 123456789101112131415&lt;body&gt; &lt;form method=\"post\" action=\"\"&gt; 你爱好的运动是？&lt;input type=\"checkbox\" id=\"checkedAllBox\" /&gt;全选/全不选 &lt;br /&gt; &lt;input type=\"checkbox\" name=\"items\" value=\"足球\" /&gt;足球 &lt;input type=\"checkbox\" name=\"items\" value=\"篮球\" /&gt;篮球 &lt;input type=\"checkbox\" name=\"items\" value=\"羽毛球\" /&gt;羽毛球 &lt;input type=\"checkbox\" name=\"items\" value=\"乒乓球\" /&gt;乒乓球 &lt;br /&gt; &lt;input type=\"button\" id=\"checkedAllBtn\" value=\"全 选\" /&gt; &lt;input type=\"button\" id=\"checkedNoBtn\" value=\"全不选\" /&gt; &lt;input type=\"button\" id=\"checkedRevBtn\" value=\"反 选\" /&gt; &lt;input type=\"button\" id=\"sendBtn\" value=\"提 交\" /&gt; &lt;/form&gt;&lt;/body&gt; 注意: 网页中的checkedAllBox多选框, 当点击选中它时, 下面的所有多选框也选中, 当点击取消选中它时, 下面的所有多选框也取消选中; 还得保证, 如果下面的多选框全部选中, 则checkedAllBox也选中, 如果下面的多选框没有全部选中, 则它也不选中. 1.全选按钮通过W3School离线手册查询JS对象里的HTML对象\\&lt;input> checkbox, 可知它有属性checked表示现在多选框的选中状态. 123456789101112131415window.onload = function() &#123; //获取全选按钮 var allBtn = document.getElementById(\"checkedAllBtn\"); //获取所有多选框 var items = document.getElementsByName(\"items\"); //获取checkedAllBox多选框 var checkedAllBox = document.getElementById(\"checkedAllBox\"); allBtn.onclick = function()&#123; for(var i = 0;i &lt; items.length;i ++)&#123; items[i].checked = true; &#125; //选中checkedAllBox checkedAllBox.checked = true; &#125;;&#125; 2.全不选按钮1234567891011121314window.onload = function() &#123; //获取全不选按钮 var noBtn = document.getElementById(\"checkedNoBtn\"); //获取所有多选框与checkedAllBox,共用之前的代码 var items = document.getElementsByName(\"items\"); var checkedAllBox = document.getElementById(\"checkedAllBox\"); noBtn.onclick = function()&#123; for(var i = 0;i &lt; items.length;i ++)&#123; items[i].checked = false; &#125; //取消选中checkedAllBox checkedAllBox.checked = false; &#125;;&#125; 3.反选1234567891011121314151617window.onload = function() &#123; //获取反选按钮 var revBtn = document.getElementById(\"checkedRevBtn\"); //获取所有多选框与checkedAllBox,共用之前的代码 var items = document.getElementsByName(\"items\"); var checkedAllBox = document.getElementById(\"checkedAllBox\"); revBtn.onclick = function()&#123; var flag = 0; for(var i = 0; i &lt; items.length; i++) &#123; items[i].checked = !items[i].checked; flag += items[i].checked; &#125; //如果所有多选框选中,选中checkedAllBox if(flag==4)checkedAllBox.checked = true; else checkedAllBox.checked = false; &#125;;&#125; 4.提交点击提交按钮时, 弹出选中的value属性值 12345678910111213window.onload = function() &#123; //获取提交按钮 var submitBtn = document.getElementById(\"sendBtn\"); //获取所有多选框,共用之前的代码 var items = document.getElementsByName(\"items\"); submitBtn.onclick = function() &#123; for(var i = 0; i &lt; items.length; i++) &#123; if(items[i].checked)&#123; alert(items[i].value); &#125; &#125; &#125;;&#125; 5.checkedAllBox1234567891011window.onload = function() &#123; //获取所有多选框与checkedAllBox,共用之前的代码 var items = document.getElementsByName(\"items\"); var checkedAllBox = document.getElementById(\"checkedAllBox\"); checkedAllBox.onclick = function()&#123; //同步所有多选框 for(var i = 0; i &lt; items.length; i++) &#123; items[i].checked = this.checked; &#125; &#125;;&#125; 6.点击多选框123456789101112131415161718window.onload = function() &#123; //获取所有多选框与checkedAllBox,共用之前的代码 var items = document.getElementsByName(\"items\"); var checkedAllBox = document.getElementById(\"checkedAllBox\"); for(var i = 0; i &lt; items.length; i++) &#123; //给每个多选框绑定单击响应函数 items[i].onclick = function()&#123; //点击多选框时,同步checkedAllBox checkedAllBox.checked = true; for(var j = 0; j &lt; items.length; j++) &#123; if(!items[j].checked)&#123; checkedAllBox.checked = false; break; &#125; &#125; &#125;; &#125;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JSDOM基础查询","slug":"JSDOM1-1","date":"2019-04-05T08:27:48.000Z","updated":"2019-10-06T09:43:01.000Z","comments":true,"path":"JSDOM1-1.html","link":"","permalink":"https://blog.crainyday.com/JSDOM1-1.html","excerpt":"JS的DOM基础查询","text":"JS的DOM基础查询 一.获取元素节点元素节点, 即HTML标签对象 DOM(document)对象的方法: 方法 描述 getElementById() 返回对拥有指定 id 的第一个对象的引用 getElementsByName() 返回带有指定name属性的对象集合 getElementsByTagName() 返回带有指定标签名的对象集合 write() 向文档写 HTML 表达式 或 JavaScript 代码 writeln() 等同于 write() 方法, 不同的是在每个表达式之后写一个换行符 通过例子, 看一下获取元素节点的三个DOM方法 样式表: 点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738@CHARSET \"UTF-8\";body &#123; width: 800px; margin-left: auto; margin-right: auto;&#125;button &#123; width: 300px; margin-bottom: 10px;&#125;#btnList &#123; float:left;&#125;#total&#123; width: 450px; float:left;&#125;ul&#123; list-style-type: none; margin: 0px; padding: 0px;&#125;.inner li&#123; border-style: solid; border-width: 1px; padding: 5px; margin: 5px; background-color: #99ff99; float:left;&#125;.inner&#123; width:400px; border-style: solid; border-width: 1px; margin-bottom: 10px; padding: 10px; float: left;&#125; html的body: 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;body&gt; &lt;div id=\"total\"&gt; &lt;div class=\"inner\"&gt; &lt;p&gt;你喜欢哪个城市?&lt;/p&gt; &lt;ul id=\"city\"&gt; &lt;li id=\"bj\"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt;&lt;br /&gt; &lt;p&gt;你喜欢哪款单机游戏?&lt;/p&gt; &lt;ul id=\"game\"&gt; &lt;li id=\"rl\"&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt;&lt;br /&gt; &lt;p&gt;你手机的操作系统是?&lt;/p&gt; &lt;ul id=\"phone\"&gt; &lt;li&gt;IOS&lt;/li&gt; &lt;li id=\"android\"&gt;Android&lt;/li&gt; &lt;li&gt;Windows Phone&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"inner\"&gt; gender: &lt;input class=\"hello\" type=\"radio\" name=\"gender\" value=\"male\" /&gt; Male &lt;input class=\"hello\" type=\"radio\" name=\"gender\" value=\"female\" /&gt; Female &lt;br /&gt;&lt;br /&gt; name: &lt;input type=\"text\" name=\"name\" id=\"username\" value=\"abcde\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"btnList\"&gt; &lt;div&gt;&lt;button id=\"btn01\"&gt;查找#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn02\"&gt;查找所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn03\"&gt;查找name=gender的所有节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn04\"&gt;查找#city下所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn05\"&gt;返回#city的所有子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn06\"&gt;返回#phone的第一个子节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn07\"&gt;返回#bj的父节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn08\"&gt;返回#android的前一个兄弟节点&lt;/button&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 1.getElementById12345678910window.onload = function() &#123; //为id为btn01的按钮绑定一个单击响应函数 var btn01 = document.getElementById(\"btn01\"); btn01.onclick = function() &#123; //查找id为bj的节点 var bj = document.getElementById(\"bj\"); //innerHTML 通过这个属性可以获取到元素内部的html代码 alert(bj.innerHTML); &#125;;&#125; 2.getElementsByTagName1234567891011121314window.onload = function() &#123; //为id为btn02的按钮绑定一个单击响应函数 var btn02 = document.getElementById(\"btn02\"); btn02.onclick = function() &#123; //查找所有li节点 //getElementsByTagName()可以根据标签名来获取一组元素节点对象 //这个方法会给我们返回一个类数组对象,所有查询到的元素都会封装到对象中 //即使查询到的元素只有一个,也会封装到数组中返回 var lis = document.getElementsByTagName(\"li\"); for(var i = 0; i &lt; lis.length; i++) &#123; alert(lis[i].innerHTML); &#125; &#125;;&#125; 3.getElementsByName1234567891011121314151617181920212223window.onload = function() &#123; //为id为btn03的按钮绑定一个单击响应函数 var btn03 = document.getElementById(\"btn03\"); btn03.onclick = function() &#123; //查找name属性,值为gender的所有节点 var inputs = document.getElementsByName(\"gender\"); for(var i = 0; i &lt; inputs.length; i++) &#123; /* innerHTML用于获取元素内部的HTML代码的 * 对于自结束标签,这个属性没有意义 */ /* 如果需要读取自结束标签的属性 * 直接使用 元素.属性名 * 例: 元素.id 元素.name 元素.value * 注意: class属性不能采用这种方式 * 读取class属性时需要使用 元素.className */ var str = \"class=\\\"\"+inputs[i].className+ \"\\\" type=\\\"\"+inputs[i].type+\"\\\" name=\\\"\"+ inputs[i].name+\"\\\" value=\\\"\"+inputs[i].value+\"\\\"\"; alert(str); &#125; &#125;;&#125; 二.获取元素节点的子节点通过具体的元素节点调用: 方法或属性 简介 getElementsByTagName() 返回当前节点的指定标签名的所有后代节点 childNodes属性 表示当前节点的所有子节点(包括文本节点) children属性 表示当前节点的所有子元素(即HTML标签) firstChild属性 表示当前节点的第一个子节点 lastChild属性 表示当前节点的最后一个子节点 1.获取某个元素的所有指定节点接着上述的练习: 123456789101112131415window.onload = function() &#123; //为id为btn04的按钮绑定一个单击响应函数 var btn04 = document.getElementById(\"btn04\"); btn04.onclick = function() &#123; //查找#city下所有li节点 //获取id为city的元素 var city = document.getElementById(\"city\"); //获取city下的所有li元素 var citys = city.getElementsByTagName(\"li\"); for(var i = 0; i &lt; citys.length; i++) &#123; var str = citys[i].innerHTML; alert(str); &#125; &#125;;&#125; 2.childNodes属性childNodes, 这个属性会返回节点的所有子节点, 包括文本节点(IE8+,空白文本也算) children, 这个属性会返回节点的所有子元素(即HTML标签) 12345678910111213141516171819window.onload = function() &#123; //为id为btn05的按钮绑定一个单击响应函数 var btn05 = document.getElementById(\"btn05\"); btn05.onclick = function() &#123; //返回#city的所有子节点 //获取id为city的元素 var city = document.getElementById(\"city\"); /* 获取city下的所有节点: * 这其中包括文本节点 * 空白字符(换行、空格等)也算文本节点 */ var nodes = city.children; //若我们只是想获取所有子元素(即HTML标签)可以这样 nodes = city.childNodes; for(var i = 0; i &lt; nodes.length; i++) &#123; alert(nodes[i]); &#125; &#125;;&#125; 3.firstChildfirstChild属性, 获取当前元素的第一个子节点(包括空白文本节点) firstElementChild属性(IE9+), 获取当前元素的第一个子元素 123456789101112window.onload = function() &#123; //为id为btn06的按钮绑定一个单击响应函数 var btn06 = document.getElementById(\"btn06\"); btn06.onclick = function() &#123; //返回#phone的第一个子节点 //获取id为phone的元素 var phone = document.getElementById(\"phone\"); var first = phone.firstChild; alert(first); //若HTML代码被格式化了,上面输出为:object Text &#125;;&#125; lastChild和firstChild属性类似 三.获取父节点和兄弟节点 属性 描述 parentNode 表示当前节点的父节点 previousSibling 表示当前节点的前一个兄弟节点 nextSibling 表示当前节点的后一个兄弟节点 1.parentNode观察上述代码, 我们做了大量的重复性工作: 先获取到指定id的按钮, 再给该按钮添加一个单击响应函数. 可以考虑将这两个过程封装成一个函数. 1234567891011121314151617function myClick(id,fun)&#123; var btn = document.getElementById(id); btn.onclick = fun;&#125;window.onload = function() &#123; //获取id为btn07的按钮并为其绑定一个单击响应函数 var btn07 = myClick(\"btn07\",function()&#123; //返回#bj的父节点,注意:父节点一定是元素即标签 var bj = document.getElementById(\"bj\"); var bjParent = bj.parentNode; //alert(bjParent.innerHTML);//获取元素的HTML代码 /* innerText属性:获取元素内部的文本内容 * 它会自动将innerHTML中的HTML标签去掉 */ alert(bjParent.innerText); &#125;);&#125; 2.previousSiblingpreviousSibling属性, 获取前一个兄弟节点(包括空白文本节点) previousElementSibling属性(IE9+), 获取前一个兄弟元素 123456789window.onload = function() &#123; //获取id为btn08的按钮并为其绑定一个单击响应函数 var btn08 = myClick(\"btn08\",function()&#123; //返回#android的前一个兄弟节点 var android = document.getElementById(\"android\"); var ardPre = android.previousSibling; alert(ardPre); &#125;);&#125; nextSibling属性和previousSibling属性类似","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JSDOM简介","slug":"JSDOM1-0","date":"2019-04-05T06:03:12.000Z","updated":"2019-10-06T09:42:51.000Z","comments":true,"path":"JSDOM1-0.html","link":"","permalink":"https://blog.crainyday.com/JSDOM1-0.html","excerpt":"JS中的宿主对象, JSDOM","text":"JS中的宿主对象, JSDOM 一.DOM简介1.什么是DOM DOM, 即Document Object Model 文档对象模型 JS中通过操作DOM来对HTML文档进行操作.只要了解DOM就可以随心所欲的操作WEB页面 文档: 表示的是整个HTML网页文档 对象: 表示将页面中的每一个部分(包括那些HTML标签)都转换为了对象. 模型: 表示对象(即HTML中的节点)之间的关系, 这样方便我们获取、操作对象. 2.节点 节点(也即对象): Node——构成html文档最基本的单元, 网页中的每个部分都可以称为一个节点 常用节点分为四类: ——①文档节点: 整个HTML文档(即document对象) ——②元素节点: HTML文档中的html标签 ——③属性节点: 元素的属性 ——④文本节点: HTML标签中的文本内容 节点的类型不同, 它们的属性也可能不同 节点的属性 nodeName nodeType nodeValue 文档节点 #document 9 null 元素节点 标签名 1 null 属性节点 属性名 2 属性值 文本节点 #text 3 文本内容 练习: JS操纵网页中的按钮123456789101112&lt;body&gt; &lt;button id=\"btn\"&gt;我是一个按钮&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; console.log(document);//object HTMLDocument //获取button对象 var btn = document.getElementById(\"btn\"); console.log(btn);//object HTMLButtonElement console.log(btn.innerHTML);//我是一个按钮 //修改按钮的文字 btn.innerHTML = \"I'm a button\"; &lt;/script&gt;&lt;/body&gt; 二.事件 事件, 即文档或浏览器窗口发生的一些特定的交互瞬间, 用户和浏览器之间的交互行为 比如: 点击按钮、鼠标移动、关闭浏览器窗口…… 我们往往比较关注对事件的处理, 即响应事件 1.事件句柄 属性 此事件发生在何时 onabort 图像的加载被中断 onblur 元素失去焦点 onchange 域的内容被改变 onclick 当用户点击某个对象时调用的事件句柄 ondblclick 当用户双击某个对象时调用的事件句柄 onerror 在加载文档或图像时发生错误 onfocus 元素获得焦点 onkeydown 某个键盘按键被按下 onkeypress 某个键盘按键被按下并松开 onkeyup 某个键盘按键被松开 onload 一张页面或一幅图像完成加载 onmousedown 鼠标按钮被按下 onmousemove 鼠标被移动 onmouseout 鼠标从某元素移开 onmouseover 鼠标移到某元素之上 onmouseup 鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被重新调整大小 onselect 文本被选中 onsubmit 确认按钮被点击 onunload 用户退出页面 2.设置事件属性我们可以在事件对应的属性中设置一些JS代码, 当该事件被触发时, 这些代码将会执行 1234&lt;!--鼠标被移动时触发--&gt;&lt;body&gt; &lt;button id=\"btn\" onmousemove=\"alert('讨厌,移到我上面干嘛~~~')\"&gt;我是一个按钮&lt;/button&gt;&lt;/body&gt; 注意: 这种响应方式, 结构与行为发生耦合, 不方便维护, 我们一般不这样使用. 3.绑定响应函数12345678910&lt;body&gt; &lt;!--双击某个对象时触发--&gt; &lt;button id=\"btn\"&gt;我是一个按钮&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var btn = document.getElementById(\"btn\"); btn.ondblclick = function()&#123; alert('讨厌,点我两下干嘛~~~'); &#125;; &lt;/script&gt;&lt;/body&gt; 或 123456789&lt;body&gt; &lt;!--单击某个对象时触发--&gt; &lt;button id=\"btn\" onclick=\"showMsg();\"&gt;我是一个按钮&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var showMsg = function()&#123; alert('讨厌,点我干嘛~~~'); &#125;; &lt;/script&gt;&lt;/body&gt; 三.文档的加载&emsp;&emsp;注意到, 我们上面的代码中, script标签都写在button标签之后, 为什么呢? 这与页面的加载顺序有关, 页面是顺序加载(自上往下)的, 假如把script标签写在button标签之前, 这时在script里获取button对象时获取不到button对象, 因为它还没被加载, 再为一个null添加一个事件就会报错. 故我们需要在该DOM对象加载之后再获取它, 要么把script标签放到要获取的DOM对象之后, 要么将获取及操作该DOM对象的JS代码放在window.onload事件的响应函数中. 1.onload事件 onload 事件会在页面或图像加载完成后立即发生, 该事件支持的JS对象: image, layer, window 先弹出消息对话框, 点击确定后, 再加载出按钮: 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;JSDOM&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; alert(\"hello\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;我是一个按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 先加载出按钮, 再弹出消息对话框: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;JSDOM&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; alert(\"hello\"); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;我是一个按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 个人觉得script标签写在DOM对象加载之后更好一些, 这样的话, 加载性能好点, 用户体验好. 但是现在的网速和浏览器内核已经很好了, 其实写在哪里没什么太大的差别.","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JS正则","slug":"JS2-5","date":"2019-04-04T00:30:47.000Z","updated":"2019-10-06T09:42:16.000Z","comments":true,"path":"JS2-5.html","link":"","permalink":"https://blog.crainyday.com/JS2-5.html","excerpt":"JS中的正则","text":"JS中的正则 一.正则表达式简介 百度百科:正则表达式, 又称规则表达式. (英语: Regular Expression, 在代码中常简写为regex、regexp或RE), 计算机科学的一个概念. 正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本. 正则表达式用于定义一些字符串的规则, 计算机根据正则表达式, 来检查是否符合规则, 获取、提取字符串中符合规则的内容. 1.创建RegExp对象正则表达式对象即RegExp对象, JS内置的对象. RegExp对象的test()方法, 检索字符串中指定的值, 返回 true 或 false 1234567//语法://var 变量名 = new RegExp(\"正则表达式\",\"匹配模式\");//匹配模式:i 忽略大小写;g 全局匹配;m 多行匹配;var reg = new RegExp(\"a\",\"i\");var str = \"ABCD\";var result = reg.test(str);//检查字符串中是否含Aconsole.log(result);//true 2.字面量创建RegExp对象字面量的方式创建更加简单, 使用构造函数创建更加灵活(可以传参数). 语法: var 变量名 = /正则表达式/匹配模式; 注意: 语法中没有引号 表达式 描述 [abc] 查找方括号之间的任何字符 [^abc] 查找任何不在方括号之间的字符 [0-9] 查找任何从 0 至 9 的数字 [a-z] 查找任何从小写 a 到小写 z 的字符 [A-Z] 查找任何从大写 A 到大写 Z 的字符 [A-z] 查找任何从大写 A 到小写 z 的字符 [adgk] 查找给定集合内的任何字符 [^adgk] 查找给定集合外的任何字符 (red blue green) 查找任何指定的选项 12345678910111213var reg = /a/i;//等价于:var reg = new RegExp(\"a\",\"i\");//1.创建一个正则表达式检查一个字符串中是否含有a或breg = /a|b/;//2.创建一个正则表达式检查一个字符串中是否含有字母reg = /[A-z]/;//中括号表示或的意思//3.检查一个字符串中是否含有abc或adc或aecreg = /a[bde]c/;//以a开头,c结尾,中间为b或d或ereg = /[^0-9]/;//检查除了数字之外的内容reg = /(abc)/;//abc连续出现reg = /(a|b|c)/;//出现过a或b或c 二.字符串与正则相关的方法1.split 根据参数将字符串拆分为字符数组 参数可以是正则表达式 正则不需要设置全局匹配, split默认将所有符合条件的拆分 123var str = \"1a2b3c4d5e6f7g8\";var arr = str.split(/[A-z]/);//根据任意字母拆分console.log(arr);//1,2,3,4,5,6,7,8 2.search 检索与正则表达式相匹配的值 如果可以搜索到指定内容, 则返回第一次出现过的位置, 没搜索到返回-1 它能接受一个正则表达式作为参数, 然后根据正则表达式检索字符串 search正则查找时不能设置全局匹配 12345//功能和indexOf()类似var str = \"hello abc hello adc hello aec\";//搜索字符串中是否含有abc或adc或aecvar result = str.search(/a[bde]c/);console.log(result);//6 3.match 可以根据正则表达式, 从一个字符串中将符合条件的内容提取出来 默认情况下, match只会找第一个符合条件的内容, 找到后停止检索, 我们可以将正则表达式设置为全局匹配模式, 这样match会找到所有符合条件的内容 可以为正则表达式设置多个匹配模式, 且顺序无所谓 match会将匹配到的内容封装到一个数组中返回, 即使只查询到一个结果. 可以将一个没有规则的长串中, 有规则的内容提取出来, 很实用 1234567891011121314var str = \"1A2B3C4d5e6f7g8\";var result = str.match(/[a-z]/gi);console.log(Array.isArray(result));//true;console.log(result);//A,B,C,d,e,f,gconsole.log(result[0]);//A//筛选出所有的QQ号var str = \"826720408abhfe826720407\"+ \"freaf826720405C826720\"+ \"404d826720405e8267204\"+ \"00f826720409g826720401\";var result = str.match(/[0-9]&#123;8,10&#125;/g);console.log(Array.isArray(result));//true;console.log(result); 4.replace 将字符串中指定的内容替换为新的内容, 不影响原字符串 参数:①被替换的内容, 可以接受一个正则表达式作为参数 ②新的内容 默认只会替换一个,可以为正则表达式设置全局匹配模式替换所有内容 1234var str = \"1A2B3C4d5e6f7g8\";//将所有字母替换为\"\"var result = str.replace(/[a-z]/gi,\"\");console.log(result);//12345678 三.正则表达式语法补充1.量词 量词: 可以设置一个内容出现的次数, 它只对它前面的一个内容起作用 量词 描述 n+ 匹配任何包含至少一个 n 的字符串, 相当于n{1, } n* 匹配任何包含零个或多个 n 的字符串, 相当于n{0, } n? 匹配任何包含零个或一个 n 的字符串, 相当于n{0,1} n{x} 匹配包含 x 个 n 的序列的字符串 n{x,y} 匹配包含 x ~ y 个 n 的序列的字符串 n{x, } 匹配包含至少 x 个 n 的序列的字符串 n$ 匹配任何结尾为 n 的字符串 ^n 匹配任何开头为 n 的字符串 ?=n 匹配任何其后紧接指定字符串 n 的字符串 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串 12345678910111213var reg = /a&#123;3&#125;/;console.log(reg.test(\"xaaax\"));//只有字符串中连续出现3个a时为truereg = /(ab)&#123;3&#125;/;console.log(reg.test(\"xabababx\"));//只有字符串中连续出现3个ab时为truereg = /ab&#123;3,5&#125;c/;console.log(reg.test(\"xabbbbcx\"));//只有字符串中a和c之间有3~5个b时为truereg = /ab&#123;3,&#125;c/;console.log(reg.test(\"xabbbcx\"));//只有字符串中a和c之间有2个以上b时为truereg = /^a$/;console.log(reg.test(\"a\"));//只有字符串为\"a\"时,结果为truereg = /^a|a$/;console.log(reg.test(\"abc\"));//字符串以a开头或以a结尾时为true 注意: 在正则表达式中同时使用了 ^ 和 $ 量词, 则要求字符串必须完全符合正则表达式. 练习: 手机号的正则表达式匹配手机号的正则表达式: /^1[3-9][0-9]{9}$/ 123456789/*手机号的规则: *1. 以1开头 *2. 第二位为3-9任意数字 *3. 第三位之后为任意数字9个 * ^ 和 $ 量词是必须的 * ^1 [3-9] [0-9]&#123;9&#125;$ */var phoneNumReg = /^1[3-9][0-9]&#123;9&#125;$/;console.log(phoneNumReg.test(\"15555555555\"));//true 2.元字符 元字符 描述 . 查找单个字符, 除了换行和行结束符 \\w 查找单词字符(字母、数字、下划线) \\W 查找非单词字符 \\d 查找数字 \\D 查找非数字字符 \\s 查找空白字符 \\S 查找非空白字符 \\b 匹配单词边界 \\B 匹配非单词边界 \\0 查找 NULL 字符 \\n 查找换行符 \\f 查找换页符 \\r 查找回车符 \\t 查找制表符 \\v 查找垂直制表符 \\xxx 查找以八进制数 xxx 规定的字符 \\xdd 查找以十六进制数 dd 规定的字符 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符 1234567891011121314151617//查找字符串中是否有.//正则字面量://由于.是元字符,我们要用\\.来代替.//而\\表示转义,要用\\\\来代替\\var reg = /\\./;console.log(reg.test(\"adsC.dSf l\"));//true//正则构造函数://由于函数的参数为字符串,而在字符串中\\代表转义字符//故在字面量中的一个\\要用\\\\来代替var reg1 = new RegExp(\"\\\\.\");//等价于regconsole.log(reg1);//输出:/\\.///查找字符串是否含单词childreg = /\\bchild\\b/;console.log(reg.test(\"hello children\"));//falseconsole.log(reg.test(\"hello child ren\"));//true 练习: A.去除字符串的前后空格匹配开头和结尾空格的正则表达式: /^\\s*|\\s*$/g 12345678910//可以考虑replace用空串替换空格var str = \" Aaron Bob \";//str = str.replace(/\\s/g,\"\");//去除所有空格//str = str.replace(/^\\s*/,\"\");//去除开头的空格//str = str.replace(/\\s*$/,\"\");//去除结尾的空格//综合一下:str = str.replace(/^\\s*|\\s*$/g,\"\");//因为是或的关系,若不加全局匹配,方法匹配完开头的空格就返回了console.log(str); 练习: B.email的正则表达式12345678910/*电子邮件格式: * hello .hello @ abc .com .cn * * 任意字母数字下划线 .任意字母数字下划线 @ 任意字母数字 .任意字母(2-5位) .任意字母(2-5位) * * \\w&#123;3,&#125; (\\.\\w+)* @ [A-z0-9]+ (\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125; */var emailReg = /^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/;var email = \"crainyday@qq.com\";console.log(emailReg.test(email));//true","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JS内建对象","slug":"JS2-4","date":"2019-04-03T14:24:22.000Z","updated":"2019-10-06T09:42:07.000Z","comments":true,"path":"JS2-4.html","link":"","permalink":"https://blog.crainyday.com/JS2-4.html","excerpt":"JS中的一些其他内建对象","text":"JS中的一些其他内建对象 一.Date1.Date对象的创建 在JS中用Date对象来表示一个时间 Date的无参构造函数会封装当前代码执行时的时间. 以字符串为参数的构造函数, 可以指定Date对象的时间.字符串格式: “月/日/年 时:分:秒” 1234var date1 = new Date();console.log(date1);//输出:计算机系统的当前时间var date2 = new Date(\"01/01/2019 08:01:01\");//\"01-01-2019\"这样也行console.log(date2);//输出:Tue Jan 01 2019 08:01:01 GMT+0800 (中国标准时间) 2.Date的一些方法 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)getMonth() 从 Date 对象返回月份 (0 ~ 11)getFullYear() 从 Date 对象以四位数字返回年份getHours() 返回 Date 对象的小时 (0 ~ 23)。getMinutes() 返回 Date 对象的分钟 (0 ~ 59)getSeconds() 返回 Date 对象的秒数 (0 ~ 59)getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)getTime() 返回(格林威治时间的)1970年1月1日 00:00:00至今的毫秒数, 即时间戳setTime() 以毫秒设置 Date 对象 Date.now() 返回当前的时间戳 1234567891011121314151617var date1 = new Date(\"01-27-2019 08:16:24.100\");console.log(date1.getDate());//输出:27console.log(date1.getDay());//输出:0console.log(date1.getMonth());//输出:0console.log(date1.getFullYear());//输出:2019console.log(date1.getHours());//输出:8console.log(date1.getMinutes());//输出:16console.log(date1.getSeconds());//输出:24console.log(date1.getMilliseconds());//输出:100var date2 = new Date(\"01-01-1970\");console.log(date2.getTime());//中文系统下,我们与格林威治时间相差8h,输出:-28800000date2.setTime(date1.getTime());console.log(date2);//输出:Sun Jan 27 2019 08:16:24 GMT+0800 (中国标准时间)console.log(Date.now());//输出当前时间戳 二.MathMath和其他内置对象不同, 它不能是一个构造函数, 不能创建对象, 它只是一个工具类, 里面封装了一些数学运算中常用的属性和函数. 1.常用属性和函数 Math.PI 返回圆周率(约等于3.14159)abs(x) 返回数的绝对值ceil(x) 对数进行上舍入floor(x) 对数进行下舍入round(x) 把数四舍五入为最接近的整数random() 返回0~1之间的随机数. 生成x~y之间的随机数: Math.round(Math.random()*(y-x)+x);max(x,y) 返回 x 和 y 中的最高值min(x,y) 返回 x 和 y 中的最低值pow(x,y) 返回 x 的 y 次幂sqrt(x) 返回数的平方根 12345678910111213141516console.log(Math.PI);//输出:3.141592653589793console.log(Math.abs(-10));//输出:10console.log(Math.ceil(1.001));//输出:2console.log(Math.ceil(1.999));//输出:2console.log(Math.floor(1.001));//输出:1console.log(Math.floor(1.999));//输出:1console.log(Math.round(1.499));//输出:1console.log(Math.round(1.5));//输出:2for(var i = 0;i &lt; 10;i ++)&#123; //生成10个20-80间的随机数,包括20和100 console.log(Math.round(Math.random()*80+20));&#125;console.log(Math.max(1,10,100));//输出:100console.log(Math.min(1,10,100));//输出:1console.log(Math.pow(2,10));//输出:1024console.log(Math.sqrt(100));//输出:10 三.包装类 回顾: 基本数据类型(Number String Boolean Null Undefined)VS引用数据类型(Object) JS为我们提供了三个包装类(Number String Boolean):&emsp;&emsp;Number—&gt;可以将基本数据类型的Number转换为Number对象&emsp;&emsp;String&emsp;—&gt;可以将基本数据类型的String转换为String对象&emsp;&emsp;Boolean—&gt;可以将基本数据类型的Boolean转换为Boolean对象 但是, 注意: 实际应用时我们一般不会使用基本数据类型的对象, 若使用, 在做比较时可能会带来一些不可预期的结果 方法和属性只能添加给对象, 不能添加给基本数据类型. 当我们调用基本数据类型的属性和方法时, 浏览器会临时使用包装类将其转换为对象, 再调用对象的属性和方法. 包装类一般是浏览器底层自己调用的, 我们一般不会使用它们. 12345678910111213var num = new Number(123);var str = new String(\"hello\");var bool = new Boolean(false);console.log(num == 123);//输出:trueconsole.log(num === 123);//输出:falseif(bool)&#123;//bool是对象,对象转换为Boolean时都会转换为true,所以下述代码会执行 alert(\"我执行了~~~\");&#125;var a = 123;a.hello = \"hello\";//这里会将a临时转换为对象,但执行完该对象便会被销毁,故后面调用会打印undefinedconsole.log(a.hello);//输出:undefinedconsole.log(a.toString(16));//输出:7b 1.数字进制间的转换Number对象有个方法toString()我们常用它来转换进制, 参数为基数 123var num = 123;console.log(num.toString(16));//输出:7dconsole.log(num.toString(2));//输出:1111011 四.String对象的方法 length 属性, 字符串的长度charAt() 返回在指定位置的字符charCodeAt() 返回在指定的位置的字符的 Unicode 编码concat() 连接字符串String.fromCharCode() 从字符编码创建一个字符串, 参数一个或多个Unicode值indexOf() 检索字符串, 有则返回索引, 没有返回-1——–参数:①要检索的字符串, 必需——–②要从哪个位置开始检索, 不传从0开始检索lastIndexOf() 和indexOf类似, 不过这个方法从后向前搜索字符串 slice() 提取字符串的片断, 将指定的字符串封装到新字符串返回——–两个参数:①截取开始位置的索引, 包括开始位置, 可以为负数(-1表示倒数第一个元素)——–②结束位置的索引, 不包括结束位置(该参数可省略, 表示截取之后所有元素), 可以为负数substring() 提取字符串中两个指定的索引号之间的字符——–与splice类似, 但其参数不可为负值, 若传负值, 则默认使用0.——–该方法还会自动调整参数位置, 若第二个参数小于第一个, 则交换两个参数substr() 从起始索引号提取字符串中指定数目的字符——–ECMAscript 没有对该方法进行标准化, 但现今大部分浏览器支持——–两个参数:①截取开始位置索引(可为负数)②(可选参数)要截取字符的数量 split() 把字符串分割为字符串数组——–两个参数:①必需, 字符串或正则表达式, 从该参数指定的地方分割——–②可选, 指定返回的数组的最大长度toLowerCase() 把字符串转换为小写toUpperCase() 把字符串转换为大写 这些方法都不会改变原来的字符串 1.连接检索字符串123456789101112var str = \"hello China,hello World!\";console.log(str.length);//24console.log(str.charAt(23));//!console.log(str.charCodeAt(0));;//104即h的Unicode值console.log(String.fromCharCode(104,101,108,108,111));//helloconsole.log(String.fromCharCode(0x4e2d,0x56fd));//中国console.log(str.concat(\"你好\",\"中国\"));//hello China,hello World!你好中国console.log(str.indexOf(\"hello\"));//0console.log(str.indexOf(\"hello\",1));//12console.log(str.lastIndexOf(\"hello\"));//12console.log(str.indexOf(\"p\"));//-1 2.截取字符串12345var str = \"abcdefghijklmn\";console.log(str.slice(-3,-1));//lmconsole.log(str.substring(1,-1));//负数会默认为0,然后交换参数为0,1;输出:aconsole.log(str.substr(-4,3));//-3开始的三个字符,即:klmconsole.log(str.substr(0));//abcdefghijklmn 3.分割转换字符串12345678910var str = \"Abc,def,ghi,jkL\";var result = str.split(\",\");console.log(Array.isArray(result));//trueconsole.log(result.length);//4result = str.split(\",\",2);console.log(result);//\"Abc\",\"def\"console.log(str.toUpperCase());//\"ABC,DEF,GHI,JKL\"console.log(str);//\"abc,def,ghi,jkl\"","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JS数组","slug":"JS2-3","date":"2019-04-02T13:24:17.000Z","updated":"2019-10-06T09:41:59.000Z","comments":true,"path":"JS2-3.html","link":"","permalink":"https://blog.crainyday.com/JS2-3.html","excerpt":"JS数组(内建对象), 之前都是说的自定义对象.","text":"JS数组(内建对象), 之前都是说的自定义对象. 一.数组简介 数组也是一个对象 它和普通对象的功能类似, 也是用来存储一些值的 不同的是, 普通对象用字符串作为索引, 数组用数字(&gt;=0的整数)作为索引 数组的存储性能比普通对象好, 我们往往常用它来存储一些数据 1.操作数组 ①数组中添加元素, 语法: 变量名[数字索引] = 值; ②读取数组元素, 语法: 变量名[数字索引]; 若读取不存在的索引不会报错, 会返回undefined ③获取数组长度, 变量名.length; 对于连续的数组, 这样可以得到数组长度, 对于不连续的数组这样使用length的值为当前数组的最大索引+1, 尽量不要用不连续的数组. ④人为的设置length, 若设置的length大于原长度, 则多余部分会空出来; 若设置的length小于原长度, 则多余的元素会被删除 ⑤向数组最后一个位置添加索引, 变量名[变量名.length] = 某值; 1234567891011121314151617var arr = new Array();console.log(typeof arr);//输出:objectarr[0] = \"hello\";console.log(arr[0]);//输出:\"hello\"console.log(arr.length);//输出:1arr[5] = 123;console.log(arr);//输出:hello,,,,,123console.log(arr.length);//输出:6console.log(arr[1]);//输出:undefinedarr.length = 1;arr[arr.length] = \"China\";arr[arr.length] = 521;arr[arr.length] = true;console.log(arr);//输出:\"hello\",\"China\",521,true 2.数组字面量 数组字面量创建数组, 语法: [];例: var arr = [1,2,3,4,10];//允许在创建时指定要添加的数组元素 使用数组的构造函数创建数组的同时, 也可以添加元素, 此时将要添加的元素作为参数传递例: var arr = new Array(1,5,6,2,3); 使用数组的构造函数创建数组, 也可以指定数组的初始长度例: var arr = new Array(10); 注意: 数组的元素可以是任意类型的数据 12345678910111213141516171819202122232425var arr1 = [5,9,8,4,3,1];//字面量创建数组var arr2 = new Array(5,9,8,4,3,1);console.log(arr1);//输出:5,9,8,4,3,1console.log(arr2);//输出:5,9,8,4,3,1var arr3 = new Array(10);console.log(arr3);//输出:,,,,,,,,,//数组的元素可以是任意类型的数据var arr4 = [\"hello\",true,123,null,undefined];console.log(arr4);//输出:\"hello\",true,123,null,undefined//可以是对象var obj = &#123;name:\"Bob\"&#125;;arr4[arr4.length] = obj;console.log(arr4[5].name);//输出:Bob//可以是函数arr4[arr4.length] = function()&#123; alert(\"我是数组中的函数\");&#125;;arr4[6]();//调用函数//也可以放数组, 我们叫这种数组为: 二维数组var arr = [[1,2,3],[4,5,6],[7,8,9]];console.log(arr);//输出:1,2,3,4,5,6,7,8,9console.log(arr.length);//输出:3console.log(arr[0].length);//输出:3 二.数组常用方法 pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素, 并返回新的长度shift() 删除并返回数组的第一个元素unshift() 向数组的开头添加一个或更多元素, 并返回新的长度 slice() 从某个已有的数组返回选定的元素——–该方法不会改变原数组, 而是将指定的数组元素封装到新数组中返回, 两个参数:——–①截取开始位置的索引, 包括开始位置, 可以为负数(-1表示倒数第一个元素)——–②截取结束位置的索引, 不包括结束位置(该参数可省略, 表示截取之后所有元素), 可以为负数splice() 删除元素, 并向数组添加新元素——–该方法会改变原数组, 会将指定元素从原数组中删除, 并将删除的元素作为返回值返回——–参数(前两个必需):①开始位置的索引, 可以为负数(-1表示倒数第一个元素)——–②要删除元素的数量——–③第三个参数及以后, 可以传递新元素, 这些元素会自动插入到第一个参数索引的前边 concat() 连接两个或更多的数组, 并返回结果.(不影响原数组)join() 把数组的所有元素放入一个字符串, 元素通过指定的分隔符(默认为逗号)进行分隔.reverse() 颠倒数组中元素的顺序.(影响原数组)sort() 对数组的元素进行排序(影响原数组), 默认按Unicode编码排序 A.pop push shift unshift1234567891011var arr = [\"孙悟空\", \"猪八戒\", \"唐僧\", \"沙和尚\"];var result = arr.pop();console.log(result); //输出:沙和尚result = arr.push(\"白骨精\", \"玉帝\", \"蝎子精\");console.log(result); //输出:6console.log(arr);//输出:孙悟空,猪八戒,唐僧,白骨精,玉帝,蝎子精result = arr.shift();console.log(result);//输出:孙悟空result = arr.unshift(\"牛魔王\", \"红孩儿\", \"铁扇公主\");console.log(result);//输出:8console.log(arr);//输出:牛魔王,红孩儿,铁扇公主,猪八戒,唐僧,白骨精,玉帝,蝎子精 B.slice splice123456789var arr = [\"孙悟空\", \"猪八戒\", \"唐僧\", \"沙和尚\"];var result = arr.slice(-3,-1);console.log(result);//输出:猪八戒,唐僧result = arr.slice(-3);console.log(result);//输出:猪八戒,唐僧,沙和尚result = arr.splice(1,0,\"玉帝\",\"佛祖\");console.log(result);//输出:\"\"console.log(arr);//输出:孙悟空,玉帝,佛祖,猪八戒,唐僧,沙和尚 例: 数组去重练习 12345678910var arr = [1,1,2,2,3,5,4,4,6,8,2,1,3,2];for(var i = 0;i &lt; arr.length;i ++)&#123; for(var j = i+1;j &lt; arr.length;j ++)&#123; if(arr[i] == arr[j])&#123; arr.splice(j,1); j--; &#125; &#125;&#125;console.log(arr);//输出:1,2,3,5,4,6,8 C.concat join123456789var arr1 = [\"孙悟空\",\"猪八戒\",\"沙和尚\"];var arr2 = [\"白骨精\",\"高玉兰\",\"玉兔精\"];var result = arr1.concat(arr2,\"牛魔王\",\"红孩儿\");console.log(result);//输出:\"孙悟空\",\"猪八戒\",\"沙和尚\",\"白骨精\",\"高玉兰\",\"玉兔精\",\"牛魔王\",\"红孩儿\"var str = result.join();console.log(str);//输出:\"孙悟空,猪八戒,沙和尚,白骨精,高玉兰,玉兔精,牛魔王,红孩儿\"str = result.join(\"\");//分隔符为\"\"console.log(str);//输出:\"孙悟空猪八戒沙和尚白骨精高玉兰玉兔精牛魔王红孩儿\" D.reverse sort ①sort方法, 默认按照Unicode编码排序, 对于数字的排序往往不是我们想要的结果, 这时我们就需要按照我们自己想要的排序方式, 编写一个回调函数传递给sort().②sort的回调函数有两个形参, 代表要比较的数组中的两个元素, 第一个形参代表的元素相对于第二个靠前③sort方法根据回调函数的返回值排序.④参数为回调函数的函数, 我们一般用匿名方式传递参数 123456var arr = [2,5,7,3,1,6,9,8,4];arr.sort(function(a,b)&#123; //return a-b;//升序 return b-a;//逆序&#125;);console.log(arr); 三.遍历数组1.for循环遍历123456789101112131415161718192021222324252627//遍历数组, 就是将数组的元素取出来使用function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.toString = function ()&#123; return \"Person[name:\"+this.name+\",age:\"+this.age+\",sex:\"+this.sex+\"]\";&#125;;var nameArr = [\"孙悟空\",\"沙悟净\",\"猪悟能\",\"唐玄奘\",\"白骨精\",\"玉兔精\",\"蜘蛛精\"];var ageArr = [18,28,38,17,16,15,14];var sexArr = [\"男\",\"男\",\"男\",\"男\",\"女\",\"女\",\"女\"];var personArr = new Array(7);for(var i = 0;i &lt; personArr.length;i ++)&#123; personArr[i] = new Person(nameArr[i],ageArr[i],sexArr[i]); console.log(personArr[i]);&#125;/* 输出:Person[name:孙悟空,age:18,sex:男]Person[name:沙悟净,age:28,sex:男]Person[name:猪悟能,age:38,sex:男]Person[name:唐玄奘,age:17,sex:男]Person[name:白骨精,age:16,sex:女]Person[name:玉兔精,age:15,sex:女]Person[name:蜘蛛精,age:14,sex:女]*/ 练习: 自定义一个函数, 将上述对象数组中person对象age属性大于等于18的对象放入一个新数组, 并将该新数组作为函数的返回值返回. 123456789function getAdult(perArr)&#123; var arr = new Array(); for(var i = 0;i &lt; perArr.length;i ++)&#123; if(perArr[i].age&gt;=18)&#123; arr.push(perArr[i]); &#125; &#125; return arr;&#125; 2.数组的for Each()方法遍历 ①该方法适用于IE 8.0+②该方法需要一个函数作为参数, 我们称此函数为回调函数, 这种函数由我们创建, 但是我们不负责调用③我们写回调函数时一般都以匿名形式给出④数组中有几个元素, 该方法会执行几次, 该方法的调用者会将在数组中遍历到的元素以实参形式传递进函数, 我们可以定义形参来接收它们⑤该函数被调用时会传递三个参数: 第一个, 当前正在遍历的元素;第二个, 当前正在遍历元素的索引;第三个, 正在遍历的数组. 1234567891011121314151617181920212223//接上上述代码personArr.forEach( function (per,index,perArr)&#123; console.log(perArr[index] == per);//全是true console.log(per); &#125;);/* 结果:truePerson[name:孙悟空,age:18,sex:男]truePerson[name:沙悟净,age:28,sex:男]truePerson[name:猪悟能,age:38,sex:男]truePerson[name:唐玄奘,age:17,sex:男]truePerson[name:白骨精,age:16,sex:女]truePerson[name:玉兔精,age:15,sex:女]truePerson[name:蜘蛛精,age:14,sex:女]*/ 四.数组相关的常用方法 详见：数组常用方法","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JS对象补充","slug":"JS2-2","date":"2019-04-01T12:28:55.000Z","updated":"2019-10-06T09:41:51.000Z","comments":true,"path":"JS2-2.html","link":"","permalink":"https://blog.crainyday.com/JS2-2.html","excerpt":"JS对象补充","text":"JS对象补充 一.工厂方法创建对象123456var obj = &#123; name:, age:, sex:, showMes:&#125;; &emsp;&emsp;我们想要创建大量的上面的obj对象, 它们的属性名都一样, 但是值可能不一样, 这时, 为了”偷懒”, 我们可以使用工厂方法创建对象. 批量生产对象. 1234567891011121314151617181920212223242526272829303132function createPerson(name, age, sex) &#123; var obj = &#123; name: name, age: age, sex: sex, showMes: function() &#123; alert(name); &#125; &#125;; return obj;&#125;var per1 = createPerson(\"孙悟空\", 500, \"男\");console.log(per1);//Object &#123;name: \"孙悟空\", age: 500, sex: \"男\", showMes: ƒ&#125;var per2 = createPerson(\"猪八戒\", 300, \"男\");console.log(per2);//Object &#123;name: \"猪八戒\", age: 300, sex: \"男\", showMes: ƒ&#125;var per3 = createPerson(\"白骨精\", 500, \"女\");console.log(per3);//Object &#123;name: \"白骨精\", age: 500, sex: \"女\", showMes: ƒ&#125;per1.showMes();//孙悟空per2.showMes();//猪八戒per3.showMes();//白骨精function createDog(name, age) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.showMes = function()&#123; alert(this.name); &#125;; return obj;&#125;var dog = createDog(\"哮天犬\",3);console.log(dog);//Object &#123;name: \"哮天犬\", age: 3, showMes: ƒ&#125;dog.showMes();//哮天犬 二.构造函数 从上面代码的注释中, 可以看见我们用工厂方法创建的对象都是Object类型的, 不易区分不同的对象(到底是Dog还是Person), 这时, 我们可以创建一个构造函数来专门创建某一类对象. 构造函数是一类特殊的普通函数, 习惯上我们将构造函数的函数名首字母大写. 构造函数与普通函数相比, 调用方式不同, 普通的直接调用即可, 构造函数需要在new关键字之后调用. 使用同一个构造函数创建的对象, 我们称为一类对象, 也将构造函数称为类, 将它创建的对象称为类的实例. 构造函数的执行流程: 被调用时, 首先创建一个新的对象 将函数中的this指向新建的对象(即在构造函数中, 可以用this来引用正在新建的对象) 逐行执行构造函数中的代码 将新建的对象作为构造函数的返回值返回. A.instanceof用法: 对象 instanceof 构造函数, 检查一个对象是否为一个构造函数的实例, 是返回true, 不是返回false. 1234567891011121314151617function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex; this.showMes = function()&#123; alert(this.name); &#125;;&#125;var per1 = new Person(\"孙悟空\", 500, \"男\");console.log(per1);//Person &#123;name: \"孙悟空\", age: 500, sex: \"男\", showMes: ƒ&#125;var per2 = new Person(\"猪八戒\", 300, \"男\");console.log(per1);//Person &#123;name: \"猪八戒\", age: 300, sex: \"男\", showMes: ƒ&#125;var per3 = new Person(\"白骨精\", 500, \"女\");console.log(per1);//Person &#123;name: \"白骨精\", age: 500, sex: \"女\", showMes: ƒ&#125;console.log(per1 instanceof Person);//trueconsole.log(per1.showMes == per2.showMes);//false 上面的代码有一个弊端, 每一个由Person创建的对象都有一个自己的showMes()方法 console.log(per1.showMes == per2.showMes);//false 返回结果是false, 而这不是我们想要的, 这样的话会浪费很多的内存.故修改一下, 将该函数的声明放到外面 1234567891011121314function showMes()&#123; alert(this.name);&#125;function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex; this.showMes = showMes;&#125;var per1 = new Person(\"孙悟空\", 500, \"男\");var per2 = new Person(\"猪八戒\", 300, \"男\");var per3 = new Person(\"白骨精\", 500, \"女\");console.log(per1.showMes == per2.showMes);//true 三.原型对象 注意: 上述改进, 将对象共有的方法showMes()直接声明在全局作用域中, 也是存在一些弊端, ①污染了全局作用域(在全局作用域中不能再添加同名函数)②不是很安全. 因此, 这次我们采用一个非常好的办法, 即解决多个同类对象创建多个公共的方法, 又不会对全局作用域造成污染. 原型: prototype 我们创建的每一个函数, 解析器都会向函数中添加一个属性prototype, 这个属性对应着一个对象即原型对象 如果函数作为普通函数调用prototype没有任何作用 如果函数以构造函数的形式调用时,它创建的对象中都会有一个隐含的属性, 指向该构造函数的原型对象, 我怕们可以用对象的__proto__属性来访问该对象 原型对象就相当于一个公共的区域, 所有同一个类的实例都能访问到这个对象, 我们可以将对象中共有的内容统一放到原型对象中. 当我们访问一个对象的属性或方法时, 它会先在对象自身寻找, 如果有则直接使用, 若没有则会去原型对象中寻找, 如果原型对象中有则直接使用 改进如下: 1234567891011121314function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.showMes = function()&#123; alert(this.name);&#125;;var per1 = new Person(\"孙悟空\", 500, \"男\");var per2 = new Person(\"猪八戒\", 300, \"男\");var per3 = new Person(\"白骨精\", 500, \"女\");console.log(Person.prototype == per1.__proto__);//trueconsole.log(per1.showMes == per2.showMes);//true A.检查对象的属性 1.之前提到过用in运算符检查对象中是否包含某个属性, 但这样, 如果对象的原型对象中有这个属性, 也会返回true, 显然这不是我们想得到的结果. 2.我们只想在对象本身的属性中搜索. 这时候可以用对象的hasOwnProperty()方法检查. hasOwnProperty方法其实在原型对象的原型中 3.原型对象也是对象, 它也有原型. 我们调用一个对象的属性或方法时, 会先在对象自身寻找, 没有就去对象的原型中寻找, 还没有就去原型的原型中寻找, 直到找到Object对象的原型, 没有则返回undefined 4.Object对象的原型没有原型, 它的值为null 1234567891011121314function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.showMes = function()&#123; alert(this.name);&#125;;Person.prototype.a = 123;var per = new Person(\"孙悟空\", 500, \"男\");console.log(\"a\" in per);//trueconsole.log(per.hasOwnProperty(\"a\"));//falseconsole.log(per.__proto__.__proto__.hasOwnProperty(\"hasOwnProperty\"));//true 四.toString()123456789101112function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.showMes = function() &#123; alert(this.name);&#125;;var per = new Person(\"孙悟空\", 500, \"男\");console.log(per);//输出:[object Object]console.log(Object.__proto__.hasOwnProperty(\"toString\"));//输出:true 我们直接在页面打印对象的引用时, 实际上调用了对象的toString()方法, 打印的是toString()的返回值, 默认调用的是Object原型的toString()方法. 假如我们想打印对象时, 按照我们自己的想法控制输出的内容, 我们就需要显示的添加一个toString()方法, 不让当前的对象向原型中搜寻方法. 12345678910function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.toString = function() &#123; return \"Person[name:\"+this.name+\",age:\"+this.age+\",sex:\"+this.sex+\"]\";&#125;;var per = new Person(\"孙悟空\", 500, \"男\");console.log(per);//Person[name:孙悟空,age:500,sex:男] 五.垃圾回收(GC) 程序运行过程中也会产生垃圾, 若垃圾过多, 会使程序运行过慢, 因此我们需要一个垃圾回收机制来处理程序运行过程中产生的垃圾. 当一个对象没有任何变量或属性对它进行引用, 我们将永远无法操作该对象, 这种对象就是垃圾. 在JS中拥有自动的垃圾回收机制, 会自动将垃圾对象从内存中销毁, 我们不需要也不能进行垃圾回收的操作. 假如我们不再使用某个对象的引用, 将它设置为null即可","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JS函数","slug":"JS2-1","date":"2019-03-31T14:17:35.000Z","updated":"2019-10-06T09:41:43.000Z","comments":true,"path":"JS2-1.html","link":"","permalink":"https://blog.crainyday.com/JS2-1.html","excerpt":"JS的函数function","text":"JS的函数function 一.JS函数的简介函数(function): 函数也是一个对象 函数中封装了一些功能(代码), 在需要时可以执行这些功能(代码) 封装到函数的代码不会立即执行, 只有调用时才会执行 调用函数时代码顺序执行, 调用语法: 函数对象() 使用typeof检查一个函数对象时, 会返回function A.创建一个函数对象 将要封装的代码以字符串形式传递给构造函数, 例: 1234var fun = new Function(\"console.log('这是我的第一个函数~~~')\");fun['value'] = \"123\";//函数是对象, 也可以像对象那样用, 但我们一般不这样用fun();//这样调用函数//实际编程中我们很少用这种方式创建一个函数 使用函数声明来船舰一个函数(对象), 格式: 123function 函数名([形参1,形参2,形参3,...,形参n])&#123; //代码...&#125; 使用函数表达式创建一个函数, 格式: 123var 函数名 = function([形参1,形参2,形参3,...,形参n])&#123; //代码...&#125; B.参数 在函数的()中, 可以指定0个或多个形参 多个形参之间用逗号隔开, 声明了形参就相当于在函数内部声明了对应的变量 声明的形参并没有被赋值 调用函数时, 可以在()中指定实参, 实参的值会依次赋值给形参 调用函数时, 解析器不会检查形参与实参的数量是否匹配 函数的实参可以是任何类型的值, 包括基本类型、对象、函数(对象). 特别注意: 调用函数时, 解析器也不会检查实参的类型, 所以要检查一下参数是否合法 例题: 定义一个能求两个数和的函数 12345678910111213141516171819202122function sum(a,b)&#123; if((typeof a) == \"number\"&amp;&amp;(typeof b) == \"number\")&#123; console.log(a+b); &#125;&#125;sum(123,456);sum(123,\"456\");//不输出内容function show(obj) &#123; console.log(\"我是\" + obj.name + \",性别\" + obj.sex + \",我今年\" + obj.age + \"岁了\");&#125;var person = &#123; name:\"孙悟空\", sex:\"男\", age:500&#125;;//函数实参为对象show(person);function fun(a)&#123; a(person);&#125;//函数实参为函数(对象),将max赋值给了a,故a(person);与show(person);等价fun(max); C.返回值 在函数中, 可以用return关键字返回一个表达式的值 可以在调用函数处, 声明一个变量接收该函数的返回值 若函数中不写return或没有return一个值, 则会默认return undefined; return语句之后的代码不会被执行 函数的返回值也可以是任意类型的值, 基本类型、对象、函数 例: 定义一个能求两个数最大值的函数, 并将最大值返回. 1234567891011121314151617181920212223242526function max(a,b)&#123; if((typeof a) == \"number\"&amp;&amp;(typeof b) == \"number\")&#123; return a&gt;b?a:b; &#125;&#125;var maxNum = max(123,456);console.log(maxNum);function fun(a)&#123; console.log(\"a = \" + a);&#125;//函数实参为函数(对象)fun(max);//函数实参为函数的返回值fun(max(123,456));function fun2()&#123; //return &#123;name:\"孙悟空\"&#125;;//返回一个对象 function fun3()&#123; alert(\"我是fun3函数\"); &#125; //return fun3();//这样是返回fun3函数的返回值 return fun3;//返回fun3这个函数&#125;var f = fun2();//此时f为fun3f();//调用fun3函数fun2()();//和f();等价,也是调用fun3()函数 D.立即执行函数 函数定义完, 立即就会被调用 这种函数往往是匿名函数, 只会执行一次.例: 12345//先用一对小括号将匿名函数括起来,表示是一个整体,否则不允许这样声明函数(function(a, b) &#123; console.log(\"a = \" + a); console.log(\"b = \" + b);&#125;)(123, 456); E.方法(method) 一类特殊的函数, 这类函数是对象的属性 若一个函数成了对象的一个属性, 那这个函数就叫做对象的方法 调用函数就叫做调用的对象的某方法 12document.write(\"Hello\");//调用document对象的write方法console.log(\"Hello\");//调用console对象的log方法 二.作用域(Scope)A.全局作用域 直接编写在script标签中的JS代码, 都在全局作用域中 全局作用域在页面打开时创建, 在页面关闭时销毁 全局作用域中有一个全局对象window, 它代表一个浏览器窗口, 由浏览器创建, 我们可以直接使用 全局作用域中我们创建的变量都会作为window对象的属性保存, 函数作为window的方法 全局作用域里的变量都是全局变量, 在页面的任何部分都能访问到 变量的声明提前: 使用var声明的变量, 会在所有的代码执行之前被声明(但不会被赋值)但声明变量时不使用var, 则变量不会被提前声明函数的声明提前: 使用函数声明的形式创建的函数 function 函数名(){}会在所有代码执行前被创建, 所以我们可以在函数声明前调用它.但是用函数表达式创建的函数 var fun = function(){};不会被声明提前, 所以不能在声明前调用. 12345678910console.log(a);//输出:undefinedvar a = 10;//去掉var之后, 第一行报错fun();function fun()&#123; console.log(\"我是fun\");&#125;var fun1 = function()&#123; console.log(\"我是fun1\");&#125;;fun1();//只能在这之后调用, 否则会报错. B.函数作用域 函数被调用时, 创建自己的函数作用域, 函数执行完毕, 函数作用域销毁 每调用一次函数, 创建一个新的函数作用域, 作用域之间互相独立 函数作用域中可以访问到全局变量, 但全局作用域无法访问到局部变量 在函数中操作一个变量时, 首先在自身作用域中寻找, 没有的话向上一级寻找 函数中想使用全局变量, 可以使用window.变量名 函数的形参相当于在函数作用域中声明的. 也存在声明提前的问题, 但提前声明于当前作用域 三.debug这种调试, 可以查看执行过程中内存的状态, 各变变量的情况. 123456789alert(d);//声明提前var a = 10;var b = 15;c = 20;//不要监视c可能会出错卡死function fun()&#123; console.log(\"我是fun\");&#125;var d = 25; 先打开, 浏览器的开发者工具, 以chrome为例, 按F12, 选择sources, 之后如下图: 其他浏览器类似 四.this你可以这样理解: &emsp;&emsp;解析器在调用函数时每次都会向函数内部传递一个隐含的参数this, this指向一个对象, 这个函数我们称为函数执行的上下文对象, 根据函数的调用方式不同, this会指向不同的对象 123456789101112131415function fun()&#123; console.log(this.name + \" \" + this);&#125;fun();//这时this指向window对象,this.name=\"全局的name\";var name = \"全局的name\";var obj = &#123; name:\"孙悟空\", show:fun&#125;;obj.show();//这时this指向obj, this.name=\"孙悟空\";var obj1 = &#123; name:\"猪八戒\", show:fun&#125;;obj1.show();//这时this指向obj1, this.name=\"猪八戒\"; 五.call()和apply() 这两个方法都是函数对象的方法, 需要通过函数对象来调用 当函数对象调用call()和apply()方法时, 函数中的代码也会执行. 可以将一个对象指定为call和apply的第一个参数, 这个对象将会成为函数执行时的this call()方法, 将函数原本的实参在第一个参数(对象)以后依次传递给函数的形参 apply()方法, 将函数原本的实参封装到一个数组统一传递. 12345678910111213141516171819202122function fun()&#123; console.log(this);&#125;var obj1 = &#123;name:\"obj1\",show:function()&#123; console.log(this.name);&#125;&#125;;var obj2 = &#123;name:\"obj2\"&#125;;fun();//输出:windowfun.call(obj1);//输出:objectfun.apply(obj2);//输出:objectobj1.show();//输出:obj1obj1.show.call(obj2);//输出:obj2function fun2(a,b)&#123; console.log(\"a = \"+a); console.log(\"b = \"+b);&#125;fun2.call(obj1,1,2);//将参数依次传递fun2.apply(obj1,[1,2]);//将参数封装成数组统一传递 this的情况: 在函数中调用时, this永远指window 在方法中调用时, this是调用方法的对象 在构造函数中调用时, this是正在创建的对象 使用call和apply调用时, this是参数传递过来的对象 六.arguments 在调用函数时, 浏览器都会传递进两个隐含的参数:①函数的上下文对象:this②封装实参的对象: arguments, 我们传递的实参都保存在里面 arguments是一个类数组对象, 它不是数组, 但是它也可以通过数字索引来操作数据. arguments.length可以获取实参的长度, 我们即使没定义形参, 也可以通过arguments来使用形参, 但这样比较麻烦 arguments[0]表示第一个实参, 以此类推. arguments.callee属性, 表示当前的函数对象 12345678function fun()&#123; console.log(arguments instanceof Array);//判断arguments是不是数组,输出:false console.log(Array.isArray(arguments));//判断arguments是不是数组,输出:false console.log(arguments.length);//输出:4 console.log(arguments[3]);//输出:true console.log(arguments.callee == fun);//输出:true&#125;fun(\"one\",\"two\",3,true);","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JS对象简介","slug":"JS2-0","date":"2019-03-30T13:08:10.000Z","updated":"2019-10-06T09:41:34.000Z","comments":true,"path":"JS2-0.html","link":"","permalink":"https://blog.crainyday.com/JS2-0.html","excerpt":"JS的Object类型","text":"JS的Object类型 一.Object对象Object类型, 我们也称为一个对象. 是JavaScript中的引用数据类型. 它是一种复合值, 它将很多值聚合到一起, 可以通过名字访问这些值. 对象也可以看做是属性的无序集合, 每个属性都是一个名/值对. 对象除了可以创建自有属性, 还可以通过从一个名为原型的对象那里继承属性. 除了字符串、数字、true、false、null和undefined之外, JS中的值都是对象. 对象可以说是对一些名值对的封装 A.对象的分类: 内建对象: 由ES标准制定的对象, 在任何ES的实现中都能使用 比如: Math String Number Boolean Function Object…… 宿主对象: 由JS的运行环境提供的对象, 目前主要指浏览器提供的对象 比如: BOM DOM 自定义对象(最难): 由开发人员自己创建的对象 二.创建自定义对象访问属性的两种方式: 用 . 访问: 对象.属性名 用 [] 访问: 对象[‘属性名’], 这样操作属性更灵活, 常用于操作一些特殊的属性名 属性名的命名方式, 建议按照标识符的规范去做; 属性值可以是任意类型的值, 甚至是一个对象. 12345678910111213141516171819//方式一:先创建对象, 再添加属性var person = new Object();person.name = \"孙悟空\";//添加name属性person.age = 18;//添加age属性person.name = \"牛魔王\";//修改属性delete person.name;//删除属性console.log(person.name);//读取属性, 如果读取不到对象的属性会返回undefined//方式二:创建对象的同时添加属性, 这种叫做对象字面量var sex = \"男\";var person1 = &#123; name: \"孙悟空\", age: 18, \"123\": 789//最后一个属性后一定不能加逗号&#125;;person1[sex] = sex;console.log(person1[sex]);var index = '123';console.log(person1['123']);//person1.123是不允许的console.log(person1[index]);//与person1['123']等价 三.in运算符通过该运算符检查对象是否有某个属性, 有则返回true, 没有返回false. 格式: “属性名” in object, 例: 123456var person = &#123; name: \"孙悟空\", age: 18, \"123\": 789&#125;;console.log(\"obj\" in person); 四.数据类型基本数据类型&amp;引用数据类型 基本数据类型: Number String Boolean Null Undefined 基本数据类型的值是无法修改的, 是不可变的. 基本数据类型的比较是值的比较, 也就是只要两个变量的值相等, 我们就认为这两个变量相等. 引用数据类型: Object 当一个变量是一个对象时, 实际上变量中保存的并不是对象本身, 而是对象的引用(堆内存中对象的地址). 当从一个变量向另一个变量复制引用类型的值时, 会将对象的引用复制到变量中, 并不是创建一个新的对象. 这时, 两个变量指向的是同一个对象. 因此, 改变其中一个变量会影响另一个 对比如下代码即结果, 有什么区别? 123456789101112131415161718var a = 123;var b = a;a ++;console.log(\"a = \" + a + \";b = \" + b);var obj = &#123; name:\"孙悟空\", birth:&#123; year:1998, month:10, day:8 &#125;&#125;;var obj2 = obj;obj2.name = \"牛魔王\";console.log(\"obj.name = \" + obj.name + \"; obj2.name = \" + obj2.name);//obj2 = null;//若执行obj2 = null;那obj2不再指向任何内容, 如下命令会出错obj2.name = \"猪八戒\";console.log(obj == obj2);//引用数据类型比较的是地址 JS运行时, 基本类型的变量直接存在栈空间; 引用类型的实体(即对象)保存在堆空间, 变量中保存的实际上对象在堆内存中的地址. 以上代码在内存中的情况如下: 五.for…in语句 在开发过程中, 我们往往会使用别人给我们提供好的对象 但我们不知道对象里有什么属性 这时就用到了for…in语句来遍历对象的属性 例: 123456789101112var obj = &#123; name:\"CRD\", sex:\"男\", age:20, nation:\"中国\", sayHello:function()&#123; console.log(\"你好\"); &#125;&#125;;for(var index in obj)&#123;//这里不能用obj.index来操作属性 console.log(\"名:\" + index + \";值:\" + obj[index]);&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JS流程控制","slug":"JS1-2","date":"2019-03-29T15:56:03.000Z","updated":"2019-10-06T09:41:25.000Z","comments":true,"path":"JS1-2.html","link":"","permalink":"https://blog.crainyday.com/JS1-2.html","excerpt":"JS的基本语法: 流程控制","text":"JS的基本语法: 流程控制 条件判断语句 if-else 条件分支语句 switch-case 循环语句 for while 一.if-else12345678910111213141516171819//①if(条件表达式)&#123; &#125;//②if(条件表达式)&#123; //执行的语句1;&#125;else&#123; //执行的语句2;&#125;//③if(条件表达式1)&#123; //执行的语句1;&#125;else if(条件表达式2)&#123; //执行的语句2;&#125;else if( 条件表达式3)&#123; //执行的语句3;&#125;...&#123;&#125;else&#123; //执行的语句;&#125; [注意] 一旦满足某个条件表达式, 则进入其执行语句块执行, 执行完毕, 跳出当前的条件判断结构, 不会执行剩下的条件结构语句. 如果多个条件表达式之间为“互斥”关系, 多个结构可以上下调换顺序.如果多个条件表达式之间为“包含”关系, 要求条件表达式范围小的写在范围大的上面. 二.switch-case123456789switch(变量)&#123; case 值1: //break; case 值2: //break; ... default: break;&#125; 1.case后只能填写变量的值, 不能写范围.2.default是可以省略的, 并且其位置也是灵活的, 但通常将其放在case语句之后.3.一旦满足某个case语句, 则进入执行其操作, 直至遇到break或者程序终止.4.若要判断的语句的条件满足switch变量的数据类型, 且值不多的情况下, 建议选择switch-case .除此之外, 选择if-else. 三.循环语句格式:①初始化条件②循环条件③迭代部分④循环体 123456789101112131415for(①;②;③)&#123; ④&#125;//①while(②)&#123; ④ ③&#125;//①do&#123; ④ ③&#125;while(②); 注意 1.不同的循环结构之间可以相互转换 2.while和do-while的区别; do-while程序至少会执行一次 嵌套循环: 上述循环体嵌套循环体若外层循环执行m次, 内层循环执行n次, 整个程序执行m*n次 . 无限循环结构: 我们往往会在无限循环结构内部提供循环的终止条件, 使用break关键字跳出循环.避免死循环. 123456789101112131415for(;;)&#123; ... if( )&#123; break; &#125; ...&#125;//或者while(true)&#123; ... if( )&#123; break; &#125; ...&#125; break&amp;continue使用switch-case结构或者循环结构中在循环结构中, 一旦执行到break, 就跳出当前循环 . continue:使用在循环结构中, 一旦执行到continue, 就跳出当次循环, 继续执行下一次循环. 1234567for(var i = 1;i &lt;= 10;i++)&#123; if(i % 4 == 0)&#123; //break; //程序执行结果:123 continue; //程序执行结果:123567910 &#125; console.log(i);&#125; 在嵌套循环中, 使用带标签的break和continue. 1234567891011label:for(var i = 1;i &lt; 5;i++)&#123; for(var j = 1;j &lt;= 10;j++)&#123; if(j % 4 == 0)&#123; //break; //continue; //break label; continue label; &#125; console.log(j); &#125;&#125; 例题: 求100以内的素数 1234567891011121314var n = 100;for(var i = 2;i &lt;= n;i ++)&#123; var m = Math.floor(Math.sqrt(i)); var flag = true; for(var j = 2;j &lt;= m;j ++)&#123; if(i % j == 0)&#123; flag = false; break; &#125; &#125; if(flag)&#123; console.log(i); &#125;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JS基础语法","slug":"JS1-1","date":"2019-03-29T15:55:58.000Z","updated":"2019-10-06T09:41:17.000Z","comments":true,"path":"JS1-1.html","link":"","permalink":"https://blog.crainyday.com/JS1-1.html","excerpt":"JS基础语法","text":"JS基础语法 一.JS注释 和其他高级语言差不多, 分为: 多行注释: /**/ 单行注释: // 注释中的代码不会被执行, 只能在源码中看见注释的内容 二.JS的变量与字面量变量的作用是给某一个值或对象标注名称, 方便复用, 变量也用来保存字面量 字面量: 可以直接使用, 不能更改其值, 像: 123、”Hello”、1.23等 变量的声明: 使用var关键字声明一个变量, 例: var a; 变量的赋值: 使用=为变量赋值, 例: a=123; 声明和赋值同时进行, 例, var a = 123; 三.JS标识符所谓标识符, 就是指变量、函数、属性的名字, 或函数的参数.要求: 第一个字符必须是一个字母、下划线_或一个美元符号$. 不能以数字开头, 不能是关键字或保留字 其他字符可以是字母、下划线、美元符号或数字. 标识符一般采用驼峰命名法(规范): 首字母小写, 每个单词首字母大写其他字母小写, 例: xxxYyyZzz JS底层保存标识符是用Unicode编码的 命名时, 尽量见名知意, 遵守它的规则和行业规范. 四.数据类型 String(字符串型), 例: “Hello World”或’Hello World’ Number(数值型), 例: 123、1.23 Boolean(布尔型), 只有 true false两个取值 Null(null型), 只有一个取值: null, 用来表示一个对象为空; 用 typeof null;会返回object Undefined(undefined型), 未定义, 当声明了一个变量而没赋值时, 变量的值就是undefined 上述五种基本类型之外的类型: Object String: 使用单或双引号括起来的整体, 但是单双引号不能嵌套. 了解一些常见的转义字符 Number: 正无穷(Infinity), 负无穷(-Infinity); Nut a Number(NaN) 尽量避免用JS做一些高精度的计算问题 用typeof运算符可以检查变量的类型, 例: 12345678910var a = 123;console.log(typeof a);//输出结果为:numbervar b = Number.MAX_VALUE + 1;console.log(b);//输出结果为:Infinityvar c = Number.MIN_VALUE;//JS能表示的大于零的最小值//Number有它能表示的最大值, 为Number.MAX_VALUE;//当计算结果超过它时, 输出结果为:Infinity(number型)即正无穷var str = \"123\" * \"123\";//当计算结果非数字时, 会返回一个NaN(number型)console.log(typeof str);//结果为:NaN 五.强制类型转换 其他类型变量转换为String, 调用变量的toString()方法, 或调用String()函数 其他类型变量转换为Number, 调用Number()函数, 对于字符串还可调用parseInt()或parseFloat()函数 其他类型变量转换为Boolean, 调用Boolean()函数 点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738//其他类型变量转换为Stringvar a = 123;//注意:当a = null;或a = undefined;时, 不能调用a.toString()方法a = a.toString();//toString()方法, 无参数, 将a的内容变为string后返回var b = null;b = String(b);//String()函数, 将要转换的变量作为参数传递给函数, 后函数将结果返回console.log(\"a = \" + a);console.log(typeof a);//输出:stringconsole.log(\"b = \" + b);console.log(typeof b);//其他类型变量转换为Numbervar str = \"123\";//若字符串内容有非数字和空格, Number()函数会将内容转换为NaNstr = Number(str);console.log(\"str = \" + str);console.log(typeof str);var bool = true;//true==&gt;1 false==&gt;0 null==&gt;0 undefined==&gt;NaNbool = Number(bool);console.log(\"bool = \" + bool);console.log(typeof bool);var px = \"123px\";px = parseInt(px);//从第一个字符开始转换, 直到遇到非空和非数字.parseFolat()函数类似console.log(\"px = \" + px);console.log(typeof px);//JS中数字的进制, 0x开头表示16进制, 0开头表示8进制px = \"070\";px = parseInt(px,10);//第二个参数, 表示以几进制进行解析console.log(\"px = \" + px);console.log(typeof px);//其他类型变量转换为Booleanvar num = 123;//数字只有0和NaN转换为false, 字符串只有空串转换为falsenum = Boolean(num);//null和undefined转换为false, 对象都转换为trueconsole.log(\"num = \" + num);console.log(typeof num);//这里说一个isNaN()函数, 判断一个数字是不是NaN, 若是返回true, 不是返回falseconsole.log(isNaN(num)); 六.运算符 算术运算符 + - * / ++(前置和后置) –(前置和后置) +(符号不变) -(符合取反) %(取模) 逻辑运算符 &amp;&amp; || ! &amp; | 关系运算符 &gt; &lt; &gt;= &lt;= == != === !== 赋值运算符 = += -= *= /= %= 条件运算符 ?:, 格式: 条件表达式?表达式1:表达式2; 若条件表达式为true, 整个表达式值为表达式1的值, 否则为表达式2的值. 位运算符 ^ &amp; | ! (用于数值类型的操作) typeof运算符 判断类型并以字符串形式返回 A.算术运算符:+的特殊性, 可以用来拼接字符串, 例: 12var a = 1 + 2 + \"3\";//33var b = \"1\" + 2 + 3;//123 其他算数运算符在进行运算时, 会将操作数先转换为Number类型, 再进行运算, 并将结果以数值类型返回 前++: 先对原变量加1, 在使用该变量的值;后++: 先使用给变量的值, 再给变量加1;–类似 B.逻辑运算符与 或 非, 运算时将其他类型转换为Boolean型, 再运算; 注意短路与(&amp;&amp;)和短路或(||): 短路与: 若第一个值为true, 则返回第二个值; 若第一个值为false, 则返回第一个值; 短路或: 若第一个值为true, 则返回第一个值; 若第一个值为false, 则返回第二个值; C.关系元算符比较两个字符串时, 比较的是字符串的字符编码(按位比较); 其他类型转换为数值类型比较; 比较结果为true或false, 以字符串形式返回比较的结果. 注意==判等时会做隐式类型转换, ===表示全等; != 与 !==一样 D.赋值运算符将运算符左边的表达式的值做一个操作, 然后将操作后的值赋值给右边的变量. 七.Unicode编码表在JS的字符串中, 使用转义字符\\u+四位16进制的编码表示Unicode编码 在HTML中, 使用 “&amp;#10进制编码;” 表示Unicode编码. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;JS基础&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var str = \"\\u2620\"; console.log(str); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&amp;#9760;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 注意: JS中严格区分大小写(HTML中不区分) JS中一个分号代表一条命令的结束 JS会忽略多个空格与换行符, 因此我们可以用来格式化自己的代码 JS代码是一条条以;结尾的语句, 可用{}将语句分组, 一个{}也叫一个代码块","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JS简介","slug":"JS1-0","date":"2019-03-29T15:55:39.000Z","updated":"2019-10-06T09:41:08.000Z","comments":true,"path":"JS1-0.html","link":"","permalink":"https://blog.crainyday.com/JS1-0.html","excerpt":"JavaScript简介","text":"JavaScript简介 一.起源 JavaScript诞生于1995年, 它的出现主要是用于处理网页中的前端验证. 所谓的前端验证, 就是指检查用户输入的内容是否符合一定的规则. 比如: 用户名的长度，密码的长度，邮箱的格式等. 二.JavaScript构成 ECMAScript(JS的标准) DOM(JS操作网页) BOM(JS操作浏览器) 三.JS的特点 解释型语言 类似于 C 和 Java 的语法结构 动态语言 基于原型的面向对象 JavaScript是一门解释型语言, 所谓解释型值语言不需要被编译为机器码在执行, 而是直接执行. JavaScript和与Java的关系也仅仅是看起来像而已 JavaScript是一门动态语言, 所谓的动态语言可以暂时理解为在语言中的一切内容都是不确定的. 比如一个变量, 这一时刻是个整型, 下一时刻可能会变成字符串了. JS可能是运行速度最快的动态语言了 JavaScript是一门面向对象(基于原型的面向对象)的语言 四.JS的Hello WorldA.JS代码的位置 JS代码写在网页(.html文件)的script标签中 JS代码可以写在标签的onclick属性中, 点击时才会执行 JS代码写在超链接的href属性中, 点击时才会执行 JS代码写在外部.js文件中, 用script标签引入该文件到网页 虽然可以写在标签的属性中, 但是这样属于结构与行为耦合, 不方便维护, 不推荐使用 一般使用script引入外部js文件或将代码写在script标签中, 一旦script标签用于引入js文件, 那么就不能在里面编写js代码 JS代码按script标签先后顺序, 顺序执行 注意: 本站所有的html代码, 均可直接复制, 然后粘贴到W3School 代码区, 点击提交代码在线执行. 例: 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;JS基础&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //弹出窗口 alert(\"Hello Wrold!\"); //输出在body标签中 document.write(\"Hello World!\"); //输出在控制台 console.log(\"Hello World!\"); &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/test.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;br /&gt; &lt;button onclick=\"alert('讨厌, 点我干嘛~~~')\"&gt;点我一下试试&lt;/button&gt; &lt;br /&gt; &lt;a href=\"javascript:alert('让你点你就点?')\"&gt;点我一下试试&lt;/a&gt; &lt;a href=\"javascript:;\"&gt;点我一下试试&lt;/a&gt;&lt;!--点击时什么都不做--&gt; &lt;script type=\"text/javascript\"&gt; //弹出窗口 alert(\"two\"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://blog.crainyday.com/tags/JS/"}]},{"title":"JavaInternet","slug":"JavaSE14-Internet","date":"2019-03-28T12:49:36.000Z","updated":"2019-10-06T09:37:33.000Z","comments":true,"path":"JavaSE14-Internet.html","link":"","permalink":"https://blog.crainyday.com/JavaSE14-Internet.html","excerpt":"Java网络编程","text":"Java网络编程 一.网络编程概述 Java是 Internet 上的语言, 它从语言级上提供了对网络应用程序的支持, 程序员能够很容易开发常见的网络应用程序. Java提供的网络类库, 可以实现无痛的网络连接, 联网的底层细节被隐藏在 Java 的本机安装系统里, 由 JVM 进行控制, 并且 Java 实现了一个跨平台的网络库, 程序员面对的是一个统一的网络编程环境. 计算机网络: 把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统, 从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源.网络编程的目的: 直接或间接地通过网络协议与其它计算机进行通讯.网络编程中有两个主要的问题: ①如何准确地定位网络上一台或多台主机 ②找到主机后如何可靠高效地进行数据传输.如何实现网络中的主机互相通信: ①通信双方地址 ②一定的规则(有两套参考模型): OSI参考模型: 模型过于理想化, 未能在因特网上进行广泛推广 TCP/IP参考模型(或TCP/IP协议): 事实上的国际标准. 二.通讯要素1.IP和端口号 IP 地址: InetAddress ①唯一的标识 Internet 上的计算机 ②本地回环地址(hostAddress): 127.0.0.1 主机名(hostName)：localhost ③不易记忆端口号标识正在计算机上运行的进程(程序) ①不同的进程有不同的端口号 ②被规定为一个 16 位的整数 0~65535. 其中, 0~1023被预先定义的服务通信占用(如My Sql占用端口3306, http占用端口80等). 除非我们需要访问这些特定服务, 否则, 就应该使用 1024~65535 这些端口中的某一个进行通信, 以免发生端口冲突. 端口号与IP地址的组合得出一个网络套接字(socket). 2.网络通信协议 ​ 计算机网络中实现通信必须有一些约定, 即通信协议, 对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准.​ 通信协议分层的思想 TCP/IP协议簇 传输层协议中有两个非常重要的协议: 传输控制协议TCP(Transmission Control Protocol) 用户数据报协议UDP(User Datagram Protocol)TCP/IP 以其两个主要协议: 传输控制协议(TCP)和网络互联协议(IP)而得名, 实际上是一组协议, 包括多个具有不同功能且互为关联的协议.IP(Internet Protocol)协议是网络层的主要协议, 支持网间互连的数据通信.TCP/IP协议模型从更实用的角度出发, 形成了高效的四层体系结构, 即物理链路层、IP层、传输层和应用层. TCP协议: 使用TCP协议前, 须先建立TCP连接, 形成传输数据通道 传输前, 采用“三次握手”方式, 是可靠的 TCP协议进行通信的两个应用进程: 客户端、服务端 在连接中可进行大数据量的传输 传输完毕, 需释放已建立的连接, 效率低 UDP协议(视频传输一般用的此协议): 将数据、源、目的封装成数据包, 不需要建立连接 每个数据报的大小限制在64 K内 因无需连接, 故是不可靠的 发送数据结束时无需释放资源, 速度快 3.Socket 利用套接字(Socket)开发网络应用程序早已被广泛的采用, 以至于成为事实上的标准. 通信的两端都要有Socket, 是两台机器间通信的端点 网络通信其实就是Socket间的通信 Socket允许程序把网络连接当成一个流, 数据在两个Socket间通过IO传输 一般主动发起通信的应用程序属客户端, 等待通信请求的为服务端 4.InetAddress类 Internet上的主机有两种方式表示地址: 域名(hostName): localhost IP 地址(hostAddress): 127.0.0.1InetAddress类主要表示IP地址, 两个子类: Inet4Address、Inet6Address.InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址: localhost 和 127.0.0.1域名容易记忆, 当在连接网络时输入一个主机的域名后, 域名解析服务器(DNS)负责将域名转化成IP地址, 这样才能和主机建立连接. ——-域名解析 Windows系统中, 访问域名, 先找本机hosts(C:\\Windows\\System32\\drivers\\etc\\hosts), 是否有输入的域名地址, 没有的话, 再通过DNS服务器, 找主机. 1234567891011121314public static void main(String[] args) throws Exception &#123; //创建一个InetAddress对象: getByName() InetAddress inet = InetAddress.getByName(\"localhost\"); //inet = InetAddress.getByName(\"127.0.0.1\"); System.out.println(inet); //两个方法 System.out.println(inet.getHostName()); System.out.println(inet.getHostAddress()); //获取本机的IP: getLocalHost() InetAddress inet1 = InetAddress.getLocalHost(); System.out.println(inet1); System.out.println(inet1.getHostName()); System.out.println(inet1.getHostAddress());&#125; 三.基于Socket的TCP编程Java语言的基于套接字编程分为服务端编程和客户端编程, 有两个类Socket类和ServerSocket类 1.TCP编程示例一客户端给服务端发送信息, 服务端将信息输出在控制台上. 注意: 测试时, 先开启服务端, 再开启客户端点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 客户端@Testpublic void client() &#123; Socket socket = null; OutputStream os = null; try &#123; //1.创建一个Socket的对象, 通过构造器指明服务端的IP地址, 以及其接收程序的端口号 socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9999); //2.getOutputStream(): 发送数据, 方法返回OutputStream的对象 os = socket.getOutputStream(); //3.具体的输出过程 os.write(\"我是客户端发送的信息\".getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.关闭相应的流和Socket对象 if (os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;// 服务端@Testpublic void server() &#123; ServerSocket ss = null; Socket s = null; InputStream is = null; try &#123; //1.创建一个ServerSocket的对象, 通过构造器指明自身的端口号 ss = new ServerSocket(9999); //2.调用其accept()方法, 返回一个Socket的对象 s = ss.accept(); //3.调用Socket对象的getInputStream()获取一个从客户端发送过来的输入流 is = s.getInputStream(); //4.对获取的输入流进行的操作 byte[] b = new byte[16]; int len = -1; while ((len = is.read(b)) != -1) &#123; String str = new String(b, 0, len); System.out.print(str); &#125; System.out.println(\"收到来自于\" + s.getInetAddress().getHostAddress() + \"的信息\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //5.关闭相应的流以及Socket、ServerSocket的对象 if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (s != null) &#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (ss != null) &#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ## 2.TCP编程示例二客户端给服务端发送信息, 服务端将信息打印到控制台上, 同时回馈”成功接受”给客户端点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//客户端@Testpublic void client()&#123; Socket socket = null; OutputStream os = null; InputStream is = null; try &#123; socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9999); os = socket.getOutputStream(); os.write(\"我是客户端的信息\".getBytes()); //shutdownOutput():执行此方法, 显式的告诉服务端发送完毕! socket.shutdownOutput(); is = socket.getInputStream(); byte[] b = new byte[16]; int len = -1; while((len = is.read(b)) != -1)&#123; String str = new String(b,0,len); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//服务端@Testpublic void server()&#123; ServerSocket ss = null; Socket s = null; InputStream is = null; OutputStream os = null; try &#123; ss = new ServerSocket(9999); s = ss.accept(); is = s.getInputStream(); byte[] b = new byte[16]; int len = -1; //下面的read()方法是阻塞式的, 需要客户端显示的告诉服务端, 发送数据完毕 while((len = is.read(b)) != -1)&#123; String str = new String(b,0,len); System.out.print(str); &#125; os = s.getOutputStream(); os.write(\"服务端成功接收\".getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(s != null)&#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(ss != null)&#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ## 3.TCP编程示例三从客户端发送文件给服务端, 服务端保存到本地. 并返回“成功接收”给客户端. 并关闭相应的连接.点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//客户端@Testpublic void client() &#123; Socket socket = null; OutputStream os = null; InputStream is = null; FileInputStream fis = null; try &#123; socket = new Socket(InetAddress.getByName(\"localhost\"),9999); os = socket.getOutputStream(); fis = new FileInputStream(new File(\"1.png\")); int length = -1; byte[] a = new byte[1024]; while((length = fis.read(a))!=-1) &#123; os.write(a, 0, length); &#125; socket.shutdownOutput(); is = socket.getInputStream(); int len = -1; byte[] b = new byte[16]; while((len = is.read(b))!= -1) &#123; String str = new String(b, 0, len); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(os !=null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//服务端@Testpublic void server() &#123; ServerSocket ss = null; Socket s = null; InputStream is = null; OutputStream os = null; FileOutputStream fos = null; try &#123; ss = new ServerSocket(9999); s = ss.accept(); is = s.getInputStream(); fos = new FileOutputStream(new File(\"2.png\")); byte b[] = new byte[1024]; int len = -1; while((len = is.read(b))!=-1) &#123; fos.write(b, 0, len); &#125; System.out.println(\"收到来自于\" + s.getInetAddress().getHostAddress() + \"的文件\"); os = s.getOutputStream(); os.write(\"成功接收\".getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(s != null) &#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(ss != null) &#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; # 四.基于Socket的TCP编程- 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序.- UDP数据报通过数据报套接字 DatagramSocket 发送和接收, 系统不保证UDP数据报一定能够安全送到目的地, 也不能确定什么时候可以抵达.- DatagramPacket 对象封装了UDP数据报, 在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号.- UDP协议中每个数据报都给出了完整的地址信息, 因此无须建立发送方和接收方的连接.## 1.流 程:1. DatagramSocket与DatagramPacket2. 建立发送端，接收端3. 建立数据包4. 调用Socket的发送、接收方法5. 关闭Socket发送端与接收端是两个独立的运行程序 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334//发送端@Testpublic void send() &#123; DatagramSocket ds = null; try &#123; ds = new DatagramSocket(); byte[] b = \"这是发送端发送过来的数据\".getBytes(); DatagramPacket dp = new DatagramPacket(b, 0, b.length, InetAddress.getByName(\"127.0.0.1\"), 9999); ds.send(dp); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(ds != null) &#123; ds.close(); &#125; &#125;&#125;//接收端@Testpublic void rceive() &#123; DatagramSocket ds = null; try &#123; ds = new DatagramSocket(9999); byte[] b = new byte[1024]; DatagramPacket dp = new DatagramPacket(b, 0, b.length); ds.receive(dp); String str = new String(dp.getData(),0,dp.getLength()); System.out.println(str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; ds.close(); &#125;&#125; 五.URL编程 URL(Uniform Resource Locator): 统一资源定位符, 它表示 Internet 上某一资源的地址. 通过 URL 我们可以访问 Internet 上的各种网络资源, 比如最常见的 www, ftp 站点. 浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源. URL的基本结构由5部分组成:&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;例如: http://127.0.0.1:8080/helloworld/index.jsp 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Testpublic void download() &#123; InputStream is = null; InputStream is2 = null; FileOutputStream fos = null; try &#123; URL url = new URL(\"https://papertome.com/hello.txt\"); //读取服务器上的资源法一: is = url.openStream(); byte[] b = new byte[16]; int len = -1; while((len = is.read(b))!=-1) &#123; String str = new String(b,0,len,\"utf-8\"); System.out.print(str); &#125; //读取服务器上的资源法二: URLConnection urlConn = url.openConnection(); is2 = urlConn.getInputStream(); fos = new FileOutputStream(new File(\"hello.txt\")); while((len = is2.read(b))!=-1) &#123; fos.write(b, 0, len); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is2 != null) &#123; try &#123; is2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"JavaReflection","slug":"JavaSE13-Reflection","date":"2019-03-27T13:48:35.000Z","updated":"2019-10-06T09:37:26.000Z","comments":true,"path":"JavaSE13-Reflection.html","link":"","permalink":"https://blog.crainyday.com/JavaSE13-Reflection.html","excerpt":"Java的反射机制","text":"Java的反射机制 一.Java ReflectionReflection(反射)是被视为动态语言的关键, 反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息, 并能直接操作任意对象的内部属性及方法 1.Java反射机制提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的成员变量和方法 生成动态代理(前边讲interface时有静态代理) 2.反射相关的主要API: java.lang.Class:代表一个类 java.lang.reflect.Method:代表类的方法 java.lang.reflect.Field:代表类的成员变量 java.lang.reflect.Constructor:代表类的构造方法 3.初识反射通过反射在运行时构造一个类的对象, 调用方法和成员变量点击显/隐内容 12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestReflection &#123; public static void main(String[] args) throws Exception&#123; //class文件中运行时Person类即为Class类的实例(clazz) Class&lt;Person&gt; clazz = Person.class; //1.创建clazz对应的运行时类(Person类)的对象 Person p = clazz.newInstance(); System.out.println(p); //2.通过反射调用运行时类指定的成员变量 Field f1 = clazz.getField(\"name\");//调用public变量 f1.set(p, \"LiuDehua\"); Field f2 = clazz.getDeclaredField(\"age\");//调用private变量 f2.setAccessible(true); f2.set(p, 21); System.out.println(p); //3.反射调用运行时类指定的方法 Method m1 = clazz.getMethod(\"show\");//无参方法 m1.invoke(p); Method m2 = clazz.getMethod(\"display\", String.class);//带参方法 m2.invoke(p, \"CHINA\"); &#125;&#125;class Person&#123; public String name; private int age; public Person() &#123; super(); &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public void show() &#123; System.out.println(\"我是一个人\"); &#125; public void display(String nation) &#123; System.out.println(\"我的国籍是:\"+nation); &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \"]\"; &#125;&#125; 二.反射的源头Class类 源文件经过编译(javac.exe)以后, 得到一个或多个.class文件, .class文件经过运行(java.exe)这步, 就需要进行类的加载(通过JVM的类加载器), 加载到内存的缓存中. 每一个放入缓存中的.class文件就是一个Class的实例! Class的一个对象, 对应着一个运行时类(每一个运行时类只加载一次). 相当于一个运行时类本身充当了Class的一个实例. 每一个对象, 都能通过它的getClass()方法, 得到它对应的运行时类 通过Class的实例得到一个运行时类中的完整结构(属性, 方法, 构造器, 内部类, 父类, 所在包, 异常, 注解, … ) 1.创建Class类的对象 通过运行时类本身的.class属性获取 通过运行时类对象的getClass()方法获取 通过Class类的静态方法Class.forName(String path)方法 (了解)通过类加载器(ClassLoader)的对象的loadClass(String path)方法 ClassLoader的应用: 点击显/隐内容 12345678910111213public static void main(String[] args)&#123; //法一: ClassLoader loader = this.getClass().getClassLoader(); InputStream is = loader.getResourceAsStream(\"com\\\\crd\\\\reflection\\\\jdbc.properties\"); //法二:// FileInputStream is = new FileInputStream(new File(\"jdbc1.properties\")); Properties pros = new Properties(); pros.load(is); String name = pros.getProperty(\"user\"); System.out.println(name); String password = pros.getProperty(\"password\"); System.out.println(password);&#125; 有了Class的实例后, 可以做什么? 创建对应的运行时类的对象(重点) 获取对应运行时类完整的类的结构: 属性、方法、构造器、包、父类、接口、泛型、注解、异常、内部类… 调用对应的运行时类中指定的结构(某个指定的属性、方法、构造器)(重点) 12345678910111213141516//获取到对应的运行时类中声明的权限为public的方法(包含其父类中的声明的public)Method[] m1 = clazz.getMethods();//获取到对应的运行时类中声明的所有的方法(①任何权限修饰符修饰的都能获取②不含父类中的)Method[] m2 = clazz.getDeclaredMethods();//获取其他结构调用类似方法即可//获取父类的泛型(以后会用到)@Testpublic void test1()&#123; Class clazz = Person.class; Type type = clazz.getGenericSuperclass(); ParameterizedType param = (ParameterizedType)type; Type[] arr = param.getActualTypeArguments(); for(int i = 0;i &lt; arr.length;i ++)&#123; System.out.println((Class)arr[i]);//父类的泛型 &#125;&#125; 注意: 调用getDeclaredXxx()方法后, 建议要调用一下, setAccessible(true); 2.创建运行时类的对象 使用Class实例的newInstance()方法创建, 该方法默认调用运行时类的空参构造器(该构造器需要足够的权限) 故, 创建类时建议创建一个空参的构造器 也能用指定的构造器创建运行时类的对象 12345678@Testpublic void test() throws Exception&#123; Class clazz = Person.class; Constructor cons = clazz.getDeclaredConstructor(String.class,int.class);//指定构造器 cons.setAccessible(true); Person p = (Person)cons.newInstance(\"Tom\",10); System.out.println(p);&#125; 三.动态代理 代理设计模式的原理: 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上 之前提到过静态代理, 特征是代理类和被代理类都是在编译期间确定下来, 不利于程序的扩展. 同时, 每一个代理类只能为一个接口服务, 这样一来程序开发中必然产生过多的代理. 最好可以通过一个代理类完成全部的代理功能 静态代理: 要求被代理类和代理类同时实现相应的一套接口; 通过代理类的对象调用重写接口的方法时, 实际上执行的是被代理类的同样的方法的调用. 点击显/隐内容 12345678910111213141516171819202122232425262728//创建接口interface ClothFactory&#123; void productCloth();&#125;//创建被代理类class NikeClothFactory implements ClothFactory&#123; public void productCloth()&#123; System.out.println(\"Nike工厂生产衣服\"); &#125;&#125;//创建代理类class ProxyFactory implements ClothFactory&#123; ClothFactory cf; public ProxyFactory(ClothFactory cf)&#123; this.cf = cf; &#125; public void productCloth()&#123; System.out.println(\"代理类开始代理\"); cf.productCloth(); &#125;&#125;public class TestFactory&#123; public static void main(String [] args)&#123; NikeClothFactory nike = new NikeClothFactory();//创建被代理类 ProxyFactory proxy = new ProxyFactory(nike);//创建代理类 proxy.productCloth(); &#125;&#125; 动态代理: 在程序运行时, 根据被代理类及其实现的接口, 动态的创建一个代理类. 当调用代理类的实现的抽象方法时, 就发起对被代理类同样方法的调用. 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334353637383940414243//动态代理的使用, 反射是动态语言的关键interface Subject &#123; void action();&#125;//被代理类class RealSubject implements Subject &#123; public void action() &#123; System.out.println(\"我是被代理类, 记得要执行我哦!么么~~\"); &#125;&#125;class MyInvocationHandler implements InvocationHandler &#123; Object obj;//实现了接口的被代理类的对象的声明 //①给被代理的对象实例化②返回一个代理类的对象 public Object blind(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); &#125; //当通过代理类的对象发起对被重写的方法的调用时, 都会转换为对如下的invoke方法的调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //method方法的返回值时returnVal Object returnVal = method.invoke(obj, args); return returnVal; &#125;&#125;public class TestProxy &#123; public static void main(String[] args) &#123; //1.被代理类的对象 RealSubject real = new RealSubject(); //2.创建一个实现了InvacationHandler接口的类的对象 MyInvocationHandler handler = new MyInvocationHandler(); //3.调用blind()方法，动态的返回一个同样实现了real所在类实现的接口Subject的代理类的对象。 Object obj = handler.blind(real); Subject sub = (Subject)obj;//此时sub就是代理类的对象 sub.action();//转到对InvacationHandler接口的实现类的invoke()方法的调用 //再举一例 NikeClothFactory nike = new NikeClothFactory(); ClothFactory proxyCloth = (ClothFactory)handler.blind(nike);//proxyCloth即为代理类的对象 proxyCloth.productCloth(); &#125;&#125; 1.动态代理与AOP点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960interface Human &#123; void info(); void fly();&#125;// 被代理类class SuperMan implements Human &#123; public void info() &#123; System.out.println(\"我是超人！我怕谁！\"); &#125; public void fly() &#123; System.out.println(\"I believe I can fly!\"); &#125;&#125;class HumanUtil &#123; public void method1() &#123; System.out.println(\"=======方法一=======\"); &#125; public void method2() &#123; System.out.println(\"=======方法二=======\"); &#125;&#125;class MyInvocationHandler implements InvocationHandler &#123; Object obj;// 被代理类对象的声明 public void setObject(Object obj) &#123; this.obj = obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; HumanUtil h = new HumanUtil(); h.method1(); Object returnVal = method.invoke(obj, args); h.method2(); return returnVal; &#125;&#125;class MyProxy &#123; // 动态的创建一个代理类的对象 public static Object getProxyInstance(Object obj) &#123; MyInvocationHandler handler = new MyInvocationHandler(); handler.setObject(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), handler); &#125;&#125;public class TestAOP &#123; public static void main(String[] args) &#123; SuperMan man = new SuperMan();//创建一个被代理类的对象 Object obj = MyProxy.getProxyInstance(man);//返回一个代理类的对象 Human hu = (Human)obj; hu.info();//通过代理类的对象调用重写的抽象方法 System.out.println(); hu.fly(); //********* NikeClothFactory nike = new NikeClothFactory(); Object obj1 = MyProxy.getProxyInstance(nike); ClothFactory cloth = (ClothFactory)obj1; cloth.productCloth(); &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"JavaClass","slug":"JavaSE12-Class","date":"2019-03-26T07:42:11.000Z","updated":"2019-10-06T09:37:17.000Z","comments":true,"path":"JavaSE12-Class.html","link":"","permalink":"https://blog.crainyday.com/JavaSE12-Class.html","excerpt":"Java常用类","text":"Java常用类 String StringBuffer StringBuilder System Date SimpleDateFormate Calendar Math BigInteger BigDecimal 一.字符串String: 代表不可变的字符序列. 底层使用char[]存放. String 是final的. StringBuffer: 代表可变序列的字符序列, 可以对字符串内容修改. 底层也是char[]存放 1.String内存解析点击显/隐内容 1234567891011121314151617181920212223public static void main(String[] args)&#123; String str1 = \"JavaEE\"; String str2 = \"JavaEE\"; String str3 = new String(\"JavaEE\"); String str4 = \"JavaEE\" + \"Android\"; String str5 = \"Android\"; String str6 = str1 + str5; str5 = str5 + \"Handoop\"; String str7 = str6.intern(); String str8 = \"JavaEEAndroid\"; System.out.println(str1 == str2);//true System.out.println(str1 == str3);//false System.out.println(str1.equals(str3));//true System.out.println(str4 == str6);//false System.out.println(str4.equals(str6));//true System.out.println(str7 == str4);//true System.out.println(str4 == str8);//true Person p1 = new Person(\"AA\"); Person p2 = new Person(\"AA\"); System.out.println(\"^_^\"+ (p1.name == p2.name));//true&#125; 2.String常用方法1234567891011121314151617181920public int length()public char charAt(int index)public boolean equals(Object anObject)public int compareTo(String anotherString)public int indexOf(String s)public int indexOf(String s ,int startpoint)public int lastIndexOf(String s)public int lastIndexOf(String s ,int startpoint)public boolean startsWith(String prefix)public boolean endsWith(String suffix)public boolean regionMatches(int firstStart,String other,int otherStart ,int length)public String substring(int startpoint)public String substring(int start,int end)public String replace(char oldChar,char newChar)public String replaceAll(String oldStr,String newStr)public String trim()public String concat(String str)public String[] split(String regex)public char[] toCharArray()public boolean contains(String str) 3.String与其他类型间的转换 String、基本数据类型、包装类之间的转换 ①String —&gt; 基本数据类型、包装类: 调用相应包装类的parseXxx(String str)方法 ②基本数据类型、包装类 —&gt; String: 调用字符串重载的valueOf()方法 String与byte[]之间的转换 ①String —&gt; byte[]: 调用字符串的getBytes()方法 ②byte[] —&gt; String: 调用字符串的构造器 String与char[]之间的转换 ①String —&gt; char[]: 调用字符串的toCharArray()方法 ②char[] —&gt; String: 调用字符串的构造器 点击显/隐内容 12345678910111213141516171819202122232425262728public static void main(String[] args)&#123; //1.String、基本数据类型、包装类 String str1 = \"123\"; int i = Integer.parseInt(str1); System.out.println(i); String str2 = i + \"\"; str2 = String.valueOf(i); System.out.println(str2); //2.String与byte[]之间的转换 String str3 = \"abcdefg\"; byte[] b = str.getBytes(); for(int j = 0;j &lt; b.length; j++)&#123; System.out.println((char)b[j]);//不能正确打印出汉字 &#125; String str4 = new String(b); System.out.println(str4); //3.String与char[]之间的转换 String str5 = \"love中国\"; char[] c = str5.toCharArray(); for(int j = 0;j &lt; c.length; c++)&#123; System.out.println(c[j]); &#125; String str6 = new String(c); System.out.println(str6);&#125; 4.StringBuffer类StringBuffer(相当于一个容器)类有三个构造方法: StringBuffer()初始容量为16的字符串缓冲区 StringBuffer(int size)构造指定容量的字符串缓冲区 StringBuffer(String str)将内容初始化为指定字符串内容 5.StringBuffer常用方法StringBuffer很多方法与String相同 12345678910StringBuffer append(String s)//参数可以为:int n、Object o、char n、long n、boolean nStringBuffer insert(int index, String str)public StringBuffer reverse()//调用此方法的StringBuffer也会反转StringBuffer delete(int startIndex, int endIndex)public char charAt(int n)public void setCharAt(int n ,char ch)StringBuffer replace( int startIndex ,int endIndex, String str)public int indexOf(String str)public String substring(int start,int end)public int length() 6.StringBuilder类也是可变的字符序列,而且方法也一样, JDK5.0后加的, 线程不安全, 但效率高于StringBuffer 使用String的一个弊端 string s=”a”; //创建了一个字符串 s=s+”b”; //实际上原来的”a”字符串对象已经丢弃了, 现在又产生了一个字符串s+”b”(也就是”ab”).如果多次执行这些改变串内容的操作, 会导致大量副本字符串对象存留在内存中, 降低效率. 如果这样的操作放到循环中, 会极大影响程序的性能. 7.String、StringBuffer、StringBuilder性能比较点击显/隐内容 123456789101112131415161718192021222324252627public static void main(String[] args)&#123; String text = \"\"; long startTime = 0L; long endTime = 0L; StringBuffer buffer = new StringBuffer(\"\"); StringBuilder builder = new StringBuilder(\"\"); startTime = System.currentTimeMillis(); for(int i = 0;i&lt;20000;i++)&#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(\"StringBuffer的执行时间：\"+(endTime-startTime)); startTime = System.currentTimeMillis(); for(int i = 0;i&lt;20000;i++)&#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(\"StringBuilder的执行时间：\"+(endTime-startTime)); startTime = System.currentTimeMillis(); for(int i = 0;i&lt;20000;i++)&#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println(\"String的执行时间：\"+(endTime-startTime));&#125; 二.时间相关类1.System类currentTimeMillis(): 返回当前时间的long型值. 此long值是从1970年1月1日0点0分00秒开始到当前的毫秒数.此方法常用来计算时间差 计算世界时间的主要标准: UTC(Universal Time Coordinated) GMT(Greenwich Mean Time)—格林威治时间 CST(Central Standard Time)—标准时间(四个国家) 2.Date类有两个: java.util.Date类及它的子类 java.sql.Date表示特定的瞬间, 精确到毫秒 1234567891011import java.util.Date;public void testDate()&#123; Date date = new Date();//两个构造方法, 无参和long型参数 System.out.println(date); System.out.println(System.currentTimeMillis()); System.out.println(date.getTime()); System.out.println(date.toString()); java.sql.Date d = new java.sql.Date(date.getTime()); System.out.println(d);//格式:year-month-day&#125; Date类的API不易于国际化, 大部分方法被废弃了, java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类. 3.SimpleDateFormat类 格式化: 日期 —&gt; 文本 使用SimpleDateFormat 的format()方法 解析: 文本 —&gt; 日期 使用SimpleDateFormat的parse()方法 12345678910111213141516public static void main(String[] args)&#123; //1.默认模式格式化 SimpleDateFormat sdf = new SimpleDateFormat(); String date = sdf.format(new Date()); System.out.println(date);//19-3-26 下午4:50 //2.自定义模式格式化 SimpleDateFormat sdf1 = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss Z\"); date = sdf1.format(new Date()); System.out.println(date);//星期二, 26 三月 2019 16:55:16 +0800 //3.解析: Date date1 = sdf.parse(\"19-3-26 下午4:50\");//要和构造器的格式字符串对应 System.out.println(date1); date1 = sdf1.parse(\"星期二, 26 三月 2019 16:55:16 +0800\");// date1 = sdf1.parse(\"19-3-26 下午4:50\");//出异常 System.out.println(date1);&#125; 4.Calendar类Calendar是一个抽象基类, 主用用于完成日期字段之间相互操作的功能. 使用Calendar.getInstance()方法得到一个Calendar的实例, 一个Calendar的实例是系统时间的抽象表示 123456//常用方法public void get(int field)public void set(int field,int value)public void add(int field,int amount)public final Date getTime()public final void setTime(Date date) 三.计算相关类1.Math类java.lang.Math提供了一系列静态方法用于科学计算; 其方法的参数和返回值类型一般为double型. abs 绝对值acos,asin,atan,cos,sin,tan 三角函数sqrt 平方根pow(double a,doble b) a的b次幂log 自然对数exp e为底指数max(double a,double b)min(double a,double b)random() 返回0.0到1.0的随机数long round(double a) double型数据a转换为long型（四舍五入）toDegrees(double angrad) 弧度—&gt;角度toRadians(double angdeg) 角度—&gt;弧度 2.BigInteger类Integer类作为int的包装类. 能存储的最大整型值为2^31−1, BigInteger类的数字范围较Integer类的数字范围要大得多, 可以支持任意精度的整数. 构造器BigInteger(String val)常用方法public BigInteger abs()public BigInteger add(BigInteger val)public BigInteger subtract(BigInteger val)public BigInteger multiply(BigInteger val)public BigInteger divide(BigInteger val)public BigInteger remainder(BigInteger val)public BigInteger pow(int exponent)public BigInteger[] divideAndRemainder(BigInteger val) 3.BigDecimal类一般的Float类和Double类可以用来做科学计算或工程计算, 但在商业计算中, 要求数字精度比较高, 故用到java.math.BigDecimal类. BigDecimal类支持任何精度的定点数. 构造器public BigDecimal(double val)public BigDecimal(String val)常用方法public BigDecimal add(BigDecimal augend)public BigDecimal subtract(BigDecimal subtrahend)public BigDecimal multiply(BigDecimal multiplicand)public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"Thread","slug":"JavaSE11-Thread","date":"2019-03-25T12:51:35.000Z","updated":"2019-10-06T09:37:08.000Z","comments":true,"path":"JavaSE11-Thread.html","link":"","permalink":"https://blog.crainyday.com/JavaSE11-Thread.html","excerpt":"Java多线程","text":"Java多线程 一.基本概念 程序、进程、线程 程序(program)可以理解为静态的代码 进程(process)可以理解为执行中的程序 线程(thread)可以理解为进程的进一步细分, 程序的一条执行路径 何时需要多线程 程序需要同时执行两个或多个任务 程序需要实现一些等待的任务时, 如: 用户输入、文件读写、网络操作顿、搜索等 需要一些后台运行的任务时 二.创建多线程通过java.lang.Thread类实现 方式一:继承Thread类 继承Thread类,并重写run()方法,run()方法内实现此子线程想要实现的功能 在主线程内, 创建一个子线程的对象. 调用子线程的start()方法, 启动此线程; 调用相应线程的run()方法 1234567891011121314151617181920212223class PrintNum extends Thread&#123; public void run()&#123; //子线程要执行的代码 for(int i = 1;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + \":\" + i); &#125; &#125; &#125; public PrintNum(String name)&#123; super(name); &#125;&#125;public class TestThread &#123; public static void main(String[] args) &#123; PrintNum p1 = new PrintNum(\"线程1\"); PrintNum p2 = new PrintNum(\"线程2\"); p1.setPriority(Thread.MAX_PRIORITY);//10 p2.setPriority(Thread.MIN_PRIORITY);//1 p1.start();//start()会调用run()方法 p2.start(); &#125;&#125; 注意: ①一个线程只能start()一次; ②不能用run()启动线程 Thread类的常用方法: 点击显/隐内容 1234567891011121314151617/* Thread类的常用方法: * 1.start():启动线程并调用相应的run()方法 * 2.run():子线程要执行的代码 * 3.currentThread():静态方法, 调取当前线程 * 4.getName():获取此线程的名字 * 5.setName():设置此线程的名字 * 6.yield():调用此方法的线程强制释放当前CPU的执行权 * 7.join():在A线程中调用B线程的join()方法.表示当A线程执行到此方法时,停止 * 执行A线程,直到B线程执行完毕,A线程再接着B.join()之后的代码执行 * 8.isAlive()判断此线程是否存活 * 9.sleep(long time)显示的让当前线程睡眠time毫秒 * 10.线程通信有关的: wait() notify() notifyAll()//在Object类中 * 设置线程的优先级MAX_PRIORITY=10;NORM_PRIORITY=5;MIN_PRIORITY=1 * 改变抢占CPU资源的概率 * setPriority(int newPriority) * getPriority() */ 例子: 三个售票窗口售卖100张票(一共100张) 继承Thread类的方式实现: 注意: 此程序存在隐患(线程安全问题) 点击显/隐内容 12345678910111213141516171819202122232425262728293031//继承Thread类的方式实现class Window extends Thread&#123; static int ticket = 100; public void run() &#123; while(true) &#123; if(ticket&gt;0) &#123;//开启注释放大错误// try &#123;// Thread.currentThread().sleep(10);//阻塞10ms// &#125; catch (InterruptedException e) &#123;// // TODO 自动生成的 catch 块// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + \"售票, 票号为:\"+ticket--); &#125; else break; &#125; &#125;&#125;public class TestWindow &#123; public static void main(String[] args) &#123; Window w1 = new Window(); Window w2 = new Window(); Window w3 = new Window(); w1.setName(\"窗口一:\"); w2.setName(\"窗口二:\"); w3.setName(\"窗口三:\"); w1.start(); w2.start(); w3.start(); &#125;&#125; 方式二:实现Runnable接口 创建一个实现Runnable接口的类 实现接口的抽象run()方法 创建一个实现Runnable接口实现类的对象 将此对象作为形参传给Thread类的构造器, 创建Thread类的对象, 此对象即为一个线程 调用start()启动线程 123456789101112131415161718192021222324252627//1.创建一个实现Runnable接口的类class SubThread implements Runnable&#123; //2.实现接口的抽象run()方法 public void run()&#123; //子线程执行的代码 for(int i = 1;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + \":\" + i); &#125; &#125; &#125;&#125;public class TestThread&#123; public static void main(String[] args)&#123; //3.创建一个实现Runnable接口实现类的对象 SubThread s = new SubThread(); //想要启动一个线程必须调用start()方法 //4.将此对象作为形参传给Thread类的构造器, 创建Thread类的对象, 此对象即为一个线程 Thread t1 = new Thread(s); Thread t2 = new Thread(s); //5.调用start()启动线程 t1.setName(\"线程1\"); t2.setName(\"线程2\"); t1.start();//启动线程: 执行Thread对象生成时构造器形参的run()方法. t2.start(); &#125;&#125; 两种方式的对比: 联系：class Thread implements Runnable, 两种方式实际上都与Runnable接口发生了关系 哪个比较好? 实现的方式(方式二)较好: ①解决了单继承的局限性 ②如果多个线程有共享数据的话, 建议使用实现方式, 同时, 共享数据所在的类可以作为Runnable接口的实现类. 实现Runnable接口的方式实现(上述售票例题): 注意: 此程序存在隐患(线程安全问题) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233//有共享数据的问题(一共100张票)class Window1 implements Runnable&#123; int ticket = 100; public void run()&#123; while(true) &#123; if(ticket&gt;0) &#123;//开启注释放大错误// try &#123;// Thread.currentThread().sleep(10);//阻塞10ms// &#125; catch (InterruptedException e) &#123;// // TODO 自动生成的 catch 块// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + \"售票, 票号为:\"+ticket--); &#125; else break; &#125; &#125;&#125;public class TestThread&#123; public static void main(String[] args)&#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 三.Java的多线程1.多线程的优点 提高应用程序的响应 提高计算机系统的CPU利用率 改善程序接口 2.Java线程的分类 守护线程VS用户线程 若JVM中都是守护线程, 当前JVM将退出 3.线程的生命周期新建、就绪、运行、阻塞、死亡 四.线程同步上述售票的例子: 程序存在线程安全问题: 打印车票时, 会出现重票、错票 线程安全问题存在的原因? 由于一个线程在操作共享数据的过程中, 未执行完的情况下, 另外一个线程参与进来, 导致共享数据存在了安全问题. 如何解决该问题? 必须让一个线程操作共享数据完毕以后, 其他线程才有机会进入参与共享数据的操作. Java如何实现线程的安全: 线程的同步机制 方式一: 同步代码块:123synchronized(同步监视器)&#123; //操作共享数据的代码&#125; ①同步监视器: 俗称锁, 任何一个类的对象都可以才充当锁. 要想保证线程的安全, 必须要求所有的线程共用同一把锁!②共享数据: 多个线程需要共同操作的变量. 明确哪部分是操作共享数据的代码. ③使用实现Runnable接口的方式创建多线程的话, 同步代码块中的锁, 可以考虑是this. 如果使用继承Thread类的方式, 慎用this! 修改原来的售票代码: 点击显/隐内容 12345678910111213141516171819202122232425262728293031//有共享数据的问题(一共100张票)class Window1 implements Runnable&#123; int ticket = 100; Object obj = new Object(); public void run() &#123; while(true) &#123; synchronized (this) &#123;//同步锁可以由任何对象充当, 但是同步的线程要共用一把锁 //this表示当前对象, 本程序中为w对象, this可以改为obj //具体问题具体分析, 有时候不能用this ,用继承Thread方式实现的多线程不能用this if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName() + \"售票, 票号为:\"+ticket--); &#125; else break; &#125; &#125; &#125;&#125;public class TestThread&#123; public static void main(String[] args)&#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 方式二: 同步方法: 将需要共享的数据的操作放到一个方法里, 并给该方法添加 synchronized 修饰 同步方法也有锁, 即为当前对象 this 如果使用在继承的方式实现多线程的话, 慎用同步方法!因为它们的this锁不一样 点击显/隐内容 123456789101112131415//这个类是用实现Runnable接口实现的多线程class Window implements Runnable&#123; int ticket = 100; @Override public void run() &#123; while(true) &#123; this.show(); &#125; &#125; public synchronized void show() &#123; if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName() + \"售票, 票号为:\"+ticket--); &#125; &#125;&#125; 懒汉式单例模式的线程安全 使用线程同步机制解决问题 对于一般的方法内, 使用同步代码块的方式, 可以考虑用this当锁 对于静态方法而言, 使用当前类本身充当锁 123456789101112131415//懒汉式class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance = null; public static Singleton getInstance()&#123; if(instance == null)&#123;//提高效率 synchronized(Singleton.class)&#123;//后面会说, Singleton.class对象 if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 线程同步的弊端: 由于同一时间只能有一个线程访问共享数据, 效率变低了 何时释放锁? 当前线程的同步方法、同步代码块执行结束时 当前线程的同步方法、同步代码块中出现了未处理的Error或Exception, 导致异常结束 当前线程的同步方法、同步代码块中执行了线程对象的wait()方法, 当前线程暂停并释放锁 线程的死锁:不同的线程分别占用对方需要的同步资源不放弃, 都在等待对方放弃自己需要的同步资源, 就形成了线程的死锁.死锁是我们在使用同步时, 需要避免的问题! 线程的通信涉及到三个方法 wait() notify() notifyAll() 在java.lang.Object类中 wait(): 令当前线程挂起, 放弃CPU、同步资源…… notify(): 唤醒正在排队等待同步资源的线程中优先级最高的线程 notifyAll(): 唤醒正在排队等待同步资源的所有线程 注意: 这三个方法只能在同步方法或同步代码块中使用, 否则会报异常 例, 用两个线程交替打印1-100: 点击显/隐内容 1234567891011121314151617181920212223242526272829303132class PrintNum implements Runnable&#123; int num = 1; @Override public void run() &#123; while(true) &#123; synchronized(this) &#123; notify(); if(num&lt;100) &#123; System.out.println(Thread.currentThread().getName() + \":\" + num); num++; &#125;else break; try &#123; wait(); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;public class TestCommunication &#123; public static void main(String[] args) &#123; PrintNum p = new PrintNum(); Thread t1 = new Thread(p); Thread t2 = new Thread(p); t1.setName(\"甲\"); t2.setName(\"乙\"); t1.start(); t2.start(); &#125;&#125; 经典例题: 生产者/消费者问题点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品， * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫 * 生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员 * 会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。 */class Producer implements Runnable &#123; Clerk clerk; Producer(Clerk clerk) &#123; this.clerk = clerk; &#125; public void run() &#123; System.out.println(\"生产者开始生产产品\"); while (true) &#123; try &#123; Thread.currentThread().sleep(100); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; clerk.addProduct(); &#125; &#125;&#125;class Consumer implements Runnable &#123; Clerk clerk; Consumer(Clerk clerk) &#123; this.clerk = clerk; &#125; public void run() &#123; System.out.println(\"消费者开始消费产品\"); while (true) &#123; try &#123; Thread.currentThread().sleep(100); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; clerk.subProduct(); &#125; &#125;&#125;class Clerk &#123; int product; public synchronized void addProduct() &#123; if (product &gt;= 20) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; else &#123; product++; notifyAll(); System.out.println(Thread.currentThread().getName() + \"生产了第\" + this.product + \"个产品\"); &#125; &#125; public synchronized void subProduct() &#123; if (product &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \"消费了第\" + this.product + \"个产品\"); product--; notifyAll(); &#125; else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); Consumer c1 = new Consumer(clerk); Thread t1 = new Thread(c1); Thread t2 = new Thread(p1); Thread t3 = new Thread(p1); t1.setName(\"消费者1\"); t2.setName(\"生产者1\"); t3.setName(\"生产者2\"); t2.start(); t1.start(); t3.start(); &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"面向对象总结","slug":"JavaSE5OOP","date":"2019-03-20T13:04:35.000Z","updated":"2019-10-06T09:36:53.000Z","comments":true,"path":"JavaSE5OOP.html","link":"","permalink":"https://blog.crainyday.com/JavaSE5OOP.html","excerpt":"面向对象的三条主线:1.类及类的成分2.面向对象的三大特性3.其他的关键字: this super import package abstract static final interface等","text":"面向对象的三条主线:1.类及类的成分2.面向对象的三大特性3.其他的关键字: this super import package abstract static final interface等 一.专注类的设计类从代码的角度: 并列关系! 从执行、设计的角度: 关联关系、继承关系、聚合关系 1.类的成分属性 方法 构造器 代码块 内部类 属性: ①变量的分类: 成员变量(属性 Field) vs 局部变量(方法的形参、方法内部、代码块内部)基本数据类型(8种, 不同的数据类型对应不同的默认初始化值) vs 引用数据类型(数组、类、接口默认初始化值为null) ②属性的声明格式: 修饰符 数据类型 变量名 = 初始化值; //java是强数据类型的语言 ③对属性的赋值的操作: A.默认初始化 B.显式的初始化 C.代码块的初始化 D.构造器的初始化 E.调用方法、属性进行赋值 方法: ①格式: 修饰符 (其它的关键字: static/final/abstract)返回值类型 方法名 (形参列表){//方法体 } ②方法的重载(overload) vs 方法的重写(override overwrite) ③方法的参数传递机制: 值传递 构造器: ①构造器的作用: A.创建类的对象 B.初始化对象的成员变量 ②构造器也是可以重载的. 代码块: 主要作用: 用来初始化类的成员变量 分类: 静态的代码块 vs 非静态的代码块 内部类: ①分类: 成员内部类(static的成员 vs 非static的成员) vs 局部内部类(方法内部声明的类) ②掌握: A.如何创建成员内部类的对象 B.如何区分调用外部类、内部类的变量(尤其是变量重名时) C.局部内部类的使用 2.类的初始化 如何创建类的对象. 如: Person p = new Person(); Date d = new Date(); 内存解析: 栈: 局部变量、对象的引用名、数组的引用名 堆: new 出来的“东西” 方法区: (字符串常量池) 静态域: 存放类中静态的变量 理解创建的对象在内存中加载的过程 二.面向对象的三大特性1.封装性 ① 通过私有化类的成员变量, 通过公共的getter和setter方法来调用和修改 ② 还可以对类的其他结构进行“封装” ③ 权限修饰符: public protected 缺省 private 2.继承性通过让一个类A继承另一个类B, 就可以获取类B中的结构(主要的: 属性、方法、构造器). 子类: 类A; 父类: 类B java中的类的继承性: 单继承的 3.多态性 ①体现: 方法的重载与重写; 子类对象的多态性 Person p = new Student(); ②子类对象多态性的使用: 虚拟方法调用. ③向上转型 向下转型 Student s = (Student)p; //建议在向下转型之前: if(p instanceof Student)避免出现ClassCastException的异常 三.其他关键字 this: 修饰属性、方法、构造器. 表示: 当前对象或当前正在创建的对象 super: 修饰属性、方法、构造器. 显式的调用父类的相应的结构, 尤其是子父类有重名的方法、属性 static: 修饰属性、方法、代码块、内部类. 随着类的加载而加载! final: 修饰类、属性、方法. 表示“最终的” abstract: 修饰类、方法 interface: 表示是一个接口, (接口是与类并列的一个结构). 类与接口之间同时“implements”发生关系. package import …… abstract不能修饰属性、构造器、不能与final static private共用.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"面向对象3.2","slug":"JavaSE5-2","date":"2019-03-20T09:11:26.000Z","updated":"2019-10-06T09:36:45.000Z","comments":true,"path":"JavaSE5-2.html","link":"","permalink":"https://blog.crainyday.com/JavaSE5-2.html","excerpt":"abstractinterface内部类","text":"abstractinterface内部类 一.abstractabstract: 抽象的, 可以用来修饰类、方法 abstract修饰类: 抽象类 不可被实例化 抽象类有构造器 (凡是类都有构造器) 抽象方法所在的类, 一定是抽象类. 抽象类中可以没有抽象方法. abstract修饰方法: 抽象方法 格式: 没有方法体和{}.如: public abstract void eat(); 抽象方法只保留方法的功能, 而具体的执行, 交给继承抽象类的子类, 由子类重写此抽象方法. 若子类继承抽象类, 并重写了所有的抽象方法, 则此类是一个”实体类”, 即可以实例化 若子类继承抽象类, 没有重写所有的抽象方法, 意味着此类中仍有抽象方法, 则此类必须声明为抽象的! abstract不能用来修饰属性、构造器、private、final、static A.模板方法设计模式功能的内部一部分实现是确定的, 一部分实现是不确定的, 可以将不确定的暴露出去让子类去实现它 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334//模板方法设计模式public class TestTemplate &#123; public static void main(String[] args) &#123; new SubTemplate().spendTime(); &#125;&#125;abstract class Template &#123; //此部分功能不确定: 具体要执行什么代码 public abstract void code(); //此部分功能确定: 计算执行code()方法的时间 public void spendTime() &#123; long start = System.currentTimeMillis(); this.code(); long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start)); &#125;&#125;class SubTemplate extends Template &#123; public void code() &#123; boolean flag = false; for(int i = 2;i &lt;= 10000;i++)&#123; for(int j = 2;j &lt;= Math.sqrt(i);j++)&#123; if(i % j == 0)&#123; flag = true; break; &#125; &#125; if(!flag)&#123; System.out.println(i); &#125; flag = false; &#125; &#125;&#125; 二.interface接口(interface)是与类并行的一个概念 接口可以看做是一个特殊的抽象类, 是常量与抽象方法的一个集合, 不能包含变量、一般的方法. 常量默认有 public static final修饰, 方法默认有 public abstract修饰 接口是没有构造器的. 接口定义的就是一种功能. 此功能可以被类所实现(implements). 比如: class CC extends DD implements AA 实现接口的类, 必须要重写其中的所有的抽象方法, 方可实例化. 若没有重写所有的抽象方法, 则此类仍为一个抽象类 一个类可以实现多个接口.—-java 中的类的继承是单继承的 接口与接口之间也是继承的关系, 而且可以实现多继承 接口与具体的实现类之间也存在多态性 面向接口编程的思想: A.工厂方法的设计模式定义一个用户创建对象的接口, 让子类决定实例化哪一个类. 工厂方法使一个类的实例化延迟到其子类. 123456789101112131415161718192021222324252627282930313233343536373839404142//接口的应用: 工厂方法的设计模式public class TestFactoryMethod &#123; public static void main(String[] args) &#123; IWorkFactory i = new StudentWorkFactory(); i.getWork().doWork(); IWorkFactory i1 = new TeacherWorkFactory(); i1.getWork().doWork(); &#125;&#125;//工厂接口interface IWorkFactory&#123; Work getWork();&#125;//创建学生工作的工厂class StudentWorkFactory implements IWorkFactory&#123; @Override public Work getWork() &#123; return new StudentWork(); &#125;&#125;//创建老师工作的工厂class TeacherWorkFactory implements IWorkFactory&#123; @Override public Work getWork() &#123; return new TeacherWork(); &#125;&#125;interface Work&#123; void doWork();&#125;class StudentWork implements Work&#123; @Override public void doWork() &#123; System.out.println(\"学生写作业\"); &#125;&#125;class TeacherWork implements Work&#123; @Override public void doWork() &#123; System.out.println(\"老师批改作业\"); &#125;&#125; B.代理模式1234567891011121314151617181920212223242526272829303132//接口的应用: 代理模式(静态代理), 后面会有动态代理public class TestProxy &#123; public static void main(String[] args) &#123; Object obj = new ProxyObject(); obj.action(); &#125;&#125;interface Object&#123; void action();&#125;//代理类class ProxyObject implements Object&#123; Object obj; public ProxyObject()&#123; System.out.println(\"代理类创建成功\"); obj = new ObjctImpl(); &#125; public void action()&#123; System.out.println(\"代理类开始执行\"); obj.action(); System.out.println(\"代理类执行结束\"); &#125;&#125;//被代理类class ObjctImpl implements Object&#123; @Override public void action() &#123; System.out.println(\"=====被代理类开始执行======\"); System.out.println(\"=====具体的操作======\"); System.out.println(\"=====被代理类执行完毕======\"); &#125;&#125; 了解就好, 你可以将这两种设计模式当成算法记下来 三.内部类类的第5个成员: 内部类(inner class) 例: Thread类内的State枚举类 相当于说, 我们可以在类的内部再定义类. 外面的类: 外部类. 定义在类内的类: 内部类 内部类的分类: 成员内部类(声明在类内部且方法外的) vs 局部内部类(声明在类的方法里) 成员内部类: 是外部类的一个成员: ①可以有修饰符(4个) ②static final ③可以调用外部类的属性、方法 具体类的特点: ①abstract ②还可以在其内部定义属性、方法、构造器 局部内部类(知道有就好) 关于内部类, 掌握三点: ①如何创建成员内部类的对象(如: 创建Bird类和Dog类的对象) ②如何区分调用外部类、内部类的变量(尤其是变量重名时) ③局部内部类的使用 A.成员内部类:1234567891011121314151617181920212223242526272829303132333435363738394041public class TestInnerClass &#123; public static void main(String[] args) &#123; //创建静态内部类的对象: 可以直接通过外部类调用静态内部类的构造器 Person.Dog d = new Person.Dog();//区别Person.new Dog(); //Person.Bird b = new Person.Bird(); //创建非静态的内部类的对象: 必须先创建外部类的对象, 通过外部类的对象调用内部类的构造器 Person p = new Person(); Person.Bird b = p.new Bird(); b.info(); b.setName(\"杜鹃\"); &#125;&#125;class Person&#123; String name = \"小明\"; int age; //成员内部类(非static的) class Bird&#123; String name = \"黄鹂\"; int id; public Bird()&#123; &#125; public void setName(String name)&#123;//假设传过来的参数为\"杜鹃\" System.out.println(name);//杜鹃 System.out.println(this.name);//黄鹂 System.out.println(Person.this.name);//小明 &#125; public void info()&#123; show(); &#125; &#125; //成员内部类(静态内部类) static class Dog&#123; &#125; public void show()&#123; System.out.println(\"show()\"); &#125; public void method1()&#123; class A&#123; &#125; &#125;&#125; B.局部内部类:12345678910111213141516171819202122232425262728293031class OuterClass&#123; //局部内部类 //如下的使用方式较少 public void method1()&#123; class InnnerClass&#123; &#125; &#125; //常常使用一个方法, 使其返回值为某个类或接口的对象. 而这个类或接口在方法内部创建 //使用方式一 public Comparable getComparable()&#123; //1.创建一个实现Comparable接口的类:局部内部类 class MyComparable implements Comparable&#123; @Override public int compareTo(java.lang.Object o) &#123; return 0; &#125; &#125; //2.返回一个实现类的对象 return new MyComparable(); &#125; //使用方式二 public Comparable getComparable1()&#123; //返回一个实现Comparable接口的匿名内部类的对象 return new Comparable()&#123; @Override public int compareTo(java.lang.Object o) &#123; return 0; &#125; &#125;; &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"面向对象3.1","slug":"JavaSE5-1","date":"2019-03-20T07:03:18.000Z","updated":"2019-10-06T09:36:33.000Z","comments":true,"path":"JavaSE5-1.html","link":"","permalink":"https://blog.crainyday.com/JavaSE5-1.html","excerpt":"static关键字main()方法代码块final","text":"static关键字main()方法代码块final 一.staticstatic: 静态的, 可以用来修饰属性、方法、*代码块(或初始化块)、*内部类 A.static修饰属性(类变量): 由类创建的所有的对象，都共用这一个属性 当其中一个对象对此属性进行修改, 会导致其他对象对此属性调用时也会更改. vs 实例变量(非static修饰的属性, 各个对象各自拥有一套副本) 类变量随着类的加载而加载的, 而且独一份 静态的变量可以直接通过“类.类变量”的形式来调用 类变量的加载是要早于对象. 所以当有对象以后, 可以“对象.类变量”使用. 但是”类.实例变量”是不行的. 类变量存在于内存的静态域中. B.static修饰方法(类方法): 随着类的加载而加载, 在内存中也是独一份 可以直接通过“类.类方法”的方式调用 方法内部可以调用静态的属性或静态的方法, 而不能调用非静态的属性或方法. 反之, 非静态的方法是可以调用静态的属性或静态的方法. 静态的方法内是不可以有this或super关键字的! 注意: 静态的结构(static的属性、方法、代码块、内部类)的生命周期要早于非静态的结构，同时被回收也要晚于非静态的结构 示例, 静态属性及内存状态: 点击显/隐内容 12345678910111213141516171819202122public Test&#123; public static void main(String []args)&#123; SportsMan s1 = new SportsMan(\"金龙\",23); SportsMan s2 = new SportsMan(\"银龙\",20); s1.setName(\"花龙\"); s1.nation = \"China\"; &#125;&#125;class SportsMan&#123; private String name; private int age; public static String nation; SportsMan()&#123; &#125; SportsMan(String name,int age)&#123; this.name = name; this.age = age; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; C.单例模式23种设计模式 单例模式(Singleton): 即类只能创建一个对象, Runtime类就是一个单例模式的应用 解决的问题: 如何只让设计的类只能创建一个对象 如何实现: 饿汉式 &amp; 懒汉式 私有化构造器 在类内部创建类的对象, 同时设置为private的, 通过公共的方法来调用, 体现封装性 一个public static的方法, 获得该(单例)对象 要求该对象也为static的 1234567891011121314151617181920212223242526272829303132333435363738394041//饿汉式1class Bank&#123; //1.私有化构造器 private Bank()&#123;&#125; //2.创建类的对象，同时设置为private的，通过公共的来调用，体现封装性 //4.要求此对象也为static的 private static Bank instance = new Bank(); //3.此公共的方法，必须为static public static Bank getInstance()&#123; return instance; &#125;&#125;//饿汉式2class Bank&#123; //1.私有化构造器 private Bank()&#123;&#125; //2.创建类的对象，同时设置为private的，通过公共的来调用，体现封装性 //4.要求此对象也为static的 private static Bank instance = null; static&#123; instance = new Bank(); &#125; //3.此公共的方法，必须为static public static Bank getInstance()&#123; return instance; &#125;&#125;//懒汉式class Bank&#123; private Bank()&#123;&#125; private static Bank instance = null; public static Bank getInstance()&#123; if(instance == null)&#123;//可能存在线程安全问题的! instance = new Bank(); &#125; return instance; &#125;&#125; 二.main()123public static void main(String[] args) throws Exception&#123; //方法体 &#125; main()是一个方法, 是主方法, 为程序的入口 权限修饰符: public protected 缺省 private —面向对象的封装性 对于方法来讲: static final abstract 可修饰 方法的返回值: void / 具体的返回值类型(基本的数据类型 &amp; 引用数据类型), 方法内部一定要有return 方法名: 命名的规则: xxxYyyZzz. 给方法命名时, 要见名知意 形参列表: 同一个方法名不同的形参列表的诸多个方法间构成重载. 形参 &amp; 实参—方法的参数传递机制: 值传递 抛出异常列表 方法体: 方法定义的是一种功能, 具体的实现由方法体操作. 三.代码块 代码块: 是类的第4个成员, 由一对大括号括起来 作用: 用来初始化类的属性 分类: 只能用static来修饰. A.静态代码块 里面可以有输出语句 随着类的加载而加载，而且只被加载一次 多个静态代码块之间按照顺序结构执行 静态代码块的执行要早于非静态代码块的执行. 静态的代码块中只能执行静态的结构(类属性, 类方法) B.非静态代码块 可以对类的属性(静态的 &amp; 非静态的)进行初始化操作, 同时也可以调用本类声明的方法(静态的 &amp; 非静态的) 里面可以有输出语句 一个类中可以有多个非静态的代码块, 多个代码块之间按照顺序结构执行 每创建一个类的对象, 非静态代码块就加载一次. 非静态代码块的执行要早于构造器 关于属性赋值的操作: ①默认的初始化②显式的初始化或代码块初始化(此处两个结构按照顺序执行)③构造器中;—————————以上是对象的属性初始化的过程—————————————④通过方法对对象的相应属性进行修改 四.finalfinal:最终的, 可以用来修饰类、属性、方法 final修饰类: 这个类就不能被继承. 如: String类、StringBuffer类、System类 final修饰方法: 不能被重写. 如: Object类的getClass() final修饰属性: 此属性就是一个常量, 一旦初始化后, 不可再被赋值. 习惯上, 常量用大写字符表示.此常量在哪里赋值: ①此常量不能使用默认初始化 ②可以显式的赋值、代码块、构造器.变量用static final修饰时: 全局常量. 比如: Math 类的PI","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"多态性","slug":"JavaSE4-2","date":"2019-03-20T06:26:18.000Z","updated":"2019-10-06T09:36:25.000Z","comments":true,"path":"JavaSE4-2.html","link":"","permalink":"https://blog.crainyday.com/JavaSE4-2.html","excerpt":"面向对象的特征三: 多态性Object类包装类","text":"面向对象的特征三: 多态性Object类包装类 一.多态性 多态性的表现: ①方法的重载与重写 ②子类对象的多态性 使用的前提: ①要有继承关系 ②要有方法的重写 格式: 点击显/隐内容 123456789101112131415161718class Person&#123; public void eat()&#123; System.out.println(\"人吃饭\"); &#125; public void walk()&#123; System.out.println(\"人走路\"); &#125;&#125;class Man extends Person&#123; public void entertainment()&#123; System.out.println(\"男人娱乐\"); &#125;&#125;class Woman extends Person&#123; public void shopping()&#123; System.out.println(\"女人购物\"); &#125;&#125; 12345Person p = new Man();//向上转型//虚拟方法调用：通过父类的引用指向子类的对象实体，当调用方法时，实际执行的是子类重写父类的方法p1.eat();p1.walk();//p1.entertainment();//不能调用, Man类里没有这个函数 编译时, 认为p是Person类型的, 故只能执行Person里才有的结构, 即Man里特有的结构不能够调用 子类对象的多态性, 并不使用于属性. 关于向下转型:①向下转型,使用强转符: ()②为了保证不报ClassCastException, 最好在向下转型前, 进行判断: instanceof 12345678910// 若a是A类的实例, 那么a也一定是A类的父类的实例。if (p1 instanceof Woman) &#123; System.out.println(\"hello!\"); Woman w1 = (Woman) p1; w1.shopping();&#125;if (p1 instanceof Man) &#123; Man m1 = (Man) p1; m1.entertainment();&#125; 二.Object类 java.lang.Object 类, 是所有类的根父类! Object类仅有一个空参的构造器 public Object(){ } 关于方法: ① equals(Object obj)123public boolean equals(Object obj) &#123; return (this == obj);&#125; A.基本数据类型: 根据基本数据类型的值判断是否相等. 相等返回true, 反之返回false&emsp;&emsp;注意: 两端数据类型可以不同, 在不同的情况下, 也可以返回true.B.引用数据类型: 比较引用类型变量的地址值是否相等.&emsp;&emsp;而我们希望比较的两个对象的属性值都相同的情况下返回true的话, 要重写Object类的equals(Object obj)方法&emsp;&emsp;像String类 File类 Date类…重写了Object类的equals()方法, 比较是两个对象的”实体内容”是否完全相同 ② toString() 当我们输出一个对象的引用时, 会默认调用toString()方法. 当我们没有重写Object类的toString()方法时, 打印的就是对象所在的类, 以及对象实体在堆空间的位置 而我们一般需要重写Object类的toString()方法, 将此对象的各个属性值返回. 像String类、Date、File类、包装类都重写了toString()方法. 1234//Object类的toString()public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode());&#125; String的内存结构: 三.包装类Wrapper Class, 包装类均位于java.lang包下 基本数据类型由于不是类, 不能够使用Java类库里提供的大量的方法. 所以在设计上, 我们让每一个基本数据类型都对应一个类, 同时数据存储的范围还不变. 此时, 相当于基本数据类型就具有了类的特点. 这些类即为包装(wrapper 或封装类) boolean ==&gt; Boolean byte&emsp;&emsp;==&gt; Byte short &emsp; ==&gt; Short int &emsp; &emsp; ==&gt; Integer long&emsp;&emsp;==&gt; Long char&emsp;&emsp;==&gt; Character float&emsp;&emsp;==&gt; Float double&emsp;==&gt; Double 需要掌握的: 基本数据类型、包装类、String类之间的转换! 简易理解: 基本数据类型与对应的包装类有自动装箱、自动拆箱 (JDK5.0之后) 1234//如下:int i = 10;Integer i1 = i;//自动装箱int j = i1;//自动拆箱 基本数据类型、包装类—-&gt;String类: 调用String类的重载的valueOf(Xxx xx); String类—-&gt;基本数据类型、包装类: 调用相应的包装的parseXxx(String str); 123//注意:String str = \"123\";int i = (int)str;//是错误的转换法. 特别的: Boolean的默认初始化值为null, 而boolean的默认初始化值为false; 12Boolean b = new Boolean(\"true\");//除了这样传参之外, 其他传参均为false//不会报java.lang.NumberFormatException","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"继承性","slug":"JavaSE4-1","date":"2019-03-19T12:38:13.000Z","updated":"2019-10-06T09:36:17.000Z","comments":true,"path":"JavaSE4-1.html","link":"","permalink":"https://blog.crainyday.com/JavaSE4-1.html","excerpt":"面向对象特征二:继承性方法的重写super关键字子类对象的实例化过程","text":"面向对象特征二:继承性方法的重写super关键字子类对象的实例化过程 一.继承性1.为什么要有继承性:&emsp;&emsp;有一些东西拥有某些公共的特性, 将他们相同的部分抽取出来放在一起, 方便代码的复用与修改2.通过”class A extends B“类实现类的继承:&emsp;&emsp;子类: A; 父类(或基类SuperClass): B3.子类继承父类以后, 父类中声明的属性、方法, 子类就可以获取到.&emsp;&emsp;明确: 当父类中有私有的属性或方法时, 子类同样可以获取得到, 只是由于封装性的设计, 使得子类不可以直接调用罢了.&emsp;&emsp;子类除了通过继承, 获取父类的结构之外, 还可以定义自己的特有的成分.extends:子类是对父类功能的“扩展”, 明确子类不是父类的子集.4.Java中类的继承性只支持单继承: 一个类只能继承一个父类. 反之, 一个父类可以有多个子类.5.子父类是相对的概念. 二.orverwrite or override方法的重载与重写的区别?重载: “两同一不同”: 同一个类, 同一个方法名, 不同的参数列表. 注: 方法的重载与方法的返回值无关!构造器也是可以重载的重写: (前提: 在继承的基础之上, 子类在获取了父类的结构以后, 可以对父类中同名的方法进行“重构”) 方法的返回值, 方法名, 形参列表形同; 权限修饰符不小于父类的同名方法; 子类方法的异常类型不大于父类的; 两个方法要同为static或同为非static. 三.super1.super: 相较于关键字this, 可以修饰属性、方法、构造器2.super修饰属性、方法: 在子类的方法、构造器中, 通过“super.属性”或者”super.方法”的形式, 显式的调用父类的指定属性或方法. 尤其是, 当子类与父类有同名的属性、或方法时, 调用父类中的结构的话, 一定要用“super.”3.通过“super(形参列表)”, 显式的在子类的构造器中, 调用父类指定的构造器!&emsp;&emsp;任何一个类(除Object类)的构造器的首行, 要么显式的调用本类中重载的其它的构造器“this(形参列表)”或显式的调用父类中指定的构造器“super(形参列表)”, 要么默认的调用父类空参的构造器”super()” “super(形参列表)”或”this(形参列表)”只能出现一个&emsp;&emsp;建议在设计类时, 提供一个空参的构造器! 四.子类对象的实例化先构建(调用父类的构造器构建)父类的内容, 再构建子类的内容 为了直观的理解, 可以运行一下代码, 看输出的结果: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//子类对象实例化的全过程public class TestDog &#123; public static void main(String[] args) &#123; Dog d = new Dog(); d.setAge(10); d.setName(\"小明\"); d.setHostName(\"花花\"); System.out.println(\"name:\" + d.getName() + \" age:\" + d.getAge() + \" hostName:\" + d.getHostName()); System.out.println(d.toString()); &#125;&#125;// 生物class Creator &#123; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Creator() &#123; super(); System.out.println(\"this is Creator's constructor\"); &#125;&#125;// 动物类class Animal extends Creator &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Animal() &#123; super(); System.out.println(\"this is Animal's constructor\"); &#125;&#125;// 狗class Dog extends Animal &#123; private String hostName; public String getHostName() &#123; return hostName; &#125; public void setHostName(String hostName) &#123; this.hostName = hostName; &#125; public Dog() &#123; super(); System.out.println(\"this is Dog's constructor\"); &#125;&#125; 输出结果为: 12345this is Creator's constructorthis is Animal's constructorthis is Dog's constructorname:小明 age:10 hostName:花花Dog类的对象dd在堆空间内的信息","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"封装性","slug":"JavaSE3-3","date":"2019-03-19T08:08:05.000Z","updated":"2019-10-06T09:36:07.000Z","comments":true,"path":"JavaSE3-3.html","link":"","permalink":"https://blog.crainyday.com/JavaSE3-3.html","excerpt":"面向对象之封装性构造器this关键字package与import","text":"面向对象之封装性构造器this关键字package与import 一.封装性面向对象的特征一: 封装与隐藏 问题: 当创建了类的对象以后, 如果直接通过”对象.属性”的方式对相应的对象属性赋值的话, 可能会出现不满足实际情况的意外, 我们考虑不让对象来直接作用属性, 而是通过”对象.方法”的形式, 来控制对象对属性的访问. 实际情况中, 对属性的要求就可以通过方法来体现. 封装性的思想: ①将类的属性私有化; ②提供公共的方法(setter&amp;getter)来实现调用. A.四种权限修饰符 1.权限从大到小为：public protected 缺省 private2.四种权限都可以用来修饰属性、方法、构造器3.修饰类的话：public 缺省(default)类只能被同一个包中的类访问 二.构造器类的第三个成员: 构造器(constructor 构造方法) A.构造器的作用①创建对象 ②给创建的对象的属性赋值 B.构造器的特征①与类名一致②没有返回值类型③无return与语句 ④不能被static|final|abstract|native本地的|synchronized同步的 1.设计类时, 若不显式声明类的构造器的话, 程序会默认提供一个空参的构造器.. 2.一旦显式的定义类的构造器, 那么默认的构造器就不再提供. 3.如何声明类的构造器. 格式: 权限修饰符 类名(形参){ } 4.类的多个构造器之间构成重载 类对象的属性赋值的先后顺序: ①属性的默认初始化 ②属性的显式初始化 ③通过构造器给属性初始化 ④通过”对象.方法”的方式给属性赋值 三.thisthis: 1.使用在类中, 可以用来修饰属性、方法、构造器2.表示当前对象或者是当前正在创建的对象3.当形参与成员变量重名时, 如果在方法内部需要使用成员变量, 必须添加this来表明该变量时类成员4.在任意方法内, 如果使用当前类的成员变量或成员方法可以在其前面添加this, 增强程序的阅读性5.在构造器中使用“this(形参列表)”显式的调用本类中重载的其它的构造器&emsp;&emsp;①要求“this(形参列表)”要声明在构造器的首行!&emsp;&emsp;②类中若存在n个构造器, 那么最多有n-1构造器中使用了this.6.静态方法中不能使用this和super关键字 例子: 点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TestPerson&#123; public static void main(String[] args) &#123; Person p1 = new Person(); System.out.println(p1.getName() + \":\" + p1.getAge()); Person p2 = new Person(\"BB\",23); int temp = p2.compare(p1); System.out.println(temp); &#125;&#125;class Person&#123; private String name; private int age; public Person()&#123; this.name = \"AA\"; this.age = 1; &#125; public Person(String name)&#123; this(); this.name = name; &#125; public Person(String name,int age)&#123; this(name); this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void eat()&#123; System.out.println(\"eating\"); &#125; public void sleep()&#123; System.out.println(\"sleeping\"); this.eat(); &#125; //比较当前对象与形参的对象的age谁大。 public int compare(Person p)&#123; if(this.age &gt; p.age) return 1; else if(this.age &lt; p.age) return -1; else return 0; &#125;&#125; 四.package与importpackage: 声明源文件(即当前文件)所在的包(即文件夹), 必须写在程序的第一行. 每“.”一次, 表示一层文件目录; 包名都要小写. import: 1)显式导入指定包下的类或接口 2)写在包的声明和源文件之间 3)如果需要引入多个类或接口, 那么并列写出 4)如果导入的类是java.lang包下的, 如: System String Math等, 就不需要显式的声明. 5)理解.*的概念.比如java.util.*; 6)如何处理同名类的导入. 如: 在util包和sql包下同时存在Date类. 7)import static 表示导入指定类的static的属性或方法 8)导入java.lang.*只能导入lang包下的所有类或接口, 不能导入lang的子包下的类或接口","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"面向对象1.2","slug":"JavaSE3-2","date":"2019-03-19T03:10:59.000Z","updated":"2019-10-06T09:29:40.000Z","comments":true,"path":"JavaSE3-2.html","link":"","permalink":"https://blog.crainyday.com/JavaSE3-2.html","excerpt":"方法的重载可变个数的形参的方法Java的值传递机制","text":"方法的重载可变个数的形参的方法Java的值传递机制 一.overload(重载)1.重载要求: 同一个类中 方法名必须相同 方法的参数列表不同(①参数的个数不同②参数类型不同)注意: 方法的重载与方法的返回值类型没有关系! 123456789101112131415161718192021222324//如下的四个方法构成重载//定义两个int型变量的和public int getSum(int i,int j)&#123; return i + j;&#125;//定义三个int型变量的和public int getSum(int i,int j,int k)&#123; return i + j + k;&#125;//定义两个double型数据的和public double getSum(double d1,double d2)&#123; return d1 + d2;&#125;//定义三个double型数组的和public void getSum(double d1,double d2,double d3)&#123; System.out.println(d1 + d2 + d3);&#125;//如下两个方法不能与如上的几个方法构成重载//public int getSum1(int i,int j,int k)&#123;//方法名必须相同// return i + j + k;//&#125;//public void getSum(int i,int j,int k)&#123;//与方法的返回值类型// System.out.println(i + j + k);//&#125; 二.可变个数的形参的方法可变个数的形参的方法(JDK5.0之后的特性): 1.格式: 对于方法的形参: 数据类型 … 形参名 2.可变个数的形参的方法与同名的方法之间构成重载 3.可变个数的形参在调用时, 个数从0开始, 到无穷多个都可以 4.使用可变多个形参的方法与方法的形参使用数组是一致的 5.若方法中存在可变个数的形参, 那么一定要声明在方法形参的最后 6.在一个方法中, 最多声明一个可变个数的形参 点击显/隐内容 1234567891011121314151617181920212223242526//如下四个方法构成重载//在类中一旦定义了重载的可变个数的形参的方法以后, 下面的前两个方法可以省略 public void sayHello()&#123; System.out.println(\"hello world!\"); &#125; public void sayHello(String str1)&#123; System.out.println(\"hello \" + str1); &#125; //可变个数的形参的方法 public void sayHello(String ... args)&#123; for(int i = 0;i &lt; args.length;i++)&#123; System.out.println(args[i] + \"$\"); &#125; &#125; public void sayHello(int i,String ... args)&#123; //public void sayHello(String ... args,int i)&#123;//这样不对 System.out.println(i); for(int j = 0;j &lt; args.length;j++)&#123; System.out.println(args[j] + \"$\"); &#125; &#125; public void sayHello1(String[] args)&#123; for(int i = 0;i &lt; args.length;i++)&#123; System.out.println(args[i]); &#125; &#125; 三.Java的值传递机制1.方法的参数传递 形参: 方法声明时, 方法小括号内的参数;实参: 调用方法时, 实际传入的参数的值 规则: Java中的参数传递机制: 值传递机制 ①形参是基本数据类型的: 将实参的值传递给形参的基本数据类型的变量②形参是引用数据类型的: 将实参的引用类型变量的值(对应的堆空间的对象实体的首地址值)传递给形参的引用类型变量. 12345678910111213141516171819202122//例1:class Test1&#123; public static void main(String[] args) &#123; Test1 tt = new Test1(); int i = 10; int j = 5; System.out.println(\"i:\" + i + \" j:\" + j);//i : 10 j : 5/* //直接交换变量i与j的值 int temp = i; i = j; j = temp;*/ tt.swap(i, j);//通过方法交换, 将i的值传递给m，j的值传递给n, 实际上i与j的值根本没有交换 System.out.println(\"i:\" + i + \" j:\" + j);//i : 10 j : 5 &#125; //定义一个方法，交换两个变量的值 public void swap(int m,int n)&#123; int temp = m; m = n; n = temp; System.out.println(\"m:\" + m + \" n:\" + n); &#125;&#125; 若直接用注释部分的代码交换i与j可以交换, 使用swap方法以后: 实际上i与j本身的值根本没有交换 12345678910111213141516171819202122//例2:public class Test1 &#123; public static void main(String[] args) &#123; Test1 tt = new Test1(); DataSwap ds = new DataSwap(); System.out.println(\"ds.i:\" + ds.i + \" ds.j:\" + ds.j); tt.swap(ds); System.out.println(ds); System.out.println(\"ds.i:\" + ds.i + \" ds.j:\" + ds.j); &#125; //交换元素的值 public void swap(DataSwap d)&#123; int temp = d.i; d.i = d.j; d.j = temp; System.out.println(d);//打印引用变量d的值 &#125;&#125;class DataSwap&#123; int i = 10; int j = 5;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"面向对象1.1","slug":"JavaSE3-1","date":"2019-03-19T02:07:23.000Z","updated":"2019-10-06T09:29:25.000Z","comments":true,"path":"JavaSE3-1.html","link":"","permalink":"https://blog.crainyday.com/JavaSE3-1.html","excerpt":"面向对象的初步认识 什么是面向对象? 如何面向对象? 为什么是面向对象?还面向什么吗?","text":"面向对象的初步认识 什么是面向对象? 如何面向对象? 为什么是面向对象?还面向什么吗? 一.面向对象的初步认识1.(了解)面向对象vs面向过程例:实现人把大象装进冰箱 面向对象: 1234567891011121314public class 人&#123;//可以这么理解 open()&#123;//打开冰箱 &#125; put()&#123;//将大象放进冰箱 &#125; close()&#123;//关闭冰箱 &#125; main()&#123; 人 = new 人(); 人.open(); 人.put(); 人.close(); &#125;&#125; 面向过程: ①人打开冰箱; ②将大象放进冰箱; ③关闭冰箱 2.面向对象的编程专注于类的设计! 1）一个项目或工程, 不管多庞大, 一定是有一个一个类构成的.2）类是抽象的, 好比是制造汽车的图纸. 而具体的一辆一辆的车, 是根据图纸制造的, 实际上就是类的实例化(即对象) 3.完成一个项目(或功能)的思路 1）所要完成的功能对应的类的对象是否存在.2）若存在, 则通过对象直接调用对应的类中的属性或方法即可.3）若不存在, 需要创建类的对象.甚至说, 类都不存在, 就需要设计类. 4.面向对象编程的三条主线 1）类及类的构成成分:属性 方法 构造器 代码块 内部类2）面向对象编程的特征:封装性 继承性 多态性(抽象性)3）其它的关键字:this super package import static final abstract interface … 二.类及对象1.关于类的设计 2.类的组成成分: 1)属性(成员变量, Field) 2)方法(成员方法, 函数, Method) 2.1属性:成员变量 vs 局部变量相同点: 1.遵循变量声明的格式: 数据类型 变量名 = 初始化值 2.都有作用域 不同点: 1.声明的位置的不同: 成员变量: 声明在类里, 方法外; 局部变量: 声明在方法内, 方法的形参部分, 代码块内 &emsp;&emsp;&emsp;&emsp;2.成员变量的修饰符有四个:public private protected 缺省, 局部变量没有修饰符, 与所在的方法修饰符相同 &emsp;&emsp;&emsp;&emsp;3.初始化值: 一定会有初始化值, 成员变量:如果在声明的时候, 不显式的赋值, 那么不同数据类型会有不同的默认初始化值.局部变量: 一定要显式的赋值.(局部变量没有默认初始化值) byte short int long ==&gt;0 float double ==&gt;0.0 char ==&gt;空格 boolean ==&gt;false 引用类型变量==&gt;null &emsp;&emsp;&emsp;&emsp;4.二者在内存中存放的位置不同:成员变量存在于堆空间中; 局部变量: 栈空间中 总结: 关于变量的分类: 1)按照数据类型的不同: 基本数据类型(8种)&amp;引用数据类型 2)按照声明的位置的不同: 成员变量 &amp; 局部变量 2.2 方法: 提供某种功能的实现 1)实例: 123public void eat()&#123;//方法体&#125;public String getName()&#123;&#125;public void setName(String n)&#123;&#125; 格式: 权限修饰符 返回值类型(void:无返回值/具体的返回值) 方法名(形参){} 2)关于返回值类型: void: 表明此方法不需要返回值 有返回值的方法: 在方法的最后一定有return + 返回值类型对应的变量 记忆: void 与return不可以同时出现一个方法内. 像一对“冤家”. 3)方法内可以调用本类的其他方法或属性, 但是不能在方法内再定义方法! 3.面向对象编程的思想的落地法则一: 1)设计并创建类及类的成分2)实例化类的对象3)通过“对象.属性”或”对象.方法”的形式完成某项功能 4.类的初始化的内存解析 4.1 内存划分的结构: 栈(stack):局部变量、对象的引用名、数组的引用名 堆(heap):new 出来的“东西”(如: 对象的实体, 数组的实体), 含成员变量 方法区: 含字符串常量 静态域: 声明为static的变量 4.2 理解的基础上, 学会基本的创建的类的对象在内存中的运行.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"Java数组","slug":"JavaSE2-3","date":"2019-03-18T12:03:27.000Z","updated":"2019-10-06T09:29:17.000Z","comments":true,"path":"JavaSE2-3.html","link":"","permalink":"https://blog.crainyday.com/JavaSE2-3.html","excerpt":"Java基本语法续 Java数组","text":"Java基本语法续 Java数组 一.一维数组数组: 相同数据类型的数据的组合. 1234567891011121314151617181920212223//如: 多个intint score1 = 72;int score2 = 90;int score3 = 59;//使用数组存储int[] scores1 = new int[]&#123;72,90,59&#125;;//静态初始化:声明并初始化数组与给数组相应的元素赋值操作同时进行int scores2[] = new int[3];//动态初始化:声明并初始化数组与数组相应的元素赋值操作分开进行scores2[0] = 72;scores2[1] = 90;scores2[2] = 59;int[] arr = &#123;72,90,59&#125;;//这样可以//声明数组的错误写法:/*String[] names = new String[5]&#123;\"AA\",\"BB\",\"CC\"&#125;;//这样用时不能指定大小int i[10];int i = new int[];//i是int型int[] arr;arr = &#123;10,11,12&#125;;//两句分开不行, 合并为一句可以*/System.out.println(scores2.length);//求数组长度for(int i = 0;i &lt; scores1.length;i++)&#123;//遍历数组 System.out.println(scores1[i]);&#125; 注意 &emsp;&emsp;1.不管是动态还是静态初始化数组, 一定在创建的时候, 就指明了数组的长度&emsp;&emsp;2.如何引用数组元素: 通过数组的下角标的方式. 下角标从0开始, 到n-1结束.其中n为数组的长度 &emsp;&emsp;3.关于数组元素的默认初始化值 byte short int long 而言:0 float double 而言:0.0 char而言:空格 boolean而言:false 引用类型变量而言:null 4.数组的内存结构内存结构图: 在JAVA中, 凡是new出来的东西, 都会被默认初始化并赋值. new 出来的东西都存放在 堆中 对于数组来讲: 字符串: 面向对象之后再看 二.二维数组123456789101112131415161718192021222324//1.声明并初始化//一维:类型后一个[]int[] i = new int[12];i[0] = 12;int[] j = new int[]&#123;12,3&#125;;//二维:类型后两个[]String[][] str = new String[4][3];//4行3列String[][] str1 = new String[4][];//4行, 每行的列可能不一样str1[0] = new String[3];//...str1[3] = new String[5];int[][] arr = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6&#125;&#125;;//2.如何引用二维数组的元素arr[1][0] = 12;//3.二维数组的长度:arr.length;//3arr[1].length;//2//4.遍历二维数组for(int i = 0;i &lt; arr.length;i++)&#123; for(int j = 0;j &lt; arr[i].length;j++)&#123; System.out.print(arr[i][j] + \"\\t\"); &#125; System.out.println(); &#125; 5.二维数组的结构: 三.数组中常见的异常123456789101112131415161718192021//1.数组下标越界的异常:java.lang.ArrayIndexOutOfBoundsExceptionint[] i = new int[10];//i[0] = 90;//i[10] = 99;//最大i[9]//for(int m = 0;m &lt;= i.length;m++)&#123;// System.out.println(i[m]);//最大i[i.length-1]//&#125;//2.空指针的异常:NullPointerException//第一种://boolean[] b = new boolean[3];//b = null;//System.out.println(b[0]);//b已经为空//第二种://String[] str = new String[4];//System.out.println(str[3].toString());//没有初始化str[3]//第三种:int[][] j = new int[3][];//j[2][0] = 12;//j的第二维还未初始化 四.数组中常用的算法求数组元素的最大值&amp;最小值&amp;和&amp;平均数数组的复制和反转情况1: 浅复制, 两个数组的引用指向同一片内存空间, 改变一个的内容另一个也会改变 12int[] arr1 = new int[]&#123;10,11,12&#125;;int[] arr2 = arr1; 情况2: 深复制, 将一片内存里的内容, 复制到另一片内存里(如何实现复制) 12345int[] arr1 = new int[]&#123;10,11,12&#125;;int[] arr2 = new int[arr1.length];for(int i = 0;i &lt; arr1.length;i ++)&#123; arr2[i] = arr1[i];&#125; 数组的反转：数组元素的反转 123456789101112//①for(int i = 0;i &lt; arr.length/2;i++)&#123; int temp = arr[i]; arr[i] = arr[arr.length-1 - i]; arr[arr.length - 1 - i] = temp;&#125;//②for (int x = 0, y = arr.length - 1; x &lt; y; x++, y--) &#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp;&#125; 拓展:String str = “abcdefg”; 数组的排序 插入排序: 直接插入排序、折半插入排序、Shell排序 交换排序: 冒泡排序、快速排序(或分区交换排序) 选择排序: 简单选择排序、堆排序 归并排序 基数排序 使用冒泡排序使数组元素从小到大排列 123456789for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125; 使用直接选择排序使数组元素从小到大排列 1234567891011121314for(int i = 0; i &lt; arr.length - 1; i++)&#123; int t = i;//默认i处是最小的 for(int j = i;j &lt; arr.length;j++)&#123; //一旦在i后发现存在比其小的元素，就记录那个元素的下角标 if(arr[t] &gt; arr[j])&#123; t = j; &#125; &#125; if(t != i)&#123; int temp = arr[t]; arr[t] = arr[i]; arr[i] = temp; &#125;&#125; 还可以调用: Arrays工具类: Arrays.sort(arr);","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"Java基本语法2","slug":"JavaSE2-2","date":"2019-03-18T10:59:37.000Z","updated":"2019-10-06T09:29:07.000Z","comments":true,"path":"JavaSE2-2.html","link":"","permalink":"https://blog.crainyday.com/JavaSE2-2.html","excerpt":"Java的一些基本语法续 流程控制 （数组）后续","text":"Java的一些基本语法续 流程控制 （数组）后续 4.流程控制A.顺序结构程序从上往下的顺序执行 B.分支结构if-else &amp; switch-case 12345678910111213141516①if(条件表达式)&#123; &#125;②if(条件表达式)&#123; //执行的语句1; &#125;else&#123; //执行的语句2; &#125;③if(条件表达式1)&#123; //执行的语句1; &#125;else if(条件表达式2)&#123; //执行的语句2; &#125;else if( 条件表达式3)&#123; //执行的语句3; &#125;... &#125;else&#123; //执行的语句; &#125; [注意] &emsp;&emsp;1.一旦满足某个条件表达式, 则进入其执行语句块执行, 执行完毕, 跳出当前的条件判断结构, 不会执行剩下的条件结构语句. &emsp;&emsp;2.如果多个条件表达式之间为“互斥”关系, 多个结构可以上下调换顺序如果多个条件表达式之间为“包含”关系, 要求条件表达式范围小的写在范围大的上面. 123456789switch(变量)&#123; case 值1: //break; case 值2: //break; ... default: break;&#125; [注意] 1.变量可以为如下的数据类型:byte short int char 枚举 String(jdk1.7)2.case后只能填写变量的值, 不能写范围.3.default是可以省略的, 并且其位置也是灵活的, 但通常将其放在case语句之后.4.一旦满足某个case语句, 则进入执行其操作, 直至遇到break或者程序终止.5.若要判断的语句的条件满足switch变量的数据类型, 且值不多的情况下, 建议选择switch-case .除此之外, 选择if-else. [例题]从键盘输入三个int类型的数存入三个int变量, 利用if-else实现对三个数的排序, 并输出.[例题]输入一个年月日, 像: 2019/7/20, 输出该天是这一年中的哪一天. C.循环结构格式: 12345678910111213for(①;②;③)&#123; ④&#125;①while(②)&#123; ④ ③&#125;①do&#123; ④ ③&#125;while(②); ①初始化条件②循环条件③迭代部分④循环体 注意 1.不同的循环结构之间可以相互转换&emsp;&emsp; 2.while和do-while的区别; do-while程序至少会执行一次 嵌套循环: 上述循环体嵌套循环体若外层循环执行m次, 内层循环执行n次, 整个程序执行m*n次 . [例题]输出九九乘法表 [例题]输出100内的质数.(两种) 无限循环结构: 123456789101112131415for(;;)&#123; ... if( )&#123; break; &#125; ...&#125;//或者while(true)&#123; ... if( )&#123; break; &#125; ...&#125; 我们往往会在无限循环结构内部提供循环的终止条件, 使用break关键字跳出循环.避免死循环. D.break&amp;continuebreak:使用switch-case结构或者循环结构中在循环结构中, 一旦执行到break, 就跳出当前循环 . continue:使用在循环结构中, 一旦执行到continue, 就跳出当次循环, 继续执行下一次循环. 1234567for(int i = 1;i &lt;= 10;i++)&#123; if(i % 4 == 0)&#123; //break; //程序执行结果:123 continue; //程序执行结果:123567910 &#125; System.out.print(i);&#125; 在嵌套循环中, 使用带标签的break和continue. 123456789101112label:for(int i = 1;i &lt; 5;i++)&#123; for(int j = 1;j &lt;= 10;j++)&#123; if(j % 4 == 0)&#123; //break; //continue; //break label; continue label; &#125; System.out.print(j); &#125; System.out.println();&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"Java基本语法1","slug":"JavaSE2-1","date":"2019-03-17T03:18:41.000Z","updated":"2019-10-06T09:28:58.000Z","comments":true,"path":"JavaSE2-1.html","link":"","permalink":"https://blog.crainyday.com/JavaSE2-1.html","excerpt":"Java的一些基本语法 关键字、标识符、变量、运算符 （流程控制、数组)后续","text":"Java的一些基本语法 关键字、标识符、变量、运算符 （流程控制、数组)后续 1.关键字＆标识符 关键字: 被Java语言赋予了特殊含义, 用做专门用途的字符串(单词), 关键字全是小写的 保留字: 以后可能用来作为关键字 标识符: 凡是自己可以起名字的地方都叫标识符 命名规则:&emsp;&emsp;一定要遵守, 不遵守就会报编译的错误 由26个英文字母大小写,0-9, _或 $ 组成 数字不可以开头.不可以使用关键字和保留字, 但能包含关键字和保留字.Java中严格区分大小写, 长度无限制.标识符不能包含空格. 命名规范:&emsp;&emsp;不遵守, 也不会出现编译的错误 包名: 多单词组成时所有字母都小写: xxxyyyzzz类名、接口名: 多单词组成时, 所有单词的首字母大写: XxxYyyZzz变量名、方法名: 多单词组成时, 第一个单词首字母小写, 第二个单词开始每个单词首字母大写: xxxYyyZzz常量名: 所有字母都大写, 多单词时每个单词用下划线连接: XXX_YYY_ZZZ 2.变量 Java中变量按照数据类型来分类: 基本数据类型 vs 引用数据类型(数组 类 接口) 基本数据类型 整型: byte(8 bit,-128~127) short(-32768~32767) int(默认类型,-2^31~2^31-1) long 浮点型: float double(默认类型) 字符型: char（‘ ’）16 bit 是以十六进制保存的字符,例:char ch = ‘\\u0041’;为’A’ 布尔类型: boolean (只能取值为true 或false, 不能取null) 引用数据类型 String类型: 值可以为null 数组、对象(类的实例)等，之后会一一说明. 数据类型 变量名 = 初始化值;​ 补充: 按照在类中存在的位置的不同: 成员变量 vs 局部变量​ 成员变量在声明时会被默认初始化, 因此可以在声明后直接使用, 而局部变量在使用之前必须先初始化​ 声明: long型常量需后缀”l”或”L”,long lo = 123L;​ float类型变量要后缀”f”或”F”,float f = 12.3F; 2.进制(了解) 十进制 二进制 八进制 十六进制 二进制: 计算机底层都是用二进制来存储、运算. 二进制 与十进制之间的转换.二进制在底层存储: 正数、负数都是以补码的形式存储的.(原码、反码、补码)四种进制间的转换 3.变量的运算: ①自动类型转换: 容量小的数据类型自动转换为容量大的数据类型转换. short s = 12; int i = s + 2; 注意: byte short char之间做运算, 结果为int型! ②强制类型转换: 是①的逆过程.使用“()”实现强转. 3.运算符运算符是一种特殊的符号, 用以表示数据的运算. A.算术运算符:1+ - / % ++ -- + 注意: 1) /: int i = 12; i = i / 5;地板除2) %: 取模, 结果的符号与被模数相同3) 前++: 先+1, 后运算 后++: 先运算, 后+14) +: String字符串与其他数据类型只能做连接运算, 且结果为String类型. 12sysout(\"*\" + '\\t' + '*'); vs sysout('*' + '\\t' + '*');结果为93//sysout为Java的快捷键用法, 先输入sysout, 再按\"Alt + /\", 即可打出System.out.println(); B.赋值运算符:123456789//= += -= *= /= %=int i = 12;i = i * 5;i *= 5;//与上一行代码同样的意思//[特别地]short s = 10;s = s + 5;//报编译的异常，s+5会被默认转化为int类型，再赋值给short会出错s = (short)(s + 5);//强制类型转换便不会异常s += 5;//相当于, s = s + 5, 但两者并不完全等价, 但是结果不会改变s的数据类型. C.比较运算符(关系运算符)1== &gt; &lt; &gt;= &lt;= instanceof [注意] 区分 == 与 = 区别.进行比较运算操作以后,返回一个boolean类型的值(true或false)4&gt;=3 表达的是4 &gt; 3或者 4 = 3.结果是true. if(i &gt; 1 &amp;&amp; i &lt; 10){ } 不能写为: if(1 &lt; i &lt; 10){} D.逻辑运算符(运算符的两端是boolean值)1&amp; &amp;&amp; | || ^ ! [注意]区分&amp;与&amp;&amp;的区别, 以及 | 与 || 的区别 我们使用的时候, 选择 &amp;&amp; , || 短路与、短路或 E.位运算符(两端是数值类型的数据)1&lt;&lt; &gt;&gt; &gt;&gt;&gt;(无符号右移) &amp; | ^(异或) ~(按位取反) [例子] 1.如何交换m = 12和n = 5的值 2.将60转换为十六进制输出. F.三元运算符(条件表达式) ? 表达式1 : 表达式2; 1) 既然是运算符, 一定会返回一个结果, 并且结果的数据类型与表达式1, 2的类型一致2) 表达式1与表达式2的数据类型一致.3) 使用三元运算符的, 一定可以转换为if-else. 反之不一定成立.4) ?: 可以嵌套使用 例子: 获取两个数的较大值; 获取三个数的最大值. 点击显/隐内容 1234int i = 0, j = 1;int max = (i &gt; j) ? i : j;int k = 2;int max2 = (i &gt; j) ? ((i &gt; k) ? i : k) : (( j &gt; k) ? j : k);","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"JavaSE概述","slug":"JavaSE1-0","date":"2019-03-17T02:38:04.000Z","updated":"2019-10-18T04:08:44.499Z","comments":true,"path":"JavaSE1-0.html","link":"","permalink":"https://blog.crainyday.com/JavaSE1-0.html","excerpt":"走进Java Java是什么? Java如何来的? Java干什么的?","text":"走进Java Java是什么? Java如何来的? Java干什么的? 一.关于Java ①关于Java语言, 其实它很简单, 就是我们人类与计算机交流的语言, 就像人类的语言: 英语、汉语…… ②Java之父: 詹姆斯·高斯林, 他曾说过, C语言是撑起一切的基石, C语言之父: 丹尼斯·里奇 ③Java语言由类C、C++等衍生出来, 属于完全面向对象的语言 ④Java的技术体系平台: JavaSE、JavaEE、JavaME &emsp;&emsp;在这里, 我们一般先学 JavaSE, 因为这是 Java 基石. 二.关于计算机 1.计算机软件软件: 系统软件 and 应用软件 2.人与计算机做交互: 使用计算机语言.图形化界面(GUI) vs 命令行方式(CLI): dir md rd cd cd.. cd/ del exit echo content &gt;temp.txt 3.语言的分类: 第一代: 机器语言; 第二代: 汇编语言; 第三代: 高级语言(面向过程 → 面向对象) 4.java语言的特性: ①面向对象性 ②健壮性 ③跨平台性(write once,run anywhere)—JVM不同的系统有不同的JVM(Java Virtual Machine即Java虚拟机), 所以要想编写Java程序, 就要在自己的系统上安装JVM等部件. 学习Java, 我们首先要做的, 就是安装JDK环境. 5.安装JDK及配置系统的path环境变量 1)傻瓜式安装JDK(提取码: et1y). 2)配置path: window操作系统在执行cmd命令时所要搜寻的路径. 右键单击此电脑, 之后点击属性, 再点击高级系统设置, 再点击环境变量, 如图: ​ 我们需要将jdk中bin目录所在的路径: 例如: D:\\Program Files\\Java\\jdk1.8.0_131\\bin 保存在path环境变量下. 配置 JAVA_HOME 为了方便更换我们使用的 JDK 版本，我们一般会这样配置系统 path。 新建系统变量：JAVA_HOME，值为所安装的JDK的根路径，如：D:\\Program Files\\Java\\jdk1.8.0_131。 注意：变量JAVA_HOME的值不要加 bin。 之后，将 JAVA_HOME 应用到 path 里，添加一项系统 path：%JAVA_HOME%\\bin。 当然，若是 JAVA 程序的测试人员(不负责开发)，只需装 JRE 就OK了，配置 JRE_HOME 变量和配置 JAVA_HOME 类似。 3)测试: 在命令行窗口, 任意的文件目录下, 执行javac.exe 或者java.exe都可以调用成功.​ JDK(Java Development Kit, Java语言的软件开发工具包即Java的SDK, Software Development Kit)​ JDK包含JRE(Java Runtime Environment, Java运行时环境), JRE包含JVM和一些常用的Java库类​ &gt;河床好比操作底层, jdk好比是河水, java应用程序好比是船. 6.如何编写并运行第一个java程序​ [过程]编写—-编译(javac.exe)—-运行(java.exe) 1)编写: 每一个java文件都是.java结尾的, 称为源文件[HelloWorld.java], java程序就存在于源文件中 如下, 第一个Java程序: 1234567public class HelloWorld&#123; //程序的主方法，是程序的入口 public static void main(String args[])&#123; //要执行的代码 System.out.println(\"HelloWorld\"); &#125;&#125;//假设这是在桌面上的源文件HelloWorld.java中的源代码, 执行过程如下: ①win+R键, 再输入cmd进入命令行模式, 通过cd desktop命令进入桌面 ②通过javac HelloWorld.java命令编译源文件生成字节码文件 ③通过java HelloWorld命令解释运行字节码文件, 之后控制台会输出HelloWorld 注意点：①Java源文件以“java”为扩展名. 源文件的基本组成部分是类(class), 如本例中的HelloWorld类.②一个源文件中最多只能有一个public类, 其它类的个数不限, 如果源文件包含一个public类, 则.java文件名必须与该类名一致.③Java应用程序的执行入口是main()方法, 它有固定的书写格式: public static void main(String[] args){}④Java语言严格区分大小写.⑤Java方法由一条条语句构成, 每个语句以“;”结束.⑥大括号都是成对出现的,缺一不可. 2)编译: 在源文件所在的目录下, 执行javac.exe 源文件名.java;生成一个或多个.class结尾的字节码文件 3)运行: 生成的字节码文件通过java.exe解释执行 7.会调试程序中出现的问题 8.注释: ①单行注释 // ②多行注释 / / （多行注释不能够嵌套） ③文档注释 /* / javadoc -d 文件目录名 -author -version 源文件名.java; ​ 其中文档注释是JAVA特有的9.JDK提供的关于旗下所有的包&amp;类的说明文档: API ，提取码：7c39","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://blog.crainyday.com/tags/JavaSE/"},{"name":"Java","slug":"Java","permalink":"https://blog.crainyday.com/tags/Java/"}]},{"title":"Hexo代码一键复制","slug":"copy-code","date":"2019-03-16T07:10:42.000Z","updated":"2019-04-30T06:50:44.000Z","comments":true,"path":"copy-code.html","link":"","permalink":"https://blog.crainyday.com/copy-code.html","excerpt":"有时候代码块是真的多啊, 添加一个一键复制功能吧","text":"有时候代码块是真的多啊, 添加一个一键复制功能吧 1.需要的JS文件 clipboard.min.js(提取码: p3xj) clipboard-use.js(提取码: sbsk) 将以上js文件放到主题的js文件目录下. clipboard-use.js: 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class=\"btn-copy\" data-clipboard-snippet=\"\"&gt;'; copyHtml += ' &lt;i class=\"fa fa-copy\"&gt;&lt;/i&gt;&lt;span&gt;Copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(\".highlight .code pre\").before(copyHtml); var clipboard = new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); clipboard.on('success', function(e) &#123; //您可以加入成功提示 console.info('Action:', e.action); console.info('Text:', e.text); console.info('Trigger:', e.trigger); success_prompt(COPY_SUCCESS); e.clearSelection(); &#125;); clipboard.on('error', function(e) &#123; //您可以加入失败提示 console.error('Action:', e.action); console.error('Trigger:', e.trigger); fail_prompt(COPY_FAILURE); &#125;); &#125; initCopyCode();&#125;(window, document);/** * 弹出式提示框，默认1.5秒自动消失 * @param message 提示信息 * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info * @param time 消失时间 */var prompt = function (message, style, time)&#123; style = (style === undefined) ? 'alert-success' : style; time = (time === undefined) ? 1500 : time*1000; $('&lt;div&gt;') .appendTo('body') .addClass('alert ' + style) .html(message) .show() .delay(time) .fadeOut();&#125;;// 成功提示var success_prompt = function(message, time)&#123; prompt(message, 'alert-success', time);&#125;;// 失败提示var fail_prompt = function(message, time)&#123; prompt(message, 'alert-danger', time);&#125;;// 提醒var warning_prompt = function(message, time)&#123; prompt(message, 'alert-warning', time);&#125;;// 信息提示var info_prompt = function(message, time)&#123; prompt(message, 'alert-info', time);&#125;; 2.引入JS文件将以上两个JS文件引入到主题每个页面都用的文件里, 一定要输入对你自己的src路径 12&lt;script type=\"text/javascript\" src=\"/blog/js/clipboard.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/blog/js/clipboard-use.js\"&gt;&lt;/script&gt; 3.配置样式表将下列代码添加到主题的样式表里, 根据自己的div修改 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125;//复制提示, 成功or失败.alert &#123; display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); z-index: 99999; text-align: center; padding: 24px 36px; border-radius: @border_radius_code_block; box-shadow: @boxshadow_card_normal; font-family: @fontfamily_base; font-weight: bold; font-size: @fontsize_base; &amp;.alert-success &#123; color: #ffffff; background-color: #1BC3FB; border-color: #d6e9c6; &#125; &amp;.alert-info &#123; color: #31708f; background-color: #d9edf7; border-color: #bce8f1; &#125; &amp;.alert-warning &#123; color: #8a6d3b; background-color: #fcf8e3; border-color: #faebcc; &#125; &amp;.alert-danger &#123; color: #a94442; background-color: #f2dede; border-color: #ebccd1; &#125;&#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.crainyday.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.crainyday.com/tags/Hexo/"}]},{"title":"Hexo为主题添加代码隐藏功能","slug":"hide-code","date":"2019-03-16T06:30:04.000Z","updated":"2019-04-30T06:38:53.000Z","comments":true,"path":"hide-code.html","link":"","permalink":"https://blog.crainyday.com/hide-code.html","excerpt":"写博客有时候需要添加的代码真的很多, 而我们又不想让它显示在网页上. 添加一个代码隐藏功能吧!","text":"写博客有时候需要添加的代码真的很多, 而我们又不想让它显示在网页上. 添加一个代码隐藏功能吧! &emsp;&emsp;首先, 你要明白不论添加一些什么功能, 无非是添加一些js插件实现. 1.自定义内置标签&emsp;&emsp;通过查看自定义标签的API, 发现主题自带标签脚本都会存放在themes/xxx/scripts/tag/xxx.js中 首先, 我们要注册一个自己的代码隐藏内置标签fold. 新建fold.js(提取码: 0khu)文件, 路径(没有相应目录的自建)如图: 内容:点击显/隐内容 12345678/* global hexo */// Usage: &#123;% fold ???? %&#125; Something &#123;% endfold %&#125;function fold (args, content) &#123; var text = args[0]; if(!text) text = \"点击显/隐\"; return '&lt;div&gt;&lt;div class=\"fold_hider\"&gt;&lt;div class=\"close hider_title\"&gt;' + text + '&lt;/div&gt;&lt;/div&gt;&lt;div class=\"fold\"&gt;\\n' + hexo.render.renderSync(&#123;text: content, engine: 'markdown'&#125;) + '\\n&lt;/div&gt;&lt;/div&gt;';&#125;hexo.extend.tag.register('fold', fold, &#123;ends: true&#125;); 2.消除渲染undefined问题在scripts目录下添加一个tags.js(提取码: giom)文件, 内容: 12345678910111213141516171819202122/*修复在 fold 标签里写 ```代码块```，最终会被渲染成 undefined 的问题*/const rEscapeContent = /&lt;escape(?:[^&gt;]*)&gt;([\\s\\S]*?)&lt;\\/escape&gt;/g;const placeholder = '\\uFFFD';const rPlaceholder = /(?:&lt;|&amp;lt;)\\!--\\uFFFD(\\d+)--(?:&gt;|&amp;gt;)/g;const cache = [];function escapeContent(str) &#123; return '&lt;!--' + placeholder + (cache.push(str) - 1) + '--&gt;';&#125;hexo.extend.filter.register('before_post_render', function(data) &#123; data.content = data.content.replace(rEscapeContent, function(match, content) &#123; return escapeContent(content); &#125;); return data;&#125;);hexo.extend.filter.register('after_post_render', function(data) &#123; data.content = data.content.replace(rPlaceholder, function() &#123; return cache[arguments[1]]; &#125;); return data;&#125;); 3.设置默认折叠代码将下列代码复制到你的主题的JS(每个页面都会加载的JS)文件中 12345678$(document).ready(function()&#123; $(document).on('click', '.fold_hider', function()&#123; $('&gt;.fold', this.parentNode).slideToggle(); $('&gt;:first', this).toggleClass('open'); &#125;); //默认情况下折叠 $(\"div.fold\").css(\"display\", \"none\");&#125;); 4.配置fold显示样式将下述代码复制到你的主题样式文件里: 12345678910.hider_title&#123; font-family: \"Microsoft Yahei\"; cursor: pointer;&#125;.close:after&#123; content: \"▼\";&#125;.open:after&#123; content: \"▲\";&#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.crainyday.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.crainyday.com/tags/Hexo/"}]},{"title":"利用Hexo和GitHub搭建一个静态博客","slug":"Hexo2","date":"2019-03-16T03:24:46.000Z","updated":"2019-10-18T08:42:22.251Z","comments":true,"path":"Hexo2.html","link":"","permalink":"https://blog.crainyday.com/Hexo2.html","excerpt":"没有服务器也可以哦 用github pages与Hexo搭建免费的个人博客","text":"没有服务器也可以哦 用github pages与Hexo搭建免费的个人博客 之前讲过了利用gitee搭建静态博客, 现在说一下利用GitHub搭建博客 1.gitee与GitHub比较 gitee是国内的仓库, 访问速度会比GitHub快点, 也比GitHub稳定一点. 但都可以利用CDN来加速访问, 之后会提到如何利用CDN加速. GitHub可以使用自己的域名, 自定义自己的博客url, 这项服务是免费的. gitee也可以, 但是这项服务需要收费. 2.前期准备 有一个github账号, 没有就先去注册一个 本地安装node.js, 配置教程 本地安装hexo，安装完NodeJS，用npm全局安装hexo，命令：npm install hexo-cli -g 本地安装git for windows 3.创建Github仓库, 开启pages服务 点击右上角的加号, 再点击 New repository 创建仓库，创建时先选上创建一个 README，方便测试; 之后进入仓库; 点击 setting，向下滚动滚轮找到Github Pages，在Source下面选择 master branch 开启服务.如图： 4.初始化博客并上传①新建空目录如图: ②安装插件打开命令行, 依次执行下列命令(路径改为你自己的). 执行完hexo s后, 访问http://localhost:4000 便是本地博客. 123456789101112f:cd testnpm install hexo-cli -g #之前没安装hexo的执行此命令hexo initnpm install hexo-server --savenpm install hexo-deployer-git --save#清理项目&amp;&amp;生成项目文件&amp;&amp;本地运行项目 hexo clean &amp;&amp; hexo g &amp;&amp; hexo shexo cleanhexo ghexo s#修改完配置信息，再 hexo d 上传到远程仓库hexo d ③配置全局_config.yml文件12345678910111213title: CRainyDay's Blogauthor: CRainyDaylanguage: zh-CN#urlurl: https://crainyday.github.io/test #这里填写GitHub Pages生成的urlroot: /test #博客根目录，若是url为：https://crainyday.github.io，即一个二级域名，root: /theme: landscape #网站应用的主题名字,可以换为你喜欢的主题#与hexo d相关的配置deploy: type: git repo: https://github.com/用户名/仓库名.git #你的GitHub仓库地址 branch: master 这里是一些Hexo 主题，你可以选择一个自己喜欢的主题。下载后放在 themes 目录下即可。 有关其他的主题配置，请看各主题的 README 文档。 ④上传到GitHub接着上述命令执行hexo d命令. 第一次执行该命令, 期间第一次上传时，需要输入GitHub的账号密码. 上传之后, 更新一下Pages等一会访问给出的url, 便可以进入你的博客. 5.自定义博客url①创建CNAME文件在本地博客根目录的source目录下, 新建CNAME文件(无后缀名). 内容为你的二级域名或其他域名 ②解析域名选择CNAME解析, 添加二级域名, 记录值为GitHub Pages提供的. 其实就是 “你的用户名.github.io” ③修改全局_config.yml文件只需修改博客的url和网站根目录即可. 12url: http://test.rainyday.toproot: / ④更新GitHub Pages","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.crainyday.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.crainyday.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog.crainyday.com/tags/GitHub/"}]},{"title":"VPS和shadowsocks搭建VPN","slug":"VPN","date":"2019-03-15T09:06:14.000Z","updated":"2019-10-01T13:57:44.000Z","comments":true,"path":"VPN.html","link":"","permalink":"https://blog.crainyday.com/VPN.html","excerpt":"想不想要自己动手搭建一个VPN呢? 在这里, 用VPS和shadowsocks搭建的 VPN , 手机端也能用","text":"想不想要自己动手搭建一个VPN呢? 在这里, 用VPS和shadowsocks搭建的 VPN , 手机端也能用 1.前期准备 购买一个国外的VPS, 建议CentOS7系统 安装XShell, 用来远程连接你的VPS 安装XFTP, 用来向你的VPS传输文件. (用 XShell 连接, vim 编写文件也行.) 2.安装&amp;配置shadowsocks&emsp;&emsp;启动XShell, 输入主机, 点击用户身份验证, 输入用户名: root, 和你的root密码 A.先用shell命令安装pip12345678#有yum可以用yum安装pipyum install python-setuptoolseasy_install pip#没有的可以用用下面命令安装pip, 没有python需要先安装pythonwget https://bootstrap.pypa.io/get-pip.pypython get-pip.py#安装完pip后, 用pip安装shadowsockspip install shadowsocks B.配置VPS上的shadowsocks&emsp;&emsp;启动XFTP, 同XShell连接远程VPS, 将新建的shadowsocks.json文件, 上传到/etc目录下 shadowsocks.json(提取码: 4k4l,下载的话请重命名)文件要用UTF-8编码, 内容如下: 1234567891011&#123; \"server\": \"你的VPSIPv4地址\", \"local_address\": \"127.0.0.1\", \"local_port\": 1080, \"port_password\": &#123; \"443\": \"自己随便设置一个连接这个VPN的密码\" &#125;, \"timeout\": 300, \"method\": \"aes-256-cfb\", \"fast_open\": false&#125; C.开启shadowsocks服务1234567891011#用以下命令之一关闭防火墙service iptables stopservice firewalld stop#禁止firewall开机启动systemctl disable firewalld.service#加载shadowsocks配置ssserver -c /etc/shadowsocks.json#开启shadowsocks服务ssserver -c /etc/shadowsocks.json -d start#关闭shadowsocks服务ssserver -c /etc/shadowsocks.json -d stop 3.本地配置shadowsocks Android shadowsocks Windows shadowsocks IPhone shadowsocks(百度网盘提取码: lagp, 链接失效请向博主索取) A.Windows配置下载解压文件, 运行exe文件, 如图配置: 右键点击状态栏中的本软件, 再点击”启用系统代理”即开启VPN B.Android配置(IPhone一样)","categories":[],"tags":[{"name":"VPN","slug":"VPN","permalink":"https://blog.crainyday.com/tags/VPN/"}]},{"title":"windows上配置NodeJS和npm","slug":"NodeJS","date":"2019-03-15T02:53:04.000Z","updated":"2019-10-18T05:08:48.955Z","comments":true,"path":"NodeJS.html","link":"","permalink":"https://blog.crainyday.com/NodeJS.html","excerpt":"本文主要讲如何在windows上配置NodeJS和npm 用github pages或gitee pages(中国的github)与Hexo搭建免费的个人博客","text":"本文主要讲如何在windows上配置NodeJS和npm 用github pages或gitee pages(中国的github)与Hexo搭建免费的个人博客 1.前期了解 Node.js 是一个基于 Chrome v8 引擎的 JS 运行环境. Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型, 使其轻量又高效. Node.js 使用包管理器 npm来管理所有模块的安装、配置、删除等操作, 使用起来非常方便, 但想配置好npm的使用环境稍微有点复杂. 2.本地安装Node.js 进入NodeJS官网下载, 我们这里选择下载LTS版本的, LTS代表长期支持版本, 新手建议使用这个版本, 因为这个版本使用的人最多, 出问题百度一般都能找到解决方案. 下载完后安装，不要急着点击 Next。 下载完成后傻瓜安装就好, 可以选择软件安装目录, 建议不要安在C盘. 安装到这一步(如下图)时注意, 这一步是选择安装哪些模块, 默认是全部安装, 对于新手来说建议全部安装. 点开那个add path选项前面的+号, 会看到, 把NodeJS和NPM这两个模块的命令路径添加到系统路径里, 这对我们来说就非常方便了. 之后点击next继续下一步, 然后确认信息, 点击Install开始安装. 3.测试是否安装成功 按下键盘的windows+R键, 输入cmd, 回车, 之后就打开了命令行, 依次输入下列命令. 12node -vnpm -v 如果正确输出版本号(如下图), 说明我们的NodeJS和NPM就安装好. 若没有成功, 需要手动配置系统path。 4.配置node和npm到系统path 若步骤3测试失败, 请看此步骤, 否则跳过. ①右键单击此电脑, 之后点击属性(如图) ②之后, 依次点击”高级系统设置”、”系统变量”, 将你的NodeJS的安装目录(例:D:\\Program Files\\nodejs)添加到系统path里面. 如图 ③之后, 进行步骤3测试就能输出版本号了. 5.修改npm的缓存目录和全局目录路径 在你的NodeJS的安装目录下, 新建两个空目录node_cache和node_global, 如图: 之后, 打开命令行, 执行以下两个命令(命令中的路径改为你的路径), 这就将npm的全局模块目录和缓存目录配置到我们刚才新建的那两个空目录. 12npm config set prefix \"D:\\Program Files\\nodejs\\node_global\"npm config set cache \"D:\\Program Files\\nodejs\\node_cache\" 由于之前修改了nodejs的默认模块安装路径, 必须修改nodejs默认的模块调用路径, 打开你的电脑的”系统变量”(和步骤4中一样), 在用户变量或系统变量的path中找到以”npm”结尾的字符串, 将其改为”D:\\Program Files\\nodejs\\node_global”(路径改为你的), 若没找到, 直接在系统变量的path里添加一项, 内容为”D:\\Program Files\\nodejs\\node_global”(路径改为你的). 之后, 依次输入命令如下, 有输出结果如图(则配置正确). 123npm install cluster -gnoderequire('cluster') 6.修改npm模块镜像源 将npm的模块下载仓库从默认的国外站点改为国内的站点, 这样下载模块的速度才能比较快, 只需要一个命令即可. 其中registry_url指的是国内提供的一些npm仓库地址, 常用的有: https://registry.npm.taobao.org http://r.cnpmjs.org/ 1npm install -g cnpm --registry=registry_url 你也可以选择不改, 但建议改一下, 毕竟这样下载速度很快.","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://blog.crainyday.com/tags/NodeJS/"},{"name":"npm","slug":"npm","permalink":"https://blog.crainyday.com/tags/npm/"}]},{"title":"利用Hexo和Gitee搭建一个静态博客","slug":"Hexo","date":"2019-03-15T02:38:04.000Z","updated":"2019-10-19T03:46:19.548Z","comments":true,"path":"Hexo.html","link":"","permalink":"https://blog.crainyday.com/Hexo.html","excerpt":"没有服务器也可以哦 用gitee pages与Hexo搭建免费的个人博客","text":"没有服务器也可以哦 用gitee pages与Hexo搭建免费的个人博客 本文主要讲解gitee上搭建, 之后会讲github上的搭建. 1.前期准备 有一个gitee账号, 没有就先去注册一个 本地安装node.js, 配置教程 本地安装git for windows, 可根据系统选择, 本文按照windows讲解. 2.创建gitee仓库开启pages服务 &emsp;&emsp;先创建仓库, 点击右上角的加号; 再进入仓库, 开启pages服务. 这里建议，将你的仓库名设置为你的用户名，例如我的gitee用户名是 CRainyD ay，就将仓库名设置为：crainyday，这样的话，后边开启的静态网站服务的 url为：https://crainyday.gitee.io，而不是 https://crainyday.gitee.io/仓库名，看着更舒服一点。 注意: !!!每次用hexo d提交代码后, 都需要更新一下pages服务, 然后过几秒再进入你的博客!!!其实不更新也行, 但可能不会出现你预期的效果 3.Hexo的安装与使用 &emsp;&emsp;Hexo是一个很常用的博客发布工具, 支持markdown格式(推荐一款md编译器), hexo有很多插件和主题. &emsp;&emsp;一定要配置好系统的环境变量, 才能用npm和hexo命令, 若不能用请看配置教程 12345678#全程在博客目录下进行, 先新建一个空文件夹(例:F:/Hexo), 再cd进入该目录#安装hexonpm install hexo-cli -gnpm install hexo-server --save#用hexo新建项目, 生成站点hexo init#清理缓存&amp;&amp;生成项目文件&amp;&amp;本地运行项目hexo clean &amp;&amp; hexo g &amp;&amp; hexo s#需要先安装hexo-server插件,才能hexo s &emsp;&emsp;执行到这里, 如果前面过程中没有错误, 就会在本地成功启用Hexo博客站点, 通过http://localhost:4000访问本地博客站点, 如图: &emsp;&emsp;执行完hexo init命令, 生成的Hexo的目录结构如图: &emsp;&emsp;若想要将本地的博客文件push到gitee仓库, 需要先配置_config.yml全局配置文件, 再进行步骤4配置git相关信息, 最后才能执行下列命令将本地博客上传到远程仓库. 12345678910#发布项目到远程hexo d#需要hexo-deployer-git插件,配置完一些git的相关配置才能上传#生成页面hexo new page \"xxx\"#生成新文章hexo new \"xxx\"#安装插件npm install xxx --save#卸载插件npm unstall xxx &emsp;&emsp;以上命令既可以用Windows的cmd来完成, 也可以用git bash来完成, 但有的命令cmd执行会有一些问题, 建议全部使用git bash来执行. 之后会提到git bash的使用 这里是一些Hexo 主题，你可以选择一个自己喜欢的主题。下载后放在 themes 目录下即可。 有关其他的主题配置，请看各主题的 README 文档。 根目录_config.yml全局配置文件123456789101112title: CRainyDay&apos;s Blogauthor: CRainyDaylanguage: zh-CN#urlurl: http://crainyday.gitee.io/blog #这里填写gitee pages生成的urlroot: /blog #博客根目录theme: landscape #网站应用的主题名字,可以换为你喜欢的主题#与hexo d相关的配置deploy: type: git repo: https://gitee.com/用户名/仓库名.git #你的gitee仓库地址 branch: master 注意: 配置文件中每个 : 后要有一个英文的空格 每个主题相应的目录下也有主题的_config.yml配置文件 4.git的使用1234567891011#需要在你的博客根目录下右键运行Git Bash Heregit config --global user.name \"你的gitee用户名\"git config --global user.email \"你的gitee绑定的邮箱地址\"git initgit remote add origin &lt;你的仓库地址&gt;#以下命令这里用不到, 可以了解一下git clone &lt;想要克隆的项目地址&gt;git pull origin master#拉取代码git add .git commit -m \"提交信息\"git push origin master#提交代码 5.上传到gitee仓库 在你的本地博客根目录下, 右键运行Git Bash Here, 输入hexo d命令上传, 第一次上传期间需要输入你的gitee账号密码 注意: hexo d命令必须安装hexo-deployer-git插件 上传之后别忘了更新一下pages服务, 其实不更新也可以, 但是有时会出一些错误. 之后访问你开启pages服务时给你的url就可以了, 那便是你的博客地址.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.crainyday.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.crainyday.com/tags/Hexo/"},{"name":"Gitee","slug":"Gitee","permalink":"https://blog.crainyday.com/tags/Gitee/"}]}]}