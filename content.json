{"meta":{"title":"CRainyDay","subtitle":null,"description":null,"author":"CRainyDay","url":"http://crainyday.gitee.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found","date":"2019-03-15T10:48:09.000Z","updated":"2019-04-04T04:50:15.402Z","comments":true,"path":"404.html","permalink":"http://crainyday.gitee.io/blog/404.html","excerpt":"","text":"404 Not Found很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"想告诉我点什么呢?","date":"2019-03-16T04:46:38.000Z","updated":"2019-03-23T08:52:52.333Z","comments":true,"path":"bbs/index.html","permalink":"http://crainyday.gitee.io/blog/bbs/index.html","excerpt":"","text":"留下点什么吧!!!"},{"title":"My Friends","date":"2019-03-15T10:46:15.000Z","updated":"2019-04-04T04:37:49.168Z","comments":true,"path":"friends/index.html","permalink":"http://crainyday.gitee.io/blog/friends/index.html","excerpt":"","text":"背景音乐《You》, 这首歌曲名字之所以叫《You》, 相信很多人能听出歌曲里的情感, 平静孤寂的调子起头, 两个人分开之后的沉寂 颓废, 慢慢的音阶起伏, 我意识到不能这样下去, 我开始改变现状, 变得积极. 到高潮部分 我不在颓废, 我找到新的目标 我迎着太阳前进. 我想这就是You的含义, 你是我的一段过去. 欢迎互相加友链 名称： CRainyDay头像： https://wx.qlogo.cn/mmopen/vi_32/mr8ULapRSZZTmtMegVYHWcSGuHfhZ9Hql6j4RcV01gdx6evZDEf9icaibBbggEIibqdfaAAVHbBaVOFfibmPtcgJuQ/132网址： http://crainyday.gitee.io/blog/标签： Java PHP 前端"},{"title":"所有分类","date":"2019-03-15T10:45:49.000Z","updated":"2019-04-04T04:27:30.176Z","comments":true,"path":"categories/index.html","permalink":"http://crainyday.gitee.io/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-03-15T10:46:02.000Z","updated":"2019-03-15T10:47:59.227Z","comments":true,"path":"tags/index.html","permalink":"http://crainyday.gitee.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JSDOM基础查询","slug":"JSDOM1-1","date":"2019-04-05T08:27:48.000Z","updated":"2019-04-05T10:22:09.195Z","comments":true,"path":"JSDOM1-1.html","link":"","permalink":"http://crainyday.gitee.io/blog/JSDOM1-1.html","excerpt":"JS的DOM基础查询","text":"JS的DOM基础查询 一.获取元素节点元素节点, 即HTML标签对象 DOM对象的方法: 方法 描述 getElementById() 返回对拥有指定 id 的第一个对象的引用 getElementsByName() 返回带有指定name属性的对象集合 getElementsByTagName() 返回带有指定标签名的对象集合 write() 向文档写 HTML 表达式 或 JavaScript 代码 writeln() 等同于 write() 方法, 不同的是在每个表达式之后写一个换行符 通过例子, 看一下获取元素节点的三个DOM方法 样式表: 点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738@CHARSET \"UTF-8\";body &#123; width: 800px; margin-left: auto; margin-right: auto;&#125;button &#123; width: 300px; margin-bottom: 10px;&#125;#btnList &#123; float:left;&#125;#total&#123; width: 450px; float:left;&#125;ul&#123; list-style-type: none; margin: 0px; padding: 0px;&#125;.inner li&#123; border-style: solid; border-width: 1px; padding: 5px; margin: 5px; background-color: #99ff99; float:left;&#125;.inner&#123; width:400px; border-style: solid; border-width: 1px; margin-bottom: 10px; padding: 10px; float: left;&#125; html的body: 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;div id=\"total\"&gt; &lt;div class=\"inner\"&gt; &lt;p&gt;你喜欢哪个城市?&lt;/p&gt; &lt;ul id=\"city\"&gt; &lt;li id=\"bj\"&gt;北京&lt;/li&gt; &lt;li&gt;上海&lt;/li&gt; &lt;li&gt;东京&lt;/li&gt; &lt;li&gt;首尔&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt;&lt;br /&gt; &lt;p&gt;你喜欢哪款单机游戏?&lt;/p&gt; &lt;ul id=\"game\"&gt; &lt;li id=\"rl\"&gt;红警&lt;/li&gt; &lt;li&gt;实况&lt;/li&gt; &lt;li&gt;极品飞车&lt;/li&gt; &lt;li&gt;魔兽&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt;&lt;br /&gt; &lt;p&gt;你手机的操作系统是?&lt;/p&gt; &lt;ul id=\"phone\"&gt; &lt;li&gt;IOS&lt;/li&gt; &lt;li id=\"android\"&gt;Android&lt;/li&gt; &lt;li&gt;Windows Phone&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"inner\"&gt; gender: &lt;input class=\"hello\" type=\"radio\" name=\"gender\" value=\"male\" /&gt; Male &lt;input class=\"hello\" type=\"radio\" name=\"gender\" value=\"female\" /&gt; Female &lt;br /&gt;&lt;br /&gt; name: &lt;input type=\"text\" name=\"name\" id=\"username\" value=\"abcde\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"btnList\"&gt; &lt;div&gt;&lt;button id=\"btn01\"&gt;查找#bj节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn02\"&gt;查找所有li节点&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button id=\"btn03\"&gt;查找name=gender的所有节点&lt;/button&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; JS实现按钮的功能: 12345678910111213141516171819202122232425262728293031323334353637383940414243window.onload = function() &#123; //为id为btn01的按钮绑定一个单击响应函数 var btn01 = document.getElementById(\"btn01\"); btn01.onclick = function() &#123; //查找id为bj的节点 var bj = document.getElementById(\"bj\"); //innerHTML 通过这个属性可以获取到元素内部的html代码 alert(bj.innerHTML); &#125;; //为id为btn02的按钮绑定一个单击响应函数 var btn02 = document.getElementById(\"btn02\"); btn02.onclick = function() &#123; //查找所有li节点 //getElementsByTagName()可以根据标签名来获取一组元素节点对象 //这个方法会给我们返回一个类数组对象,所有查询到的元素都会封装到对象中 //即使查询到的元素只有一个,也会封装到数组中返回 var lis = document.getElementsByTagName(\"li\"); for(var i = 0; i &lt; lis.length; i++) &#123; alert(lis[i].innerHTML); &#125; &#125;; //为id为btn03的按钮绑定一个单击响应函数 var btn03 = document.getElementById(\"btn03\"); btn03.onclick = function() &#123; //查找name属性,值为gender的所有节点 var inputs = document.getElementsByName(\"gender\"); for(var i = 0; i &lt; inputs.length; i++) &#123; /* innerHTML用于获取元素内部的HTML代码的 * 对于自结束标签,这个属性没有意义 */ /* 如果需要读取自结束标签的属性 * 直接使用 元素.属性名 * 例: 元素.id 元素.name 元素.value * 注意: class属性不能采用这种方式 * 读取class属性时需要使用 元素.className */ var str = \"class=\\\"\"+inputs[i].className+ \"\\\" type=\\\"\"+inputs[i].type+\"\\\" name=\\\"\"+ inputs[i].name+\"\\\" value=\\\"\"+inputs[i].value+\"\\\"\"; alert(str); &#125; &#125;;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JSDOM简介","slug":"JSDOM1-0","date":"2019-04-05T06:03:12.000Z","updated":"2019-04-05T10:15:53.734Z","comments":true,"path":"JSDOM1-0.html","link":"","permalink":"http://crainyday.gitee.io/blog/JSDOM1-0.html","excerpt":"JS中的宿主对象, JSDOM","text":"JS中的宿主对象, JSDOM 一.DOM简介1.什么是DOM DOM, 即Document Object Model 文档对象模型 JS中通过操作DOM来对HTML文档进行操作.只要了解DOM就可以随心所欲的操作WEB页面 文档: 表示的是整个HTML网页文档 对象: 表示将页面中的每一个部分(包括那些HTML标签)都转换为了对象. 模型: 表示对象(即HTML中的节点)之间的关系, 这样方便我们获取、操作对象. 2.节点 节点(也即对象): Node——构成html文档最基本的单元, 网页中的每个部分都可以称为一个节点 常用节点分为四类: ——①文档节点: 整个HTML文档(即document对象) ——②元素节点: HTML文档中的html标签 ——③属性节点: 元素的属性 ——④文本节点: HTML标签中的文本内容 节点的类型不同, 它们的属性也可能不同 节点的属性 nodeName nodeType nodeValue 文档节点 #document 9 null 元素节点 标签名 1 null 属性节点 属性名 2 属性值 文本节点 #text 3 文本内容 练习: JS操纵网页中的按钮123456789101112&lt;body&gt; &lt;button id=\"btn\"&gt;我是一个按钮&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; console.log(document);//object HTMLDocument //获取button对象 var btn = document.getElementById(\"btn\"); console.log(btn);//object HTMLButtonElement console.log(btn.innerHTML);//我是一个按钮 //修改按钮的文字 btn.innerHTML = \"I'm a button\"; &lt;/script&gt;&lt;/body&gt; 二.事件 事件, 即文档或浏览器窗口发生的一些特定的交互瞬间, 用户和浏览器之间的交互行为 比如: 点击按钮、鼠标移动、关闭浏览器窗口…… 我们往往比较关注对事件的处理, 即响应事件 1.事件句柄 属性 此事件发生在何时 onabort 图像的加载被中断 onblur 元素失去焦点 onchange 域的内容被改变 onclick 当用户点击某个对象时调用的事件句柄 ondblclick 当用户双击某个对象时调用的事件句柄 onerror 在加载文档或图像时发生错误 onfocus 元素获得焦点 onkeydown 某个键盘按键被按下 onkeypress 某个键盘按键被按下并松开 onkeyup 某个键盘按键被松开 onload 一张页面或一幅图像完成加载 onmousedown 鼠标按钮被按下 onmousemove 鼠标被移动 onmouseout 鼠标从某元素移开 onmouseover 鼠标移到某元素之上 onmouseup 鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被重新调整大小 onselect 文本被选中 onsubmit 确认按钮被点击 onunload 用户退出页面 2.设置事件属性我们可以在事件对应的属性中设置一些JS代码, 当该事件被触发时, 这些代码将会执行 1234&lt;!--鼠标被移动时触发--&gt;&lt;body&gt; &lt;button id=\"btn\" onmousemove=\"alert('讨厌,移到我上面干嘛~~~')\"&gt;我是一个按钮&lt;/button&gt;&lt;/body&gt; 注意: 这种响应方式, 结构与行为发生耦合, 不方便维护, 我们一般不这样使用. 3.绑定响应函数12345678910&lt;body&gt; &lt;!--双击某个对象时触发--&gt; &lt;button id=\"btn\"&gt;我是一个按钮&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var btn = document.getElementById(\"btn\"); btn.ondblclick = function()&#123; alert('讨厌,点我两下干嘛~~~'); &#125;; &lt;/script&gt;&lt;/body&gt; 或 123456789&lt;body&gt; &lt;!--单击某个对象时触发--&gt; &lt;button id=\"btn\" onclick=\"showMsg();\"&gt;我是一个按钮&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; var showMsg = function()&#123; alert('讨厌,点我干嘛~~~'); &#125;; &lt;/script&gt;&lt;/body&gt; 三.文档的加载&emsp;&emsp;注意到, 我们上面的代码中, script标签都写在button标签之后, 为什么呢? 这与页面的加载顺序有关, 页面是顺序加载(自上往下)的, 假如把script标签写在button标签之前, 这时在script里获取button对象时获取不到button对象, 因为它还没被加载, 再为一个null添加一个事件就会报错. 故我们需要在该DOM对象加载之后再获取它, 要么把script标签放到要获取的DOM对象之后, 要么将获取及操作该DOM对象的JS代码放在window.onload事件的响应函数中. 1.onload事件 onload 事件会在页面或图像加载完成后立即发生, 该事件支持的JS对象: image, layer, window 先弹出消息对话框, 点击确定后, 再加载出按钮: 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;JSDOM&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; alert(\"hello\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;我是一个按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 先加载出按钮, 再弹出消息对话框: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;JSDOM&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; alert(\"hello\"); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=\"btn\"&gt;我是一个按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 个人觉得script标签写在DOM对象加载之后更好一些, 这样的话, 加载性能好点, 用户体验好. 但是现在的网速和浏览器内核已经很好了, 其实写在哪里没什么太大的差别.","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JS正则","slug":"JS2-5","date":"2019-04-04T00:30:47.000Z","updated":"2019-04-04T18:06:57.745Z","comments":true,"path":"JS2-5.html","link":"","permalink":"http://crainyday.gitee.io/blog/JS2-5.html","excerpt":"JS中的正则","text":"JS中的正则 一.正则表达式简介 百度百科:正则表达式, 又称规则表达式. (英语: Regular Expression, 在代码中常简写为regex、regexp或RE), 计算机科学的一个概念. 正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本. 正则表达式用于定义一些字符串的规则, 计算机根据正则表达式, 来检查是否符合规则, 获取、提取字符串中符合规则的内容. 1.创建RegExp对象正则表达式对象即RegExp对象, JS内置的对象. RegExp对象的test()方法, 检索字符串中指定的值, 返回 true 或 false 1234567//语法://var 变量名 = new RegExp(\"正则表达式\",\"匹配模式\");//匹配模式:i 忽略大小写;g 全局匹配;m 多行匹配;var reg = new RegExp(\"a\",\"i\");var str = \"ABCD\";var result = reg.test(str);//检查字符串中是否含Aconsole.log(result);//true 2.字面量创建RegExp对象字面量的方式创建更加简单, 使用构造函数创建更加灵活(可以传参数). 语法: var 变量名 = /正则表达式/匹配模式; 注意: 语法中没有引号 表达式 描述 [abc] 查找方括号之间的任何字符 [^abc] 查找任何不在方括号之间的字符 [0-9] 查找任何从 0 至 9 的数字 [a-z] 查找任何从小写 a 到小写 z 的字符 [A-Z] 查找任何从大写 A 到大写 Z 的字符 [A-z] 查找任何从大写 A 到小写 z 的字符 [adgk] 查找给定集合内的任何字符 [^adgk] 查找给定集合外的任何字符 (red blue green) 查找任何指定的选项 12345678910111213var reg = /a/i;//等价于:var reg = new RegExp(\"a\",\"i\");//1.创建一个正则表达式检查一个字符串中是否含有a或breg = /a|b/;//2.创建一个正则表达式检查一个字符串中是否含有字母reg = /[A-z]/;//中括号表示或的意思//3.检查一个字符串中是否含有abc或adc或aecreg = /a[bde]c/;//以a开头,c结尾,中间为b或d或ereg = /[^0-9]/;//检查除了数字之外的内容reg = /(abc)/;//abc连续出现reg = /(a|b|c)/;//出现过a或b或c 二.字符串与正则相关的方法1.split 根据参数将字符串拆分为字符数组 参数可以是正则表达式 正则不需要设置全局匹配, split默认将所有符合条件的拆分 123var str = \"1a2b3c4d5e6f7g8\";var arr = str.split(/[A-z]/);//根据任意字母拆分console.log(arr);//1,2,3,4,5,6,7,8 2.search 检索与正则表达式相匹配的值 如果可以搜索到指定内容, 则返回第一次出现过的位置, 没搜索到返回-1 它能接受一个正则表达式作为参数, 然后根据正则表达式检索字符串 search正则查找时不能设置全局匹配 12345//功能和indexOf()类似var str = \"hello abc hello adc hello aec\";//搜索字符串中是否含有abc或adc或aecvar result = str.search(/a[bde]c/);console.log(result);//6 3.match 可以根据正则表达式, 从一个字符串中将符合条件的内容提取出来 默认情况下, match只会找第一个符合条件的内容, 找到后停止检索, 我们可以将正则表达式设置为全局匹配模式, 这样match会找到所有符合条件的内容 可以为正则表达式设置多个匹配模式, 且顺序无所谓 match会将匹配到的内容封装到一个数组中返回, 即使只查询到一个结果. 可以将一个没有规则的长串中, 有规则的内容提取出来, 很实用 1234567891011121314var str = \"1A2B3C4d5e6f7g8\";var result = str.match(/[a-z]/gi);console.log(Array.isArray(result));//true;console.log(result);//A,B,C,d,e,f,gconsole.log(result[0]);//A//筛选出所有的QQ号var str = \"826720408abhfe826720407\"+ \"freaf826720405C826720\"+ \"404d826720405e8267204\"+ \"00f826720409g826720401\";var result = str.match(/[0-9]&#123;8,10&#125;/g);console.log(Array.isArray(result));//true;console.log(result); 4.replace 将字符串中指定的内容替换为新的内容, 不影响原字符串 参数:①被替换的内容, 可以接受一个正则表达式作为参数 ②新的内容 默认只会替换一个,可以为正则表达式设置全局匹配模式替换所有内容 1234var str = \"1A2B3C4d5e6f7g8\";//将所有字母替换为\"\"var result = str.replace(/[a-z]/gi,\"\");console.log(result);//12345678 三.正则表达式语法补充1.量词 量词: 可以设置一个内容出现的次数, 它只对它前面的一个内容起作用 量词 描述 n+ 匹配任何包含至少一个 n 的字符串, 相当于n{1, } n* 匹配任何包含零个或多个 n 的字符串, 相当于n{0, } n? 匹配任何包含零个或一个 n 的字符串, 相当于n{0,1} n{x} 匹配包含 x 个 n 的序列的字符串 n{x,y} 匹配包含 x ~ y 个 n 的序列的字符串 n{x, } 匹配包含至少 x 个 n 的序列的字符串 n$ 匹配任何结尾为 n 的字符串 ^n 匹配任何开头为 n 的字符串 ?=n 匹配任何其后紧接指定字符串 n 的字符串 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串 12345678910111213var reg = /a&#123;3&#125;/;console.log(reg.test(\"xaaax\"));//只有字符串中连续出现3个a时为truereg = /(ab)&#123;3&#125;/;console.log(reg.test(\"xabababx\"));//只有字符串中连续出现3个ab时为truereg = /ab&#123;3,5&#125;c/;console.log(reg.test(\"xabbbbcx\"));//只有字符串中a和c之间有3~5个b时为truereg = /ab&#123;3,&#125;c/;console.log(reg.test(\"xabbbcx\"));//只有字符串中a和c之间有2个以上b时为truereg = /^a$/;console.log(reg.test(\"a\"));//只有字符串为\"a\"时,结果为truereg = /^a|a$/;console.log(reg.test(\"abc\"));//字符串以a开头或以a结尾时为true 注意: 在正则表达式中同时使用了 ^ 和 $ 量词, 则要求字符串必须完全符合正则表达式. 练习: 手机号的正则表达式匹配手机号的正则表达式: /^1[3-9][0-9]{9}$/ 123456789/*手机号的规则: *1. 以1开头 *2. 第二位为3-9任意数字 *3. 第三位之后为任意数字9个 * ^ 和 $ 量词是必须的 * ^1 [3-9] [0-9]&#123;9&#125;$ */var phoneNumReg = /^1[3-9][0-9]&#123;9&#125;$/;console.log(phoneNumReg.test(\"15555555555\"));//true 2.元字符 元字符 描述 . 查找单个字符, 除了换行和行结束符 \\w 查找单词字符(字母、数字、下划线) \\W 查找非单词字符 \\d 查找数字 \\D 查找非数字字符 \\s 查找空白字符 \\S 查找非空白字符 \\b 匹配单词边界 \\B 匹配非单词边界 \\0 查找 NULL 字符 \\n 查找换行符 \\f 查找换页符 \\r 查找回车符 \\t 查找制表符 \\v 查找垂直制表符 \\xxx 查找以八进制数 xxx 规定的字符 \\xdd 查找以十六进制数 dd 规定的字符 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符 1234567891011121314151617//查找字符串中是否有.//正则字面量://由于.是元字符,我们要用\\.来代替.//而\\表示转义,要用\\\\来代替\\var reg = /\\./;console.log(reg.test(\"adsC.dSf l\"));//true//正则构造函数://由于函数的参数为字符串,而在字符串中\\代表转义字符//故在字面量中的一个\\要用\\\\来代替var reg1 = new RegExp(\"\\\\.\");//等价于regconsole.log(reg1);//输出:/\\.///查找字符串是否含单词childreg = /\\bchild\\b/;console.log(reg.test(\"hello children\"));//falseconsole.log(reg.test(\"hello child ren\"));//true 练习: A.去除字符串的前后空格匹配开头和结尾空格的正则表达式: /^\\s*|\\s*$/g 12345678910//可以考虑replace用空串替换空格var str = \" Aaron Bob \";//str = str.replace(/\\s/g,\"\");//去除所有空格//str = str.replace(/^\\s*/,\"\");//去除开头的空格//str = str.replace(/\\s*$/,\"\");//去除结尾的空格//综合一下:str = str.replace(/^\\s*|\\s*$/g,\"\");//因为是或的关系,若不加全局匹配,方法匹配完开头的空格就返回了console.log(str); 练习: B.email的正则表达式12345678910/*电子邮件格式: * hello .hello @ abc .com .cn * * 任意字母数字下划线 .任意字母数字下划线 @ 任意字母数字 .任意字母(2-5位) .任意字母(2-5位) * * \\w&#123;3,&#125; (\\.\\w+)* @ [A-z0-9]+ (\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125; */var emailReg = /^\\w&#123;3,&#125;(\\.\\w+)*@[A-z0-9]+(\\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/;var email = \"crainyday@qq.com\";console.log(emailReg.test(email));//true","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JS内建对象","slug":"JS2-4","date":"2019-04-03T14:24:22.000Z","updated":"2019-04-04T03:45:01.696Z","comments":true,"path":"JS2-4.html","link":"","permalink":"http://crainyday.gitee.io/blog/JS2-4.html","excerpt":"JS中的一些其他内建对象","text":"JS中的一些其他内建对象 一.Date1.Date对象的创建 在JS中用Date对象来表示一个时间 Date的无参构造函数会封装当前代码执行时的时间. 以字符串为参数的构造函数, 可以指定Date对象的时间.字符串格式: “月/日/年 时:分:秒” 1234var date1 = new Date();console.log(date1);//输出:计算机系统的当前时间var date2 = new Date(\"01/01/2019 08:01:01\");//\"01-01-2019\"这样也行console.log(date2);//输出:Tue Jan 01 2019 08:01:01 GMT+0800 (中国标准时间) 2.Date的一些方法 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)getMonth() 从 Date 对象返回月份 (0 ~ 11)getFullYear() 从 Date 对象以四位数字返回年份getHours() 返回 Date 对象的小时 (0 ~ 23)。getMinutes() 返回 Date 对象的分钟 (0 ~ 59)getSeconds() 返回 Date 对象的秒数 (0 ~ 59)getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)getTime() 返回(格林威治时间的)1970年1月1日 00:00:00至今的毫秒数, 即时间戳setTime() 以毫秒设置 Date 对象 Date.now() 返回当前的时间戳 1234567891011121314151617var date1 = new Date(\"01-27-2019 08:16:24.100\");console.log(date1.getDate());//输出:27console.log(date1.getDay());//输出:0console.log(date1.getMonth());//输出:0console.log(date1.getFullYear());//输出:2019console.log(date1.getHours());//输出:8console.log(date1.getMinutes());//输出:16console.log(date1.getSeconds());//输出:24console.log(date1.getMilliseconds());//输出:100var date2 = new Date(\"01-01-1970\");console.log(date2.getTime());//中文系统下,我们与格林威治时间相差8h,输出:-28800000date2.setTime(date1.getTime());console.log(date2);//输出:Sun Jan 27 2019 08:16:24 GMT+0800 (中国标准时间)console.log(Date.now());//输出当前时间戳 二.MathMath和其他内置对象不同, 它不能是一个构造函数, 不能创建对象, 它只是一个工具类, 里面封装了一些数学运算中常用的属性和函数. 1.常用属性和函数 Math.PI 返回圆周率(约等于3.14159)abs(x) 返回数的绝对值ceil(x) 对数进行上舍入floor(x) 对数进行下舍入round(x) 把数四舍五入为最接近的整数random() 返回0~1之间的随机数. 生成x~y之间的随机数: Math.round(Math.random()*(y-x)+x);max(x,y) 返回 x 和 y 中的最高值min(x,y) 返回 x 和 y 中的最低值pow(x,y) 返回 x 的 y 次幂sqrt(x) 返回数的平方根 12345678910111213141516console.log(Math.PI);//输出:3.141592653589793console.log(Math.abs(-10));//输出:10console.log(Math.ceil(1.001));//输出:2console.log(Math.ceil(1.999));//输出:2console.log(Math.floor(1.001));//输出:1console.log(Math.floor(1.999));//输出:1console.log(Math.round(1.499));//输出:1console.log(Math.round(1.5));//输出:2for(var i = 0;i &lt; 10;i ++)&#123; //生成10个20-80间的随机数,包括20和100 console.log(Math.round(Math.random()*80+20));&#125;console.log(Math.max(1,10,100));//输出:100console.log(Math.min(1,10,100));//输出:1console.log(Math.pow(2,10));//输出:1024console.log(Math.sqrt(100));//输出:10 三.包装类 回顾: 基本数据类型(Number String Boolean Null Undefined)VS引用数据类型(Object) JS为我们提供了三个包装类(Number String Boolean):&emsp;&emsp;Number—&gt;可以将基本数据类型的Number转换为Number对象&emsp;&emsp;String&emsp;—&gt;可以将基本数据类型的String转换为String对象&emsp;&emsp;Boolean—&gt;可以将基本数据类型的Boolean转换为Boolean对象 但是, 注意: 实际应用时我们一般不会使用基本数据类型的对象, 若使用, 在做比较时可能会带来一些不可预期的结果 方法和属性只能添加给对象, 不能添加给基本数据类型. 当我们调用基本数据类型的属性和方法时, 浏览器会临时使用包装类将其转换为对象, 再调用对象的属性和方法. 包装类一般是浏览器底层自己调用的, 我们一般不会使用它们. 12345678910111213var num = new Number(123);var str = new String(\"hello\");var bool = new Boolean(false);console.log(num == 123);//输出:trueconsole.log(num === 123);//输出:falseif(bool)&#123;//bool是对象,对象转换为Boolean时都会转换为true,所以下述代码会执行 alert(\"我执行了~~~\");&#125;var a = 123;a.hello = \"hello\";//这里会将a临时转换为对象,但执行完该对象便会被销毁,故后面调用会打印undefinedconsole.log(a.hello);//输出:undefinedconsole.log(a.toString(16));//输出:7b 1.数字进制间的转换Number对象有个方法toString()我们常用它来转换进制, 参数为基数 123var num = 123;console.log(num.toString(16));//输出:7dconsole.log(num.toString(2));//输出:1111011 四.String对象的方法 length 属性, 字符串的长度charAt() 返回在指定位置的字符charCodeAt() 返回在指定的位置的字符的 Unicode 编码concat() 连接字符串String.fromCharCode() 从字符编码创建一个字符串, 参数一个或多个Unicode值indexOf() 检索字符串, 有则返回索引, 没有返回-1——–参数:①要检索的字符串, 必需——–②要从哪个位置开始检索, 不传从0开始检索lastIndexOf() 和indexOf类似, 不过这个方法从后向前搜索字符串 slice() 提取字符串的片断, 将指定的字符串封装到新字符串返回——–两个参数:①截取开始位置的索引, 包括开始位置, 可以为负数(-1表示倒数第一个元素)——–②结束位置的索引, 不包括结束位置(该参数可省略, 表示截取之后所有元素), 可以为负数substring() 提取字符串中两个指定的索引号之间的字符——–与splice类似, 但其参数不可为负值, 若传负值, 则默认使用0.——–该方法还会自动调整参数位置, 若第二个参数小于第一个, 则交换两个参数substr() 从起始索引号提取字符串中指定数目的字符——–ECMAscript 没有对该方法进行标准化, 但现今大部分浏览器支持——–两个参数:①截取开始位置索引(可为负数)②(可选参数)要截取字符的数量 split() 把字符串分割为字符串数组——–两个参数:①必需, 字符串或正则表达式, 从该参数指定的地方分割——–②可选, 指定返回的数组的最大长度toLowerCase() 把字符串转换为小写toUpperCase() 把字符串转换为大写 这些方法都不会改变原来的字符串 1.连接检索字符串123456789101112var str = \"hello China,hello World!\";console.log(str.length);//24console.log(str.charAt(23));//!console.log(str.charCodeAt(0));;//104即h的Unicode值console.log(String.fromCharCode(104,101,108,108,111));//helloconsole.log(String.fromCharCode(0x4e2d,0x56fd));//中国console.log(str.concat(\"你好\",\"中国\"));//hello China,hello World!你好中国console.log(str.indexOf(\"hello\"));//0console.log(str.indexOf(\"hello\",1));//12console.log(str.lastIndexOf(\"hello\"));//12console.log(str.indexOf(\"p\"));//-1 2.截取字符串12345var str = \"abcdefghijklmn\";console.log(str.slice(-3,-1));//lmconsole.log(str.substring(1,-1));//负数会默认为0,然后交换参数为0,1;输出:aconsole.log(str.substr(-4,3));//-3开始的三个字符,即:klmconsole.log(str.substr(0));//abcdefghijklmn 3.分割转换字符串12345678910var str = \"Abc,def,ghi,jkL\";var result = str.split(\",\");console.log(Array.isArray(result));//trueconsole.log(result.length);//4result = str.split(\",\",2);console.log(result);//\"Abc\",\"def\"console.log(str.toUpperCase());//\"ABC,DEF,GHI,JKL\"console.log(str);//\"abc,def,ghi,jkl\"","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JS数组","slug":"JS2-3","date":"2019-04-02T13:24:17.000Z","updated":"2019-04-03T17:01:42.822Z","comments":true,"path":"JS2-3.html","link":"","permalink":"http://crainyday.gitee.io/blog/JS2-3.html","excerpt":"JS数组(内建对象), 之前都是说的自定义对象.","text":"JS数组(内建对象), 之前都是说的自定义对象. 一.数组简介 数组也是一个对象 它和普通对象的功能类似, 也是用来存储一些值的 不同的是, 普通对象用字符串作为索引, 数组用数字(&gt;=0的整数)作为索引 数组的存储性能比普通对象好, 我们往往常用它来存储一些数据 1.操作数组 ①数组中添加元素, 语法: 变量名[数字索引] = 值; ②读取数组元素, 语法: 变量名[数字索引]; 若读取不存在的索引不会报错, 会返回undefined ③获取数组长度, 变量名.length; 对于连续的数组, 这样可以得到数组长度, 对于不连续的数组这样使用length的值为当前数组的最大索引+1, 尽量不要用不连续的数组. ④人为的设置length, 若设置的length大于原长度, 则多余部分会空出来; 若设置的length小于原长度, 则多余的元素会被删除 ⑤向数组最后一个位置添加索引, 变量名[变量名.length] = 某值; 1234567891011121314151617var arr = new Array();console.log(typeof arr);//输出:objectarr[0] = \"hello\";console.log(arr[0]);//输出:\"hello\"console.log(arr.length);//输出:1arr[5] = 123;console.log(arr);//输出:hello,,,,,123console.log(arr.length);//输出:6console.log(arr[1]);//输出:undefinedarr.length = 1;arr[arr.length] = \"China\";arr[arr.length] = 521;arr[arr.length] = true;console.log(arr);//输出:\"hello\",\"China\",521,true 2.数组字面量 数组字面量创建数组, 语法: [];例: var arr = [1,2,3,4,10];//允许在创建时指定要添加的数组元素 使用数组的构造函数创建数组的同时, 也可以添加元素, 此时将要添加的元素作为参数传递例: var arr = new Array(1,5,6,2,3); 使用数组的构造函数创建数组, 也可以指定数组的初始长度例: var arr = new Array(10); 注意: 数组的元素可以是任意类型的数据 12345678910111213141516171819202122232425var arr1 = [5,9,8,4,3,1];//字面量创建数组var arr2 = new Array(5,9,8,4,3,1);console.log(arr1);//输出:5,9,8,4,3,1console.log(arr2);//输出:5,9,8,4,3,1var arr3 = new Array(10);console.log(arr3);//输出:,,,,,,,,,//数组的元素可以是任意类型的数据var arr4 = [\"hello\",true,123,null,undefined];console.log(arr4);//输出:\"hello\",true,123,null,undefined//可以是对象var obj = &#123;name:\"Bob\"&#125;;arr4[arr4.length] = obj;console.log(arr4[5].name);//输出:Bob//可以是函数arr4[arr4.length] = function()&#123; alert(\"我是数组中的函数\");&#125;;arr4[6]();//调用函数//也可以放数组, 我们叫这种数组为: 二维数组var arr = [[1,2,3],[4,5,6],[7,8,9]];console.log(arr);//输出:1,2,3,4,5,6,7,8,9console.log(arr.length);//输出:3console.log(arr[0].length);//输出:3 二.数组常用方法 pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素, 并返回新的长度shift() 删除并返回数组的第一个元素unshift() 向数组的开头添加一个或更多元素, 并返回新的长度 slice() 从某个已有的数组返回选定的元素——–该方法不会改变原数组, 而是将指定的数组元素封装到新数组中返回, 两个参数:——–①截取开始位置的索引, 包括开始位置, 可以为负数(-1表示倒数第一个元素)——–②截取结束位置的索引, 不包括结束位置(该参数可省略, 表示截取之后所有元素), 可以为负数splice() 删除元素, 并向数组添加新元素——–该方法会改变原数组, 会将指定元素从原数组中删除, 并将删除的元素作为返回值返回——–参数(前两个必需):①开始位置的索引, 可以为负数(-1表示倒数第一个元素)——–②要删除元素的数量——–③第三个参数及以后, 可以传递新元素, 这些元素会自动插入到第一个参数索引的前边 concat() 连接两个或更多的数组, 并返回结果.(不影响原数组)join() 把数组的所有元素放入一个字符串, 元素通过指定的分隔符(默认为逗号)进行分隔.reverse() 颠倒数组中元素的顺序.(影响原数组)sort() 对数组的元素进行排序(影响原数组), 默认按Unicode编码排序 A.pop push shift unshift1234567891011var arr = [\"孙悟空\", \"猪八戒\", \"唐僧\", \"沙和尚\"];var result = arr.pop();console.log(result); //输出:沙和尚result = arr.push(\"白骨精\", \"玉帝\", \"蝎子精\");console.log(result); //输出:6console.log(arr);//输出:孙悟空,猪八戒,唐僧,白骨精,玉帝,蝎子精result = arr.shift();console.log(result);//输出:孙悟空result = arr.unshift(\"牛魔王\", \"红孩儿\", \"铁扇公主\");console.log(result);//输出:8console.log(arr);//输出:牛魔王,红孩儿,铁扇公主,猪八戒,唐僧,白骨精,玉帝,蝎子精 B.slice splice123456789var arr = [\"孙悟空\", \"猪八戒\", \"唐僧\", \"沙和尚\"];var result = arr.slice(-3,-1);console.log(result);//输出:猪八戒,唐僧result = arr.slice(-3);console.log(result);//输出:猪八戒,唐僧,沙和尚result = arr.splice(1,0,\"玉帝\",\"佛祖\");console.log(result);//输出:\"\"console.log(arr);//输出:孙悟空,玉帝,佛祖,猪八戒,唐僧,沙和尚 例: 数组去重练习 12345678910var arr = [1,1,2,2,3,5,4,4,6,8,2,1,3,2];for(var i = 0;i &lt; arr.length;i ++)&#123; for(var j = i+1;j &lt; arr.length;j ++)&#123; if(arr[i] == arr[j])&#123; arr.splice(j,1); j--; &#125; &#125;&#125;console.log(arr);//输出:1,2,3,5,4,6,8 C.concat join123456789var arr1 = [\"孙悟空\",\"猪八戒\",\"沙和尚\"];var arr2 = [\"白骨精\",\"高玉兰\",\"玉兔精\"];var result = arr1.concat(arr2,\"牛魔王\",\"红孩儿\");console.log(result);//输出:\"孙悟空\",\"猪八戒\",\"沙和尚\",\"白骨精\",\"高玉兰\",\"玉兔精\",\"牛魔王\",\"红孩儿\"var str = result.join();console.log(str);//输出:\"孙悟空,猪八戒,沙和尚,白骨精,高玉兰,玉兔精,牛魔王,红孩儿\"str = result.join(\"\");//分隔符为\"\"console.log(str);//输出:\"孙悟空猪八戒沙和尚白骨精高玉兰玉兔精牛魔王红孩儿\" D.reverse sort ①sort方法, 默认按照Unicode编码排序, 对于数字的排序往往不是我们想要的结果, 这时我们就需要按照我们自己想要的排序方式, 编写一个回调函数传递给sort().②sort的回调函数有两个形参, 代表要比较的数组中的两个元素, 第一个形参代表的元素相对于第二个靠前③sort方法根据回调函数的返回值排序.④参数为回调函数的函数, 我们一般用匿名方式传递参数 123456var arr = [2,5,7,3,1,6,9,8,4];arr.sort(function(a,b)&#123; //return a-b;//升序 return b-a;//逆序&#125;);console.log(arr); 三.遍历数组1.for循环遍历123456789101112131415161718192021222324252627//遍历数组, 就是将数组的元素取出来使用function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.toString = function ()&#123; return \"Person[name:\"+this.name+\",age:\"+this.age+\",sex:\"+this.sex+\"]\";&#125;;var nameArr = [\"孙悟空\",\"沙悟净\",\"猪悟能\",\"唐玄奘\",\"白骨精\",\"玉兔精\",\"蜘蛛精\"];var ageArr = [18,28,38,17,16,15,14];var sexArr = [\"男\",\"男\",\"男\",\"男\",\"女\",\"女\",\"女\"];var personArr = new Array(7);for(var i = 0;i &lt; personArr.length;i ++)&#123; personArr[i] = new Person(nameArr[i],ageArr[i],sexArr[i]); console.log(personArr[i]);&#125;/* 输出:Person[name:孙悟空,age:18,sex:男]Person[name:沙悟净,age:28,sex:男]Person[name:猪悟能,age:38,sex:男]Person[name:唐玄奘,age:17,sex:男]Person[name:白骨精,age:16,sex:女]Person[name:玉兔精,age:15,sex:女]Person[name:蜘蛛精,age:14,sex:女]*/ 练习: 自定义一个函数, 将上述对象数组中person对象age属性大于等于18的对象放入一个新数组, 并将该新数组作为函数的返回值返回. 123456789function getAdult(perArr)&#123; var arr = new Array(); for(var i = 0;i &lt; perArr.length;i ++)&#123; if(perArr[i].age&gt;=18)&#123; arr.push(perArr[i]); &#125; &#125; return arr;&#125; 2.数组的for Each()方法遍历 ①该方法适用于IE 8.0+②该方法需要一个函数作为参数, 我们称此函数为回调函数, 这种函数由我们创建, 但是我们不负责调用③我们写回调函数时一般都以匿名形式给出④数组中有几个元素, 该方法会执行几次, 该方法的调用者会将在数组中遍历到的元素以实参形式传递进函数, 我们可以定义形参来接收它们⑤该函数被调用时会传递三个参数: 第一个, 当前正在遍历的元素;第二个, 当前正在遍历元素的索引;第三个, 正在遍历的数组. 1234567891011121314151617181920212223//接上上述代码personArr.forEach( function (per,index,perArr)&#123; console.log(perArr[index] == per);//全是true console.log(per); &#125;);/* 结果:truePerson[name:孙悟空,age:18,sex:男]truePerson[name:沙悟净,age:28,sex:男]truePerson[name:猪悟能,age:38,sex:男]truePerson[name:唐玄奘,age:17,sex:男]truePerson[name:白骨精,age:16,sex:女]truePerson[name:玉兔精,age:15,sex:女]truePerson[name:蜘蛛精,age:14,sex:女]*/","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JS对象补充","slug":"JS2-2","date":"2019-04-01T12:28:55.000Z","updated":"2019-04-03T17:01:28.333Z","comments":true,"path":"JS2-2.html","link":"","permalink":"http://crainyday.gitee.io/blog/JS2-2.html","excerpt":"JS对象补充","text":"JS对象补充 一.工厂方法创建对象123456var obj = &#123; name:, age:, sex:, showMes:&#125;; &emsp;&emsp;我们想要创建大量的上面的obj对象, 它们的属性名都一样, 但是值可能不一样, 这时, 为了”偷懒”, 我们可以使用工厂方法创建对象. 批量生产对象. 1234567891011121314151617181920212223242526272829303132function createPerson(name, age, sex) &#123; var obj = &#123; name: name, age: age, sex: sex, showMes: function() &#123; alert(name); &#125; &#125;; return obj;&#125;var per1 = createPerson(\"孙悟空\", 500, \"男\");console.log(per1);//Object &#123;name: \"孙悟空\", age: 500, sex: \"男\", showMes: ƒ&#125;var per2 = createPerson(\"猪八戒\", 300, \"男\");console.log(per2);//Object &#123;name: \"猪八戒\", age: 300, sex: \"男\", showMes: ƒ&#125;var per3 = createPerson(\"白骨精\", 500, \"女\");console.log(per3);//Object &#123;name: \"白骨精\", age: 500, sex: \"女\", showMes: ƒ&#125;per1.showMes();//孙悟空per2.showMes();//猪八戒per3.showMes();//白骨精function createDog(name, age) &#123; var obj = new Object(); obj.name = name; obj.age = age; obj.showMes = function()&#123; alert(this.name); &#125;; return obj;&#125;var dog = createDog(\"哮天犬\",3);console.log(dog);//Object &#123;name: \"哮天犬\", age: 3, showMes: ƒ&#125;dog.showMes();//哮天犬 二.构造函数 从上面代码的注释中, 可以看见我们用工厂方法创建的对象都是Object类型的, 不易区分不同的对象(到底是Dog还是Person), 这时, 我们可以创建一个构造函数来专门创建某一类对象. 构造函数是一类特殊的普通函数, 习惯上我们将构造函数的函数名首字母大写. 构造函数与普通函数相比, 调用方式不同, 普通的直接调用即可, 构造函数需要在new关键字之后调用. 使用同一个构造函数创建的对象, 我们称为一类对象, 也将构造函数称为类, 将它创建的对象称为类的实例. 构造函数的执行流程: 被调用时, 首先创建一个新的对象 将函数中的this指向新建的对象(即在构造函数中, 可以用this来引用正在新建的对象) 逐行执行构造函数中的代码 将新建的对象作为构造函数的返回值返回. A.instanceof用法: 对象 instanceof 构造函数, 检查一个对象是否为一个构造函数的实例, 是返回true, 不是返回false. 1234567891011121314151617function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex; this.showMes = function()&#123; alert(this.name); &#125;;&#125;var per1 = new Person(\"孙悟空\", 500, \"男\");console.log(per1);//Person &#123;name: \"孙悟空\", age: 500, sex: \"男\", showMes: ƒ&#125;var per2 = new Person(\"猪八戒\", 300, \"男\");console.log(per1);//Person &#123;name: \"猪八戒\", age: 300, sex: \"男\", showMes: ƒ&#125;var per3 = new Person(\"白骨精\", 500, \"女\");console.log(per1);//Person &#123;name: \"白骨精\", age: 500, sex: \"女\", showMes: ƒ&#125;console.log(per1 instanceof Person);//trueconsole.log(per1.showMes == per2.showMes);//false 上面的代码有一个弊端, 每一个由Person创建的对象都有一个自己的showMes()方法 console.log(per1.showMes == per2.showMes);//false 返回结果是false, 而这不是我们想要的, 这样的话会浪费很多的内存.故修改一下, 将该函数的声明放到外面 1234567891011121314function showMes()&#123; alert(this.name);&#125;function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex; this.showMes = showMes;&#125;var per1 = new Person(\"孙悟空\", 500, \"男\");var per2 = new Person(\"猪八戒\", 300, \"男\");var per3 = new Person(\"白骨精\", 500, \"女\");console.log(per1.showMes == per2.showMes);//true 三.原型对象 注意: 上述改进, 将对象共有的方法showMes()直接声明在全局作用域中, 也是存在一些弊端, ①污染了全局作用域(在全局作用域中不能再添加同名函数)②不是很安全. 因此, 这次我们采用一个非常好的办法, 即解决多个同类对象创建多个公共的方法, 又不会对全局作用域造成污染. 原型: prototype 我们创建的每一个函数, 解析器都会向函数中添加一个属性prototype, 这个属性对应着一个对象即原型对象 如果函数作为普通函数调用prototype没有任何作用 如果函数以构造函数的形式调用时,它创建的对象中都会有一个隐含的属性, 指向该构造函数的原型对象, 我怕们可以用对象的__proto__属性来访问该对象 原型对象就相当于一个公共的区域, 所有同一个类的实例都能访问到这个对象, 我们可以将对象中共有的内容统一放到原型对象中. 当我们访问一个对象的属性或方法时, 它会先在对象自身寻找, 如果有则直接使用, 若没有则会去原型对象中寻找, 如果原型对象中有则直接使用 改进如下: 1234567891011121314function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.showMes = function()&#123; alert(this.name);&#125;;var per1 = new Person(\"孙悟空\", 500, \"男\");var per2 = new Person(\"猪八戒\", 300, \"男\");var per3 = new Person(\"白骨精\", 500, \"女\");console.log(Person.prototype == per1.__proto__);//trueconsole.log(per1.showMes == per2.showMes);//true A.检查对象的属性 1.之前提到过用in运算符检查对象中是否包含某个属性, 但这样, 如果对象的原型对象中有这个属性, 也会返回true, 显然这不是我们想得到的结果. 2.我们只想在对象本身的属性中搜索. 这时候可以用对象的hasOwnProperty()方法检查. hasOwnProperty方法其实在原型对象的原型中 3.原型对象也是对象, 它也有原型. 我们调用一个对象的属性或方法时, 会先在对象自身寻找, 没有就去对象的原型中寻找, 还没有就去原型的原型中寻找, 直到找到Object对象的原型, 没有则返回undefined 4.Object对象的原型没有原型, 它的值为null 1234567891011121314function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.showMes = function()&#123; alert(this.name);&#125;;Person.prototype.a = 123;var per = new Person(\"孙悟空\", 500, \"男\");console.log(\"a\" in per);//trueconsole.log(per.hasOwnProperty(\"a\"));//falseconsole.log(per.__proto__.__proto__.hasOwnProperty(\"hasOwnProperty\"));//true 四.toString()123456789101112function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.showMes = function() &#123; alert(this.name);&#125;;var per = new Person(\"孙悟空\", 500, \"男\");console.log(per);//输出:[object Object]console.log(Object.__proto__.hasOwnProperty(\"toString\"));//输出:true 我们直接在页面打印对象的引用时, 实际上调用了对象的toString()方法, 打印的是toString()的返回值, 默认调用的是Object原型的toString()方法. 假如我们想打印对象时, 按照我们自己的想法控制输出的内容, 我们就需要显示的添加一个toString()方法, 不让当前的对象向原型中搜寻方法. 12345678910function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;Person.prototype.toString = function() &#123; return \"Person[name:\"+this.name+\",age:\"+this.age+\",sex:\"+this.sex+\"]\";&#125;;var per = new Person(\"孙悟空\", 500, \"男\");console.log(per);//Person[name:孙悟空,age:500,sex:男] 五.垃圾回收(GC) 程序运行过程中也会产生垃圾, 若垃圾过多, 会使程序运行过慢, 因此我们需要一个垃圾回收机制来处理程序运行过程中产生的垃圾. 当一个对象没有任何变量或属性对它进行引用, 我们将永远无法操作该对象, 这种对象就是垃圾. 在JS中拥有自动的垃圾回收机制, 会自动将垃圾对象从内存中销毁, 我们不需要也不能进行垃圾回收的操作. 假如我们不再使用某个对象的引用, 将它设置为null即可","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JS函数","slug":"JS2-1","date":"2019-03-31T14:17:35.000Z","updated":"2019-04-03T17:01:03.593Z","comments":true,"path":"JS2-1.html","link":"","permalink":"http://crainyday.gitee.io/blog/JS2-1.html","excerpt":"JS的函数function","text":"JS的函数function 一.JS函数的简介函数(function): 函数也是一个对象 函数中封装了一些功能(代码), 在需要时可以执行这些功能(代码) 封装到函数的代码不会立即执行, 只有调用时才会执行 调用函数时代码顺序执行, 调用语法: 函数对象() 使用typeof检查一个函数对象时, 会返回function A.创建一个函数对象 将要封装的代码以字符串形式传递给构造函数, 例: 1234var fun = new Function(\"console.log('这是我的第一个函数~~~')\");fun['value'] = \"123\";//函数是对象, 也可以像对象那样用, 但我们一般不这样用fun();//这样调用函数//实际编程中我们很少用这种方式创建一个函数 使用函数声明来船舰一个函数(对象), 格式: 123function 函数名([形参1,形参2,形参3,...,形参n])&#123; //代码...&#125; 使用函数表达式创建一个函数, 格式: 123var 函数名 = function([形参1,形参2,形参3,...,形参n])&#123; //代码...&#125; B.参数 在函数的()中, 可以指定0个或多个形参 多个形参之间用逗号隔开, 声明了形参就相当于在函数内部声明了对应的变量 声明的形参并没有被赋值 调用函数时, 可以在()中指定实参, 实参的值会依次赋值给形参 调用函数时, 解析器不会检查形参与实参的数量是否匹配 函数的实参可以是任何类型的值, 包括基本类型、对象、函数(对象). 特别注意: 调用函数时, 解析器也不会检查实参的类型, 所以要检查一下参数是否合法 例题: 定义一个能求两个数和的函数 12345678910111213141516171819202122function sum(a,b)&#123; if((typeof a) == \"number\"&amp;&amp;(typeof b) == \"number\")&#123; console.log(a+b); &#125;&#125;sum(123,456);sum(123,\"456\");//不输出内容function show(obj) &#123; console.log(\"我是\" + obj.name + \",性别\" + obj.sex + \",我今年\" + obj.age + \"岁了\");&#125;var person = &#123; name:\"孙悟空\", sex:\"男\", age:500&#125;;//函数实参为对象show(person);function fun(a)&#123; a(person);&#125;//函数实参为函数(对象),将max赋值给了a,故a(person);与show(person);等价fun(max); C.返回值 在函数中, 可以用return关键字返回一个表达式的值 可以在调用函数处, 声明一个变量接收该函数的返回值 若函数中不写return或没有return一个值, 则会默认return undefined; return语句之后的代码不会被执行 函数的返回值也可以是任意类型的值, 基本类型、对象、函数 例: 定义一个能求两个数最大值的函数, 并将最大值返回. 1234567891011121314151617181920212223242526function max(a,b)&#123; if((typeof a) == \"number\"&amp;&amp;(typeof b) == \"number\")&#123; return a&gt;b?a:b; &#125;&#125;var maxNum = max(123,456);console.log(maxNum);function fun(a)&#123; console.log(\"a = \" + a);&#125;//函数实参为函数(对象)fun(max);//函数实参为函数的返回值fun(max(123,456));function fun2()&#123; //return &#123;name:\"孙悟空\"&#125;;//返回一个对象 function fun3()&#123; alert(\"我是fun3函数\"); &#125; //return fun3();//这样是返回fun3函数的返回值 return fun3;//返回fun3这个函数&#125;var f = fun2();//此时f为fun3f();//调用fun3函数fun2()();//和f();等价,也是调用fun3()函数 D.立即执行函数 函数定义完, 立即就会被调用 这种函数往往是匿名函数, 只会执行一次.例: 12345//先用一对小括号将匿名函数括起来,表示是一个整体,否则不允许这样声明函数(function(a, b) &#123; console.log(\"a = \" + a); console.log(\"b = \" + b);&#125;)(123, 456); E.方法(method) 一类特殊的函数, 这类函数是对象的属性 若一个函数成了对象的一个属性, 那这个函数就叫做对象的方法 调用函数就叫做调用的对象的某方法 12document.write(\"Hello\");//调用document对象的write方法console.log(\"Hello\");//调用console对象的log方法 二.作用域(Scope)A.全局作用域 直接编写在script标签中的JS代码, 都在全局作用域中 全局作用域在页面打开时创建, 在页面关闭时销毁 全局作用域中有一个全局对象window, 它代表一个浏览器窗口, 由浏览器创建, 我们可以直接使用 全局作用域中我们创建的变量都会作为window对象的属性保存, 函数作为window的方法 全局作用域里的变量都是全局变量, 在页面的任何部分都能访问到 变量的声明提前: 使用var声明的变量, 会在所有的代码执行之前被声明(但不会被赋值)但声明变量时不使用var, 则变量不会被提前声明函数的声明提前: 使用函数声明的形式创建的函数 function 函数名(){}会在所有代码执行前被创建, 所以我们可以在函数声明前调用它.但是用函数表达式创建的函数 var fun = function(){};不会被声明提前, 所以不能在声明前调用. 12345678910console.log(a);//输出:undefinedvar a = 10;//去掉var之后, 第一行报错fun();function fun()&#123; console.log(\"我是fun\");&#125;var fun1 = function()&#123; console.log(\"我是fun1\");&#125;;fun1();//只能在这之后调用, 否则会报错. B.函数作用域 函数被调用时, 创建自己的函数作用域, 函数执行完毕, 函数作用域销毁 每调用一次函数, 创建一个新的函数作用域, 作用域之间互相独立 函数作用域中可以访问到全局变量, 但全局作用域无法访问到局部变量 在函数中操作一个变量时, 首先在自身作用域中寻找, 没有的话向上一级寻找 函数中想使用全局变量, 可以使用window.变量名 函数的形参相当于在函数作用域中声明的. 也存在声明提前的问题, 但提前声明于当前作用域 三.debug这种调试, 可以查看执行过程中内存的状态, 各变变量的情况. 123456789alert(d);//声明提前var a = 10;var b = 15;c = 20;//不要监视c可能会出错卡死function fun()&#123; console.log(\"我是fun\");&#125;var d = 25; 先打开, 浏览器的开发者工具, 以chrome为例, 按F12, 选择sources, 之后如下图: 其他浏览器类似 四.this你可以这样理解: &emsp;&emsp;解析器在调用函数时每次都会向函数内部传递一个隐含的参数this, this指向一个对象, 这个函数我们称为函数执行的上下文对象, 根据函数的调用方式不同, this会指向不同的对象 123456789101112131415function fun()&#123; console.log(this.name + \" \" + this);&#125;fun();//这时this指向window对象,this.name=\"全局的name\";var name = \"全局的name\";var obj = &#123; name:\"孙悟空\", show:fun&#125;;obj.show();//这时this指向obj, this.name=\"孙悟空\";var obj1 = &#123; name:\"猪八戒\", show:fun&#125;;obj1.show();//这时this指向obj1, this.name=\"猪八戒\"; 五.call()和apply() 这两个方法都是函数对象的方法, 需要通过函数对象来调用 当函数对象调用call()和apply()方法时, 函数中的代码也会执行. 可以将一个对象指定为call和apply的第一个参数, 这个对象将会成为函数执行时的this call()方法, 将函数原本的实参在第一个参数(对象)以后依次传递给函数的形参 apply()方法, 将函数原本的实参封装到一个数组统一传递. 12345678910111213141516171819202122function fun()&#123; console.log(this);&#125;var obj1 = &#123;name:\"obj1\",show:function()&#123; console.log(this.name);&#125;&#125;;var obj2 = &#123;name:\"obj2\"&#125;;fun();//输出:windowfun.call(obj1);//输出:objectfun.apply(obj2);//输出:objectobj1.show();//输出:obj1obj1.show.call(obj2);//输出:obj2function fun2(a,b)&#123; console.log(\"a = \"+a); console.log(\"b = \"+b);&#125;fun2.call(obj1,1,2);//将参数依次传递fun2.apply(obj1,[1,2]);//将参数封装成数组统一传递 this的情况: 在函数中调用时, this永远指window 在方法中调用时, this是调用方法的对象 在构造函数中调用时, this是正在创建的对象 使用call和apply调用时, this是参数传递过来的对象 六.arguments 在调用函数时, 浏览器都会传递进两个隐含的参数:①函数的上下文对象:this②封装实参的对象: arguments, 我们传递的实参都保存在里面 arguments是一个类数组对象, 它不是数组, 但是它也可以通过数字索引来操作数据. arguments.length可以获取实参的长度, 我们即使没定义形参, 也可以通过arguments来使用形参, 但这样比较麻烦 arguments[0]表示第一个实参, 以此类推. arguments.callee属性, 表示当前的函数对象 12345678function fun()&#123; console.log(arguments instanceof Array);//判断arguments是不是数组,输出:false console.log(Array.isArray(arguments));//判断arguments是不是数组,输出:false console.log(arguments.length);//输出:4 console.log(arguments[3]);//输出:true console.log(arguments.callee == fun);//输出:true&#125;fun(\"one\",\"two\",3,true);","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JS对象简介","slug":"JS2-0","date":"2019-03-30T13:08:10.000Z","updated":"2019-04-03T05:09:18.580Z","comments":true,"path":"JS2-0.html","link":"","permalink":"http://crainyday.gitee.io/blog/JS2-0.html","excerpt":"JS的Object类型","text":"JS的Object类型 一.Object对象Object类型, 我们也称为一个对象. 是JavaScript中的引用数据类型. 它是一种复合值, 它将很多值聚合到一起, 可以通过名字访问这些值. 对象也可以看做是属性的无序集合, 每个属性都是一个名/值对. 对象除了可以创建自有属性, 还可以通过从一个名为原型的对象那里继承属性. 除了字符串、数字、true、false、null和undefined之外, JS中的值都是对象. 对象可以说是对一些名值对的封装 A.对象的分类: 内建对象: 由ES标准制定的对象, 在任何ES的实现中都能使用 比如: Math String Number Boolean Function Object…… 宿主对象: 由JS的运行环境提供的对象, 目前主要指浏览器提供的对象 比如: BOM DOM 自定义对象(最难): 由开发人员自己创建的对象 二.创建自定义对象访问属性的两种方式: 用 . 访问: 对象.属性名 用 [] 访问: 对象[‘属性名’], 这样操作属性更灵活, 常用于操作一些特殊的属性名 属性名的命名方式, 建议按照标识符的规范去做; 属性值可以是任意类型的值, 甚至是一个对象. 12345678910111213141516171819//方式一:先创建对象, 再添加属性var person = new Object();person.name = \"孙悟空\";//添加name属性person.age = 18;//添加age属性person.name = \"牛魔王\";//修改属性delete person.name;//删除属性console.log(person.name);//读取属性, 如果读取不到对象的属性会返回undefined//方式二:创建对象的同时添加属性, 这种叫做对象字面量var sex = \"男\";var person1 = &#123; name: \"孙悟空\", age: 18, \"123\": 789//最后一个属性后一定不能加逗号&#125;;person1[sex] = sex;console.log(person1[sex]);var index = '123';console.log(person1['123']);//person1.123是不允许的console.log(person1[index]);//与person1['123']等价 三.in运算符通过该运算符检查对象是否有某个属性, 有则返回true, 没有返回false. 格式: “属性名” in object, 例: 123456var person = &#123; name: \"孙悟空\", age: 18, \"123\": 789&#125;;console.log(\"obj\" in person); 四.数据类型基本数据类型&amp;引用数据类型 基本数据类型: Number String Boolean Null Undefined 基本数据类型的值是无法修改的, 是不可变的. 基本数据类型的比较是值的比较, 也就是只要两个变量的值相等, 我们就认为这两个变量相等. 引用数据类型: Object 当一个变量是一个对象时, 实际上变量中保存的并不是对象本身, 而是对象的引用(堆内存中对象的地址). 当从一个变量向另一个变量复制引用类型的值时, 会将对象的引用复制到变量中, 并不是创建一个新的对象. 这时, 两个变量指向的是同一个对象. 因此, 改变其中一个变量会影响另一个 对比如下代码即结果, 有什么区别? 123456789101112131415161718var a = 123;var b = a;a ++;console.log(\"a = \" + a + \";b = \" + b);var obj = &#123; name:\"孙悟空\", birth:&#123; year:1998, month:10, day:8 &#125;&#125;;var obj2 = obj;obj2.name = \"牛魔王\";console.log(\"obj.name = \" + obj.name + \"; obj2.name = \" + obj2.name);//obj2 = null;//若执行obj2 = null;那obj2不再指向任何内容, 如下命令会出错obj2.name = \"猪八戒\";console.log(obj == obj2);//引用数据类型比较的是地址 JS运行时, 基本类型的变量直接存在栈空间; 引用类型的实体(即对象)保存在堆空间, 变量中保存的实际上对象在堆内存中的地址. 以上代码在内存中的情况如下: 五.for…in语句 在开发过程中, 我们往往会使用别人给我们提供好的对象 但我们不知道对象里有什么属性 这时就用到了for…in语句来遍历对象的属性 例: 123456789101112var obj = &#123; name:\"CRD\", sex:\"男\", age:20, nation:\"中国\", sayHello:function()&#123; console.log(\"你好\"); &#125;&#125;;for(var index in obj)&#123;//这里不能用obj.index来操作属性 console.log(\"名:\" + index + \";值:\" + obj[index]);&#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JS流程控制","slug":"JS1-2","date":"2019-03-29T15:56:03.000Z","updated":"2019-04-03T05:07:33.503Z","comments":true,"path":"JS1-2.html","link":"","permalink":"http://crainyday.gitee.io/blog/JS1-2.html","excerpt":"JS的基本语法: 流程控制","text":"JS的基本语法: 流程控制 条件判断语句 if-else 条件分支语句 switch-case 循环语句 for while 一.if-else12345678910111213141516171819//①if(条件表达式)&#123; &#125;//②if(条件表达式)&#123; //执行的语句1;&#125;else&#123; //执行的语句2;&#125;//③if(条件表达式1)&#123; //执行的语句1;&#125;else if(条件表达式2)&#123; //执行的语句2;&#125;else if( 条件表达式3)&#123; //执行的语句3;&#125;...&#123;&#125;else&#123; //执行的语句;&#125; [注意] 一旦满足某个条件表达式, 则进入其执行语句块执行, 执行完毕, 跳出当前的条件判断结构, 不会执行剩下的条件结构语句. 如果多个条件表达式之间为“互斥”关系, 多个结构可以上下调换顺序.如果多个条件表达式之间为“包含”关系, 要求条件表达式范围小的写在范围大的上面. 二.switch-case123456789switch(变量)&#123; case 值1: //break; case 值2: //break; ... default: break;&#125; 1.case后只能填写变量的值, 不能写范围.2.default是可以省略的, 并且其位置也是灵活的, 但通常将其放在case语句之后.3.一旦满足某个case语句, 则进入执行其操作, 直至遇到break或者程序终止.4.若要判断的语句的条件满足switch变量的数据类型, 且值不多的情况下, 建议选择switch-case .除此之外, 选择if-else. 三.循环语句格式:①初始化条件②循环条件③迭代部分④循环体 123456789101112131415for(①;②;③)&#123; ④&#125;//①while(②)&#123; ④ ③&#125;//①do&#123; ④ ③&#125;while(②); 注意 1.不同的循环结构之间可以相互转换 2.while和do-while的区别; do-while程序至少会执行一次 嵌套循环: 上述循环体嵌套循环体若外层循环执行m次, 内层循环执行n次, 整个程序执行m*n次 . 无限循环结构: 我们往往会在无限循环结构内部提供循环的终止条件, 使用break关键字跳出循环.避免死循环. 123456789101112131415for(;;)&#123; ... if( )&#123; break; &#125; ...&#125;//或者while(true)&#123; ... if( )&#123; break; &#125; ...&#125; break&amp;continue使用switch-case结构或者循环结构中在循环结构中, 一旦执行到break, 就跳出当前循环 . continue:使用在循环结构中, 一旦执行到continue, 就跳出当次循环, 继续执行下一次循环. 1234567for(var i = 1;i &lt;= 10;i++)&#123; if(i % 4 == 0)&#123; //break; //程序执行结果:123 continue; //程序执行结果:123567910 &#125; console.log(i);&#125; 在嵌套循环中, 使用带标签的break和continue. 1234567891011label:for(var i = 1;i &lt; 5;i++)&#123; for(var j = 1;j &lt;= 10;j++)&#123; if(j % 4 == 0)&#123; //break; //continue; //break label; continue label; &#125; console.log(j); &#125;&#125; 例题: 求100以内的素数 1234567891011121314var n = 100;for(var i = 2;i &lt;= n;i ++)&#123; var m = Math.floor(Math.sqrt(i)); var flag = true; for(var j = 2;j &lt;= m;j ++)&#123; if(i % j == 0)&#123; flag = false; break; &#125; &#125; if(flag)&#123; console.log(i); &#125;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JS基础语法","slug":"JS1-1","date":"2019-03-29T15:55:58.000Z","updated":"2019-04-03T05:07:02.559Z","comments":true,"path":"JS1-1.html","link":"","permalink":"http://crainyday.gitee.io/blog/JS1-1.html","excerpt":"JS基础语法","text":"JS基础语法 一.JS注释 和其他高级语言差不多, 分为: 多行注释: /**/ 单行注释: // 注释中的代码不会被执行, 只能在源码中看见注释的内容 二.JS的变量与字面量变量的作用是给某一个值或对象标注名称, 方便复用, 变量也用来保存字面量 字面量: 可以直接使用, 不能更改其值, 像: 123、”Hello”、1.23等 变量的声明: 使用var关键字声明一个变量, 例: var a; 变量的赋值: 使用=为变量赋值, 例: a=123; 声明和赋值同时进行, 例, var a = 123; 三.JS标识符所谓标识符, 就是指变量、函数、属性的名字, 或函数的参数.要求: 第一个字符必须是一个字母、下划线_或一个美元符号$. 不能以数字开头, 不能是关键字或保留字 其他字符可以是字母、下划线、美元符号或数字. 标识符一般采用驼峰命名法(规范): 首字母小写, 每个单词首字母大写其他字母小写, 例: xxxYyyZzz JS底层保存标识符是用Unicode编码的 命名时, 尽量见名知意, 遵守它的规则和行业规范. 四.数据类型 String(字符串型), 例: “Hello World”或’Hello World’ Number(数值型), 例: 123、1.23 Boolean(布尔型), 只有 true false两个取值 Null(null型), 只有一个取值: null, 用来表示一个对象为空; 用 typeof null;会返回object Undefined(undefined型), 未定义, 当声明了一个变量而没赋值时, 变量的值就是undefined 上述五种基本类型之外的类型: Object String: 使用单或双引号括起来的整体, 但是单双引号不能嵌套. 了解一些常见的转义字符 Number: 正无穷(Infinity), 负无穷(-Infinity); Nut a Number(NaN) 尽量避免用JS做一些高精度的计算问题 用typeof运算符可以检查变量的类型, 例: 12345678910var a = 123;console.log(typeof a);//输出结果为:numbervar b = Number.MAX_VALUE + 1;console.log(b);//输出结果为:Infinityvar c = Number.MIN_VALUE;//JS能表示的大于零的最小值//Number有它能表示的最大值, 为Number.MAX_VALUE;//当计算结果超过它时, 输出结果为:Infinity(number型)即正无穷var str = \"123\" * \"123\";//当计算结果非数字时, 会返回一个NaN(number型)console.log(typeof str);//结果为:NaN 五.强制类型转换 其他类型变量转换为String, 调用变量的toString()方法, 或调用String()函数 其他类型变量转换为Number, 调用Number()函数, 对于字符串还可调用parseInt()或parseFloat()函数 其他类型变量转换为Boolean, 调用Boolean()函数 点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738//其他类型变量转换为Stringvar a = 123;//注意:当a = null;或a = undefined;时, 不能调用a.toString()方法a = a.toString();//toString()方法, 无参数, 将a的内容变为string后返回var b = null;b = String(b);//String()函数, 将要转换的变量作为参数传递给函数, 后函数将结果返回console.log(\"a = \" + a);console.log(typeof a);//输出:stringconsole.log(\"b = \" + b);console.log(typeof b);//其他类型变量转换为Numbervar str = \"123\";//若字符串内容有非数字和空格, Number()函数会将内容转换为NaNstr = Number(str);console.log(\"str = \" + str);console.log(typeof str);var bool = true;//true==&gt;1 false==&gt;0 null==&gt;0 undefined==&gt;NaNbool = Number(bool);console.log(\"bool = \" + bool);console.log(typeof bool);var px = \"123px\";px = parseInt(px);//从第一个字符开始转换, 直到遇到非空和非数字.parseFolat()函数类似console.log(\"px = \" + px);console.log(typeof px);//JS中数字的进制, 0x开头表示16进制, 0开头表示8进制px = \"070\";px = parseInt(px,10);//第二个参数, 表示以几进制进行解析console.log(\"px = \" + px);console.log(typeof px);//其他类型变量转换为Booleanvar num = 123;//数字只有0和NaN转换为false, 字符串只有空串转换为falsenum = Boolean(num);//null和undefined转换为false, 对象都转换为trueconsole.log(\"num = \" + num);console.log(typeof num);//这里说一个isNaN()函数, 判断一个数字是不是NaN, 若是返回true, 不是返回falseconsole.log(isNaN(num)); 六.运算符 算术运算符 + - * / ++(前置和后置) –(前置和后置) +(符号不变) -(符合取反) %(取模) 逻辑运算符 &amp;&amp; || ! &amp; | 关系运算符 &gt; &lt; &gt;= &lt;= == != === !== 赋值运算符 = += -= *= /= %= 条件运算符 ?:, 格式: 条件表达式?表达式1:表达式2; 若条件表达式为true, 整个表达式值为表达式1的值, 否则为表达式2的值. 位运算符 ^ &amp; | ! (用于数值类型的操作) typeof运算符 判断类型并以字符串形式返回 A.算术运算符:+的特殊性, 可以用来拼接字符串, 例: 12var a = 1 + 2 + \"3\";//33var b = \"1\" + 2 + 3;//123 其他算数运算符在进行运算时, 会将操作数先转换为Number类型, 再进行运算, 并将结果以数值类型返回 前++: 先对原变量加1, 在使用该变量的值;后++: 先使用给变量的值, 再给变量加1;–类似 B.逻辑运算符与 或 非, 运算时将其他类型转换为Boolean型, 再运算; 注意短路与(&amp;&amp;)和短路或(||): 短路与: 若第一个值为true, 则返回第二个值; 若第一个值为false, 则返回第一个值; 短路或: 若第一个值为true, 则返回第一个值; 若第一个值为false, 则返回第二个值; C.关系元算符比较两个字符串时, 比较的是字符串的字符编码(按位比较); 其他类型转换为数值类型比较; 比较结果为true或false, 以字符串形式返回比较的结果. 注意==判等时会做隐式类型转换, ===表示全等; != 与 !==一样 D.赋值运算符将运算符左边的表达式的值做一个操作, 然后将操作后的值赋值给右边的变量. 七.Unicode编码表在JS的字符串中, 使用转义字符\\u+四位16进制的编码表示Unicode编码 在HTML中, 使用 &amp;#10进制编码; 表示Unicode编码. 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;JS基础&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var str = \"\\u2620\"; console.log(str); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&amp;#9760;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 注意: JS中严格区分大小写(HTML中不区分) JS中一个分号代表一条命令的结束 JS会忽略多个空格与换行符, 因此我们可以用来格式化自己的代码 JS代码是一条条以;结尾的语句, 可用{}将语句分组, 一个{}也叫一个代码块","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JS简介","slug":"JS1-0","date":"2019-03-29T15:55:39.000Z","updated":"2019-04-03T05:04:59.849Z","comments":true,"path":"JS1-0.html","link":"","permalink":"http://crainyday.gitee.io/blog/JS1-0.html","excerpt":"JavaScript简介","text":"JavaScript简介 一.起源 JavaScript诞生于1995年, 它的出现主要是用于处理网页中的前端验证. 所谓的前端验证, 就是指检查用户输入的内容是否符合一定的规则. 比如: 用户名的长度，密码的长度，邮箱的格式等. 二.JavaScript构成 ECMAScript(JS的标准) DOM(JS操作网页) BOM(JS操作浏览器) 三.JS的特点 解释型语言 类似于 C 和 Java 的语法结构 动态语言 基于原型的面向对象 JavaScript是一门解释型语言, 所谓解释型值语言不需要被编译为机器码在执行, 而是直接执行. JavaScript和与Java的关系也仅仅是看起来像而已 JavaScript是一门动态语言, 所谓的动态语言可以暂时理解为在语言中的一切内容都是不确定的. 比如一个变量, 这一时刻是个整型, 下一时刻可能会变成字符串了. JS可能是运行速度最快的动态语言了 JavaScript是一门面向对象(基于原型的面向对象)的语言 四.JS的Hello WorldA.JS代码的位置 JS代码写在网页(.html文件)的script标签中 JS代码可以写在标签的onclick属性中, 点击时才会执行 JS代码写在超链接的href属性中, 点击时才会执行 JS代码写在外部.js文件中, 用script标签引入该文件到网页 虽然可以写在标签的属性中, 但是这样属于结构与行为耦合, 不方便维护, 不推荐使用 一般使用script引入外部js文件或将代码写在script标签中, 一旦script标签用于引入js文件, 那么就不能在里面编写js代码 JS代码按script标签先后顺序, 顺序执行 例: 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;JS基础&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; //弹出窗口 alert(\"Hello Wrold!\"); //输出在body标签中 document.write(\"Hello World!\"); //输出在控制台 console.log(\"Hello World!\"); &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/test.js\" &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;br /&gt; &lt;button onclick=\"alert('讨厌, 点我干嘛~~~')\"&gt;点我一下试试&lt;/button&gt; &lt;br /&gt; &lt;a href=\"javascript:alert('让你点你就点?')\"&gt;点我一下试试&lt;/a&gt; &lt;a href=\"javascript:;\"&gt;点我一下试试&lt;/a&gt;&lt;!--点击时什么都不做--&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://crainyday.gitee.io/blog/tags/JS/"}]},{"title":"JavaInternet","slug":"JavaInternet","date":"2019-03-28T12:49:36.000Z","updated":"2019-04-03T04:34:55.561Z","comments":true,"path":"JavaInternet.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaInternet.html","excerpt":"Java网络编程","text":"Java网络编程 一.网络编程概述 Java是 Internet 上的语言, 它从语言级上提供了对网络应用程序的支持, 程序员能够很容易开发常见的网络应用程序. Java提供的网络类库, 可以实现无痛的网络连接, 联网的底层细节被隐藏在 Java 的本机安装系统里, 由 JVM 进行控制, 并且 Java 实现了一个跨平台的网络库, 程序员面对的是一个统一的网络编程环境. 计算机网络: 把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统, 从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源.网络编程的目的: 直接或间接地通过网络协议与其它计算机进行通讯.网络编程中有两个主要的问题: ①如何准确地定位网络上一台或多台主机 ②找到主机后如何可靠高效地进行数据传输.如何实现网络中的主机互相通信: ①通信双方地址 ②一定的规则(有两套参考模型): OSI参考模型: 模型过于理想化, 未能在因特网上进行广泛推广 TCP/IP参考模型(或TCP/IP协议): 事实上的国际标准. 二.通讯要素1.IP和端口号 IP 地址: InetAddress ①唯一的标识 Internet 上的计算机 ②本地回环地址(hostAddress): 127.0.0.1 主机名(hostName)：localhost ③不易记忆端口号标识正在计算机上运行的进程(程序) ①不同的进程有不同的端口号 ②被规定为一个 16 位的整数 0~65535. 其中, 0~1023被预先定义的服务通信占用(如My Sql占用端口3306, http占用端口80等). 除非我们需要访问这些特定服务, 否则, 就应该使用 1024~65535 这些端口中的某一个进行通信, 以免发生端口冲突. 端口号与IP地址的组合得出一个网络套接字(socket). 2.网络通信协议 ​ 计算机网络中实现通信必须有一些约定, 即通信协议, 对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准.​ 通信协议分层的思想 TCP/IP协议簇 传输层协议中有两个非常重要的协议: 传输控制协议TCP(Transmission Control Protocol) 用户数据报协议UDP(User Datagram Protocol)TCP/IP 以其两个主要协议: 传输控制协议(TCP)和网络互联协议(IP)而得名, 实际上是一组协议, 包括多个具有不同功能且互为关联的协议.IP(Internet Protocol)协议是网络层的主要协议, 支持网间互连的数据通信.TCP/IP协议模型从更实用的角度出发, 形成了高效的四层体系结构, 即物理链路层、IP层、传输层和应用层. TCP协议: 使用TCP协议前, 须先建立TCP连接, 形成传输数据通道 传输前, 采用“三次握手”方式, 是可靠的 TCP协议进行通信的两个应用进程: 客户端、服务端 在连接中可进行大数据量的传输 传输完毕, 需释放已建立的连接, 效率低 UDP协议(视频传输一般用的此协议): 将数据、源、目的封装成数据包, 不需要建立连接 每个数据报的大小限制在64 K内 因无需连接, 故是不可靠的 发送数据结束时无需释放资源, 速度快 3.Socket 利用套接字(Socket)开发网络应用程序早已被广泛的采用, 以至于成为事实上的标准. 通信的两端都要有Socket, 是两台机器间通信的端点 网络通信其实就是Socket间的通信 Socket允许程序把网络连接当成一个流, 数据在两个Socket间通过IO传输 一般主动发起通信的应用程序属客户端, 等待通信请求的为服务端 4.InetAddress类 Internet上的主机有两种方式表示地址: 域名(hostName): localhost IP 地址(hostAddress): 127.0.0.1InetAddress类主要表示IP地址, 两个子类: Inet4Address、Inet6Address.InetAddress 类对象含有一个 Internet 主机地址的域名和IP地址: localhost 和 127.0.0.1域名容易记忆, 当在连接网络时输入一个主机的域名后, 域名解析服务器(DNS)负责将域名转化成IP地址, 这样才能和主机建立连接. ——-域名解析 Windows系统中, 访问域名, 先找本机hosts(C:\\Windows\\System32\\drivers\\etc\\hosts), 是否有输入的域名地址, 没有的话, 再通过DNS服务器, 找主机. 1234567891011121314public static void main(String[] args) throws Exception &#123; //创建一个InetAddress对象: getByName() InetAddress inet = InetAddress.getByName(\"localhost\"); //inet = InetAddress.getByName(\"127.0.0.1\"); System.out.println(inet); //两个方法 System.out.println(inet.getHostName()); System.out.println(inet.getHostAddress()); //获取本机的IP: getLocalHost() InetAddress inet1 = InetAddress.getLocalHost(); System.out.println(inet1); System.out.println(inet1.getHostName()); System.out.println(inet1.getHostAddress());&#125; 三.基于Socket的TCP编程Java语言的基于套接字编程分为服务端编程和客户端编程, 有两个类Socket类和ServerSocket类 1.TCP编程示例一客户端给服务端发送信息, 服务端将信息输出在控制台上. 注意: 测试时, 先开启服务端, 再开启客户端点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 客户端@Testpublic void client() &#123; Socket socket = null; OutputStream os = null; try &#123; //1.创建一个Socket的对象, 通过构造器指明服务端的IP地址, 以及其接收程序的端口号 socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9999); //2.getOutputStream(): 发送数据, 方法返回OutputStream的对象 os = socket.getOutputStream(); //3.具体的输出过程 os.write(\"我是客户端发送的信息\".getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.关闭相应的流和Socket对象 if (os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;// 服务端@Testpublic void server() &#123; ServerSocket ss = null; Socket s = null; InputStream is = null; try &#123; //1.创建一个ServerSocket的对象, 通过构造器指明自身的端口号 ss = new ServerSocket(9999); //2.调用其accept()方法, 返回一个Socket的对象 s = ss.accept(); //3.调用Socket对象的getInputStream()获取一个从客户端发送过来的输入流 is = s.getInputStream(); //4.对获取的输入流进行的操作 byte[] b = new byte[16]; int len = -1; while ((len = is.read(b)) != -1) &#123; String str = new String(b, 0, len); System.out.print(str); &#125; System.out.println(\"收到来自于\" + s.getInetAddress().getHostAddress() + \"的信息\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //5.关闭相应的流以及Socket、ServerSocket的对象 if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (s != null) &#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (ss != null) &#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ## 2.TCP编程示例二客户端给服务端发送信息, 服务端将信息打印到控制台上, 同时回馈”成功接受”给客户端点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//客户端@Testpublic void client()&#123; Socket socket = null; OutputStream os = null; InputStream is = null; try &#123; socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9999); os = socket.getOutputStream(); os.write(\"我是客户端的信息\".getBytes()); //shutdownOutput():执行此方法, 显式的告诉服务端发送完毕! socket.shutdownOutput(); is = socket.getInputStream(); byte[] b = new byte[16]; int len = -1; while((len = is.read(b)) != -1)&#123; String str = new String(b,0,len); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//服务端@Testpublic void server()&#123; ServerSocket ss = null; Socket s = null; InputStream is = null; OutputStream os = null; try &#123; ss = new ServerSocket(9999); s = ss.accept(); is = s.getInputStream(); byte[] b = new byte[16]; int len = -1; //下面的read()方法是阻塞式的, 需要客户端显示的告诉服务端, 发送数据完毕 while((len = is.read(b)) != -1)&#123; String str = new String(b,0,len); System.out.print(str); &#125; os = s.getOutputStream(); os.write(\"服务端成功接收\".getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; if(os != null)&#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(s != null)&#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(ss != null)&#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ## 3.TCP编程示例三从客户端发送文件给服务端, 服务端保存到本地. 并返回“成功接收”给客户端. 并关闭相应的连接.点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//客户端@Testpublic void client() &#123; Socket socket = null; OutputStream os = null; InputStream is = null; FileInputStream fis = null; try &#123; socket = new Socket(InetAddress.getByName(\"localhost\"),9999); os = socket.getOutputStream(); fis = new FileInputStream(new File(\"1.png\")); int length = -1; byte[] a = new byte[1024]; while((length = fis.read(a))!=-1) &#123; os.write(a, 0, length); &#125; socket.shutdownOutput(); is = socket.getInputStream(); int len = -1; byte[] b = new byte[16]; while((len = is.read(b))!= -1) &#123; String str = new String(b, 0, len); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(os !=null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//服务端@Testpublic void server() &#123; ServerSocket ss = null; Socket s = null; InputStream is = null; OutputStream os = null; FileOutputStream fos = null; try &#123; ss = new ServerSocket(9999); s = ss.accept(); is = s.getInputStream(); fos = new FileOutputStream(new File(\"2.png\")); byte b[] = new byte[1024]; int len = -1; while((len = is.read(b))!=-1) &#123; fos.write(b, 0, len); &#125; System.out.println(\"收到来自于\" + s.getInetAddress().getHostAddress() + \"的文件\"); os = s.getOutputStream(); os.write(\"成功接收\".getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(s != null) &#123; try &#123; s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(ss != null) &#123; try &#123; ss.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; # 四.基于Socket的TCP编程- 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序.- UDP数据报通过数据报套接字 DatagramSocket 发送和接收, 系统不保证UDP数据报一定能够安全送到目的地, 也不能确定什么时候可以抵达.- DatagramPacket 对象封装了UDP数据报, 在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号.- UDP协议中每个数据报都给出了完整的地址信息, 因此无须建立发送方和接收方的连接.## 1.流 程:1. DatagramSocket与DatagramPacket2. 建立发送端，接收端3. 建立数据包4. 调用Socket的发送、接收方法5. 关闭Socket发送端与接收端是两个独立的运行程序 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334//发送端@Testpublic void send() &#123; DatagramSocket ds = null; try &#123; ds = new DatagramSocket(); byte[] b = \"这是发送端发送过来的数据\".getBytes(); DatagramPacket dp = new DatagramPacket(b, 0, b.length, InetAddress.getByName(\"127.0.0.1\"), 9999); ds.send(dp); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(ds != null) &#123; ds.close(); &#125; &#125;&#125;//接收端@Testpublic void rceive() &#123; DatagramSocket ds = null; try &#123; ds = new DatagramSocket(9999); byte[] b = new byte[1024]; DatagramPacket dp = new DatagramPacket(b, 0, b.length); ds.receive(dp); String str = new String(dp.getData(),0,dp.getLength()); System.out.println(str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; ds.close(); &#125;&#125; 五.URL编程 URL(Uniform Resource Locator): 统一资源定位符, 它表示 Internet 上某一资源的地址. 通过 URL 我们可以访问 Internet 上的各种网络资源, 比如最常见的 www, ftp 站点. 浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源. URL的基本结构由5部分组成:&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;例如: http://127.0.0.1:8080/helloworld/index.jsp 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Testpublic void download() &#123; InputStream is = null; InputStream is2 = null; FileOutputStream fos = null; try &#123; URL url = new URL(\"https://papertome.com/hello.txt\"); //读取服务器上的资源法一: is = url.openStream(); byte[] b = new byte[16]; int len = -1; while((len = is.read(b))!=-1) &#123; String str = new String(b,0,len,\"utf-8\"); System.out.print(str); &#125; //读取服务器上的资源法二: URLConnection urlConn = url.openConnection(); is2 = urlConn.getInputStream(); fos = new FileOutputStream(new File(\"hello.txt\")); while((len = is2.read(b))!=-1) &#123; fos.write(b, 0, len); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(is2 != null) &#123; try &#123; is2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"JavaReflection","slug":"JavaReflection","date":"2019-03-27T13:48:35.000Z","updated":"2019-04-03T04:36:44.071Z","comments":true,"path":"JavaReflection.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaReflection.html","excerpt":"Java的反射机制","text":"Java的反射机制 一.Java ReflectionReflection(反射)是被视为动态语言的关键, 反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息, 并能直接操作任意对象的内部属性及方法 1.Java反射机制提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的成员变量和方法 生成动态代理(前边讲interface时有静态代理) 2.反射相关的主要API: java.lang.Class:代表一个类 java.lang.reflect.Method:代表类的方法 java.lang.reflect.Field:代表类的成员变量 java.lang.reflect.Constructor:代表类的构造方法 3.初识反射通过反射在运行时构造一个类的对象, 调用方法和成员变量点击显/隐内容 12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestReflection &#123; public static void main(String[] args) throws Exception&#123; //class文件中运行时Person类即为Class类的实例(clazz) Class&lt;Person&gt; clazz = Person.class; //1.创建clazz对应的运行时类(Person类)的对象 Person p = clazz.newInstance(); System.out.println(p); //2.通过反射调用运行时类指定的成员变量 Field f1 = clazz.getField(\"name\");//调用public变量 f1.set(p, \"LiuDehua\"); Field f2 = clazz.getDeclaredField(\"age\");//调用private变量 f2.setAccessible(true); f2.set(p, 21); System.out.println(p); //3.反射调用运行时类指定的方法 Method m1 = clazz.getMethod(\"show\");//无参方法 m1.invoke(p); Method m2 = clazz.getMethod(\"display\", String.class);//带参方法 m2.invoke(p, \"CHINA\"); &#125;&#125;class Person&#123; public String name; private int age; public Person() &#123; super(); &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public void show() &#123; System.out.println(\"我是一个人\"); &#125; public void display(String nation) &#123; System.out.println(\"我的国籍是:\"+nation); &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \"]\"; &#125;&#125; 二.反射的源头Class类 源文件经过编译(javac.exe)以后, 得到一个或多个.class文件, .class文件经过运行(java.exe)这步, 就需要进行类的加载(通过JVM的类加载器), 加载到内存的缓存中. 每一个放入缓存中的.class文件就是一个Class的实例! Class的一个对象, 对应着一个运行时类(每一个运行时类只加载一次). 相当于一个运行时类本身充当了Class的一个实例. 每一个对象, 都能通过它的getClass()方法, 得到它对应的运行时类 通过Class的实例得到一个运行时类中的完整结构(属性, 方法, 构造器, 内部类, 父类, 所在包, 异常, 注解, … ) 1.创建Class类的对象 通过运行时类本身的.class属性获取 通过运行时类对象的getClass()方法获取 通过Class类的静态方法Class.forName(String path)方法 (了解)通过类加载器(ClassLoader)的对象的loadClass(String path)方法 ClassLoader的应用: 点击显/隐内容 12345678910111213public static void main(String[] args)&#123; //法一: ClassLoader loader = this.getClass().getClassLoader(); InputStream is = loader.getResourceAsStream(\"com\\\\crd\\\\reflection\\\\jdbc.properties\"); //法二:// FileInputStream is = new FileInputStream(new File(\"jdbc1.properties\")); Properties pros = new Properties(); pros.load(is); String name = pros.getProperty(\"user\"); System.out.println(name); String password = pros.getProperty(\"password\"); System.out.println(password);&#125; 有了Class的实例后, 可以做什么? 创建对应的运行时类的对象(重点) 获取对应运行时类完整的类的结构: 属性、方法、构造器、包、父类、接口、泛型、注解、异常、内部类… 调用对应的运行时类中指定的结构(某个指定的属性、方法、构造器)(重点) 12345678910111213141516//获取到对应的运行时类中声明的权限为public的方法(包含其父类中的声明的public)Method[] m1 = clazz.getMethods();//获取到对应的运行时类中声明的所有的方法(①任何权限修饰符修饰的都能获取②不含父类中的)Method[] m2 = clazz.getDeclaredMethods();//获取其他结构调用类似方法即可//获取父类的泛型(以后会用到)@Testpublic void test1()&#123; Class clazz = Person.class; Type type = clazz.getGenericSuperclass(); ParameterizedType param = (ParameterizedType)type; Type[] arr = param.getActualTypeArguments(); for(int i = 0;i &lt; arr.length;i ++)&#123; System.out.println((Class)arr[i]);//父类的泛型 &#125;&#125; 注意: 调用getDeclaredXxx()方法后, 建议要调用一下, setAccessible(true); 2.创建运行时类的对象 使用Class实例的newInstance()方法创建, 该方法默认调用运行时类的空参构造器(该构造器需要足够的权限) 故, 创建类时建议创建一个空参的构造器 也能用指定的构造器创建运行时类的对象 12345678@Testpublic void test() throws Exception&#123; Class clazz = Person.class; Constructor cons = clazz.getDeclaredConstructor(String.class,int.class);//指定构造器 cons.setAccessible(true); Person p = (Person)cons.newInstance(\"Tom\",10); System.out.println(p);&#125; 三.动态代理 代理设计模式的原理: 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上 之前提到过静态代理, 特征是代理类和被代理类都是在编译期间确定下来, 不利于程序的扩展. 同时, 每一个代理类只能为一个接口服务, 这样一来程序开发中必然产生过多的代理. 最好可以通过一个代理类完成全部的代理功能 静态代理: 要求被代理类和代理类同时实现相应的一套接口; 通过代理类的对象调用重写接口的方法时, 实际上执行的是被代理类的同样的方法的调用. 点击显/隐内容 12345678910111213141516171819202122232425262728//创建接口interface ClothFactory&#123; void productCloth();&#125;//创建被代理类class NikeClothFactory implements ClothFactory&#123; public void productCloth()&#123; System.out.println(\"Nike工厂生产衣服\"); &#125;&#125;//创建代理类class ProxyFactory implements ClothFactory&#123; ClothFactory cf; public ProxyFactory(ClothFactory cf)&#123; this.cf = cf; &#125; public void productCloth()&#123; System.out.println(\"代理类开始代理\"); cf.productCloth(); &#125;&#125;public class TestFactory&#123; public static void main(String [] args)&#123; NikeClothFactory nike = new NikeClothFactory();//创建被代理类 ProxyFactory proxy = new ProxyFactory(nike);//创建代理类 proxy.productCloth(); &#125;&#125; 动态代理: 在程序运行时, 根据被代理类及其实现的接口, 动态的创建一个代理类. 当调用代理类的实现的抽象方法时, 就发起对被代理类同样方法的调用. 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334353637383940414243//动态代理的使用, 反射是动态语言的关键interface Subject &#123; void action();&#125;//被代理类class RealSubject implements Subject &#123; public void action() &#123; System.out.println(\"我是被代理类, 记得要执行我哦!么么~~\"); &#125;&#125;class MyInvocationHandler implements InvocationHandler &#123; Object obj;//实现了接口的被代理类的对象的声明 //①给被代理的对象实例化②返回一个代理类的对象 public Object blind(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); &#125; //当通过代理类的对象发起对被重写的方法的调用时, 都会转换为对如下的invoke方法的调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //method方法的返回值时returnVal Object returnVal = method.invoke(obj, args); return returnVal; &#125;&#125;public class TestProxy &#123; public static void main(String[] args) &#123; //1.被代理类的对象 RealSubject real = new RealSubject(); //2.创建一个实现了InvacationHandler接口的类的对象 MyInvocationHandler handler = new MyInvocationHandler(); //3.调用blind()方法，动态的返回一个同样实现了real所在类实现的接口Subject的代理类的对象。 Object obj = handler.blind(real); Subject sub = (Subject)obj;//此时sub就是代理类的对象 sub.action();//转到对InvacationHandler接口的实现类的invoke()方法的调用 //再举一例 NikeClothFactory nike = new NikeClothFactory(); ClothFactory proxyCloth = (ClothFactory)handler.blind(nike);//proxyCloth即为代理类的对象 proxyCloth.productCloth(); &#125;&#125; 1.动态代理与AOP点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960interface Human &#123; void info(); void fly();&#125;// 被代理类class SuperMan implements Human &#123; public void info() &#123; System.out.println(\"我是超人！我怕谁！\"); &#125; public void fly() &#123; System.out.println(\"I believe I can fly!\"); &#125;&#125;class HumanUtil &#123; public void method1() &#123; System.out.println(\"=======方法一=======\"); &#125; public void method2() &#123; System.out.println(\"=======方法二=======\"); &#125;&#125;class MyInvocationHandler implements InvocationHandler &#123; Object obj;// 被代理类对象的声明 public void setObject(Object obj) &#123; this.obj = obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; HumanUtil h = new HumanUtil(); h.method1(); Object returnVal = method.invoke(obj, args); h.method2(); return returnVal; &#125;&#125;class MyProxy &#123; // 动态的创建一个代理类的对象 public static Object getProxyInstance(Object obj) &#123; MyInvocationHandler handler = new MyInvocationHandler(); handler.setObject(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), handler); &#125;&#125;public class TestAOP &#123; public static void main(String[] args) &#123; SuperMan man = new SuperMan();//创建一个被代理类的对象 Object obj = MyProxy.getProxyInstance(man);//返回一个代理类的对象 Human hu = (Human)obj; hu.info();//通过代理类的对象调用重写的抽象方法 System.out.println(); hu.fly(); //********* NikeClothFactory nike = new NikeClothFactory(); Object obj1 = MyProxy.getProxyInstance(nike); ClothFactory cloth = (ClothFactory)obj1; cloth.productCloth(); &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"JavaClass","slug":"JavaClass","date":"2019-03-26T07:42:11.000Z","updated":"2019-04-03T04:31:40.756Z","comments":true,"path":"JavaClass.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaClass.html","excerpt":"Java常用类","text":"Java常用类 String StringBuffer StringBuilder System Date SimpleDateFormate Calendar Math BigInteger BigDecimal 一.字符串String: 代表不可变的字符序列. 底层使用char[]存放. String 是final的. StringBuffer: 代表可变序列的字符序列, 可以对字符串内容修改. 底层也是char[]存放 1.String内存解析点击显/隐内容 1234567891011121314151617181920212223public static void main(String[] args)&#123; String str1 = \"JavaEE\"; String str2 = \"JavaEE\"; String str3 = new String(\"JavaEE\"); String str4 = \"JavaEE\" + \"Android\"; String str5 = \"Android\"; String str6 = str1 + str5; str5 = str5 + \"Handoop\"; String str7 = str6.intern(); String str8 = \"JavaEEAndroid\"; System.out.println(str1 == str2);//true System.out.println(str1 == str3);//false System.out.println(str1.equals(str3));//true System.out.println(str4 == str6);//false System.out.println(str4.equals(str6));//true System.out.println(str7 == str4);//true System.out.println(str4 == str8);//true Person p1 = new Person(\"AA\"); Person p2 = new Person(\"AA\"); System.out.println(\"^_^\"+ (p1.name == p2.name));//true&#125; 2.String常用方法1234567891011121314151617181920public int length()public char charAt(int index)public boolean equals(Object anObject)public int compareTo(String anotherString)public int indexOf(String s)public int indexOf(String s ,int startpoint)public int lastIndexOf(String s)public int lastIndexOf(String s ,int startpoint)public boolean startsWith(String prefix)public boolean endsWith(String suffix)public boolean regionMatches(int firstStart,String other,int otherStart ,int length)public String substring(int startpoint)public String substring(int start,int end)public String replace(char oldChar,char newChar)public String replaceAll(String oldStr,String newStr)public String trim()public String concat(String str)public String[] split(String regex)public char[] toCharArray()public boolean contains(String str) 3.String与其他类型间的转换 String、基本数据类型、包装类之间的转换 ①String —&gt; 基本数据类型、包装类: 调用相应包装类的parseXxx(String str)方法 ②基本数据类型、包装类 —&gt; String: 调用字符串重载的valueOf()方法 String与byte[]之间的转换 ①String —&gt; byte[]: 调用字符串的getBytes()方法 ②byte[] —&gt; String: 调用字符串的构造器 String与char[]之间的转换 ①String —&gt; char[]: 调用字符串的toCharArray()方法 ②char[] —&gt; String: 调用字符串的构造器 点击显/隐内容 12345678910111213141516171819202122232425262728public static void main(String[] args)&#123; //1.String、基本数据类型、包装类 String str1 = \"123\"; int i = Integer.parseInt(str1); System.out.println(i); String str2 = i + \"\"; str2 = String.valueOf(i); System.out.println(str2); //2.String与byte[]之间的转换 String str3 = \"abcdefg\"; byte[] b = str.getBytes(); for(int j = 0;j &lt; b.length; j++)&#123; System.out.println((char)b[j]);//不能正确打印出汉字 &#125; String str4 = new String(b); System.out.println(str4); //3.String与char[]之间的转换 String str5 = \"love中国\"; char[] c = str5.toCharArray(); for(int j = 0;j &lt; c.length; c++)&#123; System.out.println(c[j]); &#125; String str6 = new String(c); System.out.println(str6);&#125; 4.StringBuffer类StringBuffer(相当于一个容器)类有三个构造方法: StringBuffer()初始容量为16的字符串缓冲区 StringBuffer(int size)构造指定容量的字符串缓冲区 StringBuffer(String str)将内容初始化为指定字符串内容 5.StringBuffer常用方法StringBuffer很多方法与String相同 12345678910StringBuffer append(String s)//参数可以为:int n、Object o、char n、long n、boolean nStringBuffer insert(int index, String str)public StringBuffer reverse()//调用此方法的StringBuffer也会反转StringBuffer delete(int startIndex, int endIndex)public char charAt(int n)public void setCharAt(int n ,char ch)StringBuffer replace( int startIndex ,int endIndex, String str)public int indexOf(String str)public String substring(int start,int end)public int length() 6.StringBuilder类也是可变的字符序列,而且方法也一样, JDK5.0后加的, 线程不安全, 但效率高于StringBuffer 使用String的一个弊端 string s=”a”; //创建了一个字符串 s=s+”b”; //实际上原来的”a”字符串对象已经丢弃了, 现在又产生了一个字符串s+”b”(也就是”ab”).如果多次执行这些改变串内容的操作, 会导致大量副本字符串对象存留在内存中, 降低效率. 如果这样的操作放到循环中, 会极大影响程序的性能. 7.String、StringBuffer、StringBuilder性能比较点击显/隐内容 123456789101112131415161718192021222324252627public static void main(String[] args)&#123; String text = \"\"; long startTime = 0L; long endTime = 0L; StringBuffer buffer = new StringBuffer(\"\"); StringBuilder builder = new StringBuilder(\"\"); startTime = System.currentTimeMillis(); for(int i = 0;i&lt;20000;i++)&#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(\"StringBuffer的执行时间：\"+(endTime-startTime)); startTime = System.currentTimeMillis(); for(int i = 0;i&lt;20000;i++)&#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(\"StringBuilder的执行时间：\"+(endTime-startTime)); startTime = System.currentTimeMillis(); for(int i = 0;i&lt;20000;i++)&#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println(\"String的执行时间：\"+(endTime-startTime));&#125; 二.时间相关类1.System类currentTimeMillis(): 返回当前时间的long型值. 此long值是从1970年1月1日0点0分00秒开始到当前的毫秒数.此方法常用来计算时间差 计算世界时间的主要标准: UTC(Universal Time Coordinated) GMT(Greenwich Mean Time)—格林威治时间 CST(Central Standard Time)—标准时间(四个国家) 2.Date类有两个: java.util.Date类及它的子类 java.sql.Date表示特定的瞬间, 精确到毫秒 1234567891011import java.util.Date;public void testDate()&#123; Date date = new Date();//两个构造方法, 无参和long型参数 System.out.println(date); System.out.println(System.currentTimeMillis()); System.out.println(date.getTime()); System.out.println(date.toString()); java.sql.Date d = new java.sql.Date(date.getTime()); System.out.println(d);//格式:year-month-day&#125; Date类的API不易于国际化, 大部分方法被废弃了, java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类. 3.SimpleDateFormat类 格式化: 日期 —&gt; 文本 使用SimpleDateFormat 的format()方法 解析: 文本 —&gt; 日期 使用SimpleDateFormat的parse()方法 12345678910111213141516public static void main(String[] args)&#123; //1.默认模式格式化 SimpleDateFormat sdf = new SimpleDateFormat(); String date = sdf.format(new Date()); System.out.println(date);//19-3-26 下午4:50 //2.自定义模式格式化 SimpleDateFormat sdf1 = new SimpleDateFormat(\"EEE, d MMM yyyy HH:mm:ss Z\"); date = sdf1.format(new Date()); System.out.println(date);//星期二, 26 三月 2019 16:55:16 +0800 //3.解析: Date date1 = sdf.parse(\"19-3-26 下午4:50\");//要和构造器的格式字符串对应 System.out.println(date1); date1 = sdf1.parse(\"星期二, 26 三月 2019 16:55:16 +0800\");// date1 = sdf1.parse(\"19-3-26 下午4:50\");//出异常 System.out.println(date1);&#125; 4.Calendar类Calendar是一个抽象基类, 主用用于完成日期字段之间相互操作的功能. 使用Calendar.getInstance()方法得到一个Calendar的实例, 一个Calendar的实例是系统时间的抽象表示 123456//常用方法public void get(int field)public void set(int field,int value)public void add(int field,int amount)public final Date getTime()public final void setTime(Date date) 三.计算相关类1.Math类java.lang.Math提供了一系列静态方法用于科学计算; 其方法的参数和返回值类型一般为double型. abs 绝对值acos,asin,atan,cos,sin,tan 三角函数sqrt 平方根pow(double a,doble b) a的b次幂log 自然对数exp e为底指数max(double a,double b)min(double a,double b)random() 返回0.0到1.0的随机数long round(double a) double型数据a转换为long型（四舍五入）toDegrees(double angrad) 弧度—&gt;角度toRadians(double angdeg) 角度—&gt;弧度 2.BigInteger类Integer类作为int的包装类. 能存储的最大整型值为2^31−1, BigInteger类的数字范围较Integer类的数字范围要大得多, 可以支持任意精度的整数. 构造器BigInteger(String val)常用方法public BigInteger abs()public BigInteger add(BigInteger val)public BigInteger subtract(BigInteger val)public BigInteger multiply(BigInteger val)public BigInteger divide(BigInteger val)public BigInteger remainder(BigInteger val)public BigInteger pow(int exponent)public BigInteger[] divideAndRemainder(BigInteger val) 3.BigDecimal类一般的Float类和Double类可以用来做科学计算或工程计算, 但在商业计算中, 要求数字精度比较高, 故用到java.math.BigDecimal类. BigDecimal类支持任何精度的定点数. 构造器public BigDecimal(double val)public BigDecimal(String val)常用方法public BigDecimal add(BigDecimal augend)public BigDecimal subtract(BigDecimal subtrahend)public BigDecimal multiply(BigDecimal multiplicand)public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"Thread","slug":"JaveSE-Thread","date":"2019-03-25T12:51:35.000Z","updated":"2019-04-03T05:04:16.261Z","comments":true,"path":"JaveSE-Thread.html","link":"","permalink":"http://crainyday.gitee.io/blog/JaveSE-Thread.html","excerpt":"Java多线程","text":"Java多线程 一.基本概念 程序、进程、线程 程序(program)可以理解为静态的代码 进程(process)可以理解为执行中的程序 线程(thread)可以理解为进程的进一步细分, 程序的一条执行路径 何时需要多线程 程序需要同时执行两个或多个任务 程序需要实现一些等待的任务时, 如: 用户输入、文件读写、网络操作顿、搜索等 需要一些后台运行的任务时 二.创建多线程通过java.lang.Thread类实现 方式一:继承Thread类 继承Thread类,并重写run()方法,run()方法内实现此子线程想要实现的功能 在主线程内, 创建一个子线程的对象. 调用子线程的start()方法, 启动此线程; 调用相应线程的run()方法 1234567891011121314151617181920212223class PrintNum extends Thread&#123; public void run()&#123; //子线程要执行的代码 for(int i = 1;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + \":\" + i); &#125; &#125; &#125; public PrintNum(String name)&#123; super(name); &#125;&#125;public class TestThread &#123; public static void main(String[] args) &#123; PrintNum p1 = new PrintNum(\"线程1\"); PrintNum p2 = new PrintNum(\"线程2\"); p1.setPriority(Thread.MAX_PRIORITY);//10 p2.setPriority(Thread.MIN_PRIORITY);//1 p1.start();//start()会调用run()方法 p2.start(); &#125;&#125; 注意: ①一个线程只能start()一次; ②不能用run()启动线程 Thread类的常用方法: 点击显/隐内容 1234567891011121314151617/* Thread类的常用方法: * 1.start():启动线程并调用相应的run()方法 * 2.run():子线程要执行的代码 * 3.currentThread():静态方法, 调取当前线程 * 4.getName():获取此线程的名字 * 5.setName():设置此线程的名字 * 6.yield():调用此方法的线程强制释放当前CPU的执行权 * 7.join():在A线程中调用B线程的join()方法.表示当A线程执行到此方法时,停止 * 执行A线程,直到B线程执行完毕,A线程再接着B.join()之后的代码执行 * 8.isAlive()判断此线程是否存活 * 9.sleep(long time)显示的让当前线程睡眠time毫秒 * 10.线程通信有关的: wait() notify() notifyAll()//在Object类中 * 设置线程的优先级MAX_PRIORITY=10;NORM_PRIORITY=5;MIN_PRIORITY=1 * 改变抢占CPU资源的概率 * setPriority(int newPriority) * getPriority() */ 例子: 三个售票窗口售卖100张票(一共100张) 继承Thread类的方式实现: 注意: 此程序存在隐患(线程安全问题) 点击显/隐内容 12345678910111213141516171819202122232425262728293031//继承Thread类的方式实现class Window extends Thread&#123; static int ticket = 100; public void run() &#123; while(true) &#123; if(ticket&gt;0) &#123;//开启注释放大错误// try &#123;// Thread.currentThread().sleep(10);//阻塞10ms// &#125; catch (InterruptedException e) &#123;// // TODO 自动生成的 catch 块// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + \"售票, 票号为:\"+ticket--); &#125; else break; &#125; &#125;&#125;public class TestWindow &#123; public static void main(String[] args) &#123; Window w1 = new Window(); Window w2 = new Window(); Window w3 = new Window(); w1.setName(\"窗口一:\"); w2.setName(\"窗口二:\"); w3.setName(\"窗口三:\"); w1.start(); w2.start(); w3.start(); &#125;&#125; 方式二:实现Runnable接口 创建一个实现Runnable接口的类 实现接口的抽象run()方法 创建一个实现Runnable接口实现类的对象 将此对象作为形参传给Thread类的构造器, 创建Thread类的对象, 此对象即为一个线程 调用start()启动线程 123456789101112131415161718192021222324252627//1.创建一个实现Runnable接口的类class SubThread implements Runnable&#123; //2.实现接口的抽象run()方法 public void run()&#123; //子线程执行的代码 for(int i = 1;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + \":\" + i); &#125; &#125; &#125;&#125;public class TestThread&#123; public static void main(String[] args)&#123; //3.创建一个实现Runnable接口实现类的对象 SubThread s = new SubThread(); //想要启动一个线程必须调用start()方法 //4.将此对象作为形参传给Thread类的构造器, 创建Thread类的对象, 此对象即为一个线程 Thread t1 = new Thread(s); Thread t2 = new Thread(s); //5.调用start()启动线程 t1.setName(\"线程1\"); t2.setName(\"线程2\"); t1.start();//启动线程: 执行Thread对象生成时构造器形参的run()方法. t2.start(); &#125;&#125; 两种方式的对比: 联系：class Thread implements Runnable, 两种方式实际上都与Runnable接口发生了关系 哪个比较好? 实现的方式(方式二)较好: ①解决了单继承的局限性 ②如果多个线程有共享数据的话, 建议使用实现方式, 同时, 共享数据所在的类可以作为Runnable接口的实现类. 实现Runnable接口的方式实现(上述售票例题): 注意: 此程序存在隐患(线程安全问题) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233//有共享数据的问题(一共100张票)class Window1 implements Runnable&#123; int ticket = 100; public void run()&#123; while(true) &#123; if(ticket&gt;0) &#123;//开启注释放大错误// try &#123;// Thread.currentThread().sleep(10);//阻塞10ms// &#125; catch (InterruptedException e) &#123;// // TODO 自动生成的 catch 块// e.printStackTrace();// &#125; System.out.println(Thread.currentThread().getName() + \"售票, 票号为:\"+ticket--); &#125; else break; &#125; &#125;&#125;public class TestThread&#123; public static void main(String[] args)&#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 三.Java的多线程1.多线程的优点 提高应用程序的响应 提高计算机系统的CPU利用率 改善程序接口 2.Java线程的分类 守护线程VS用户线程 若JVM中都是守护线程, 当前JVM将退出 3.线程的生命周期新建、就绪、运行、阻塞、死亡 四.线程同步上述售票的例子: 程序存在线程安全问题: 打印车票时, 会出现重票、错票 线程安全问题存在的原因? 由于一个线程在操作共享数据的过程中, 未执行完的情况下, 另外一个线程参与进来, 导致共享数据存在了安全问题. 如何解决该问题? 必须让一个线程操作共享数据完毕以后, 其他线程才有机会进入参与共享数据的操作. Java如何实现线程的安全: 线程的同步机制 方式一: 同步代码块:123synchronized(同步监视器)&#123; //操作共享数据的代码&#125; ①同步监视器: 俗称锁, 任何一个类的对象都可以才充当锁. 要想保证线程的安全, 必须要求所有的线程共用同一把锁!②共享数据: 多个线程需要共同操作的变量. 明确哪部分是操作共享数据的代码. ③使用实现Runnable接口的方式创建多线程的话, 同步代码块中的锁, 可以考虑是this. 如果使用继承Thread类的方式, 慎用this! 修改原来的售票代码: 点击显/隐内容 12345678910111213141516171819202122232425262728293031//有共享数据的问题(一共100张票)class Window1 implements Runnable&#123; int ticket = 100; Object obj = new Object(); public void run() &#123; while(true) &#123; synchronized (this) &#123;//同步锁可以由任何对象充当, 但是同步的线程要共用一把锁 //this表示当前对象, 本程序中为w对象, this可以改为obj //具体问题具体分析, 有时候不能用this ,用继承Thread方式实现的多线程不能用this if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName() + \"售票, 票号为:\"+ticket--); &#125; else break; &#125; &#125; &#125;&#125;public class TestThread&#123; public static void main(String[] args)&#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 方式二: 同步方法: 将需要共享的数据的操作放到一个方法里, 并给该方法添加 synchronized 修饰 同步方法也有锁, 即为当前对象 this 如果使用在继承的方式实现多线程的话, 慎用同步方法!因为它们的this锁不一样 点击显/隐内容 123456789101112131415//这个类是用实现Runnable接口实现的多线程class Window implements Runnable&#123; int ticket = 100; @Override public void run() &#123; while(true) &#123; this.show(); &#125; &#125; public synchronized void show() &#123; if(ticket&gt;0) &#123; System.out.println(Thread.currentThread().getName() + \"售票, 票号为:\"+ticket--); &#125; &#125;&#125; 懒汉式单例模式的线程安全 使用线程同步机制解决问题 对于一般的方法内, 使用同步代码块的方式, 可以考虑用this当锁 对于静态方法而言, 使用当前类本身充当锁 123456789101112131415//懒汉式class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance = null; public static Singleton getInstance()&#123; if(instance == null)&#123;//提高效率 synchronized(Singleton.class)&#123;//后面会说, Singleton.class对象 if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 线程同步的弊端: 由于同一时间只能有一个线程访问共享数据, 效率变低了 何时释放锁? 当前线程的同步方法、同步代码块执行结束时 当前线程的同步方法、同步代码块中出现了未处理的Error或Exception, 导致异常结束 当前线程的同步方法、同步代码块中执行了线程对象的wait()方法, 当前线程暂停并释放锁 线程的死锁:不同的线程分别占用对方需要的同步资源不放弃, 都在等待对方放弃自己需要的同步资源, 就形成了线程的死锁.死锁是我们在使用同步时, 需要避免的问题! 线程的通信涉及到三个方法 wait() notify() notifyAll() 在java.lang.Object类中 wait(): 令当前线程挂起, 放弃CPU、同步资源…… notify(): 唤醒正在排队等待同步资源的线程中优先级最高的线程 notifyAll(): 唤醒正在排队等待同步资源的所有线程 注意: 这三个方法只能在同步方法或同步代码块中使用, 否则会报异常 例, 用两个线程交替打印1-100: 点击显/隐内容 1234567891011121314151617181920212223242526272829303132class PrintNum implements Runnable&#123; int num = 1; @Override public void run() &#123; while(true) &#123; synchronized(this) &#123; notify(); if(num&lt;100) &#123; System.out.println(Thread.currentThread().getName() + \":\" + num); num++; &#125;else break; try &#123; wait(); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;public class TestCommunication &#123; public static void main(String[] args) &#123; PrintNum p = new PrintNum(); Thread t1 = new Thread(p); Thread t2 = new Thread(p); t1.setName(\"甲\"); t2.setName(\"乙\"); t1.start(); t2.start(); &#125;&#125; 经典例题: 生产者/消费者问题点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品， * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫 * 生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员 * 会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。 */class Producer implements Runnable &#123; Clerk clerk; Producer(Clerk clerk) &#123; this.clerk = clerk; &#125; public void run() &#123; System.out.println(\"生产者开始生产产品\"); while (true) &#123; try &#123; Thread.currentThread().sleep(100); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; clerk.addProduct(); &#125; &#125;&#125;class Consumer implements Runnable &#123; Clerk clerk; Consumer(Clerk clerk) &#123; this.clerk = clerk; &#125; public void run() &#123; System.out.println(\"消费者开始消费产品\"); while (true) &#123; try &#123; Thread.currentThread().sleep(100); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; clerk.subProduct(); &#125; &#125;&#125;class Clerk &#123; int product; public synchronized void addProduct() &#123; if (product &gt;= 20) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; else &#123; product++; notifyAll(); System.out.println(Thread.currentThread().getName() + \"生产了第\" + this.product + \"个产品\"); &#125; &#125; public synchronized void subProduct() &#123; if (product &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \"消费了第\" + this.product + \"个产品\"); product--; notifyAll(); &#125; else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); Consumer c1 = new Consumer(clerk); Thread t1 = new Thread(c1); Thread t2 = new Thread(p1); Thread t3 = new Thread(p1); t1.setName(\"消费者1\"); t2.setName(\"生产者1\"); t3.setName(\"生产者2\"); t2.start(); t1.start(); t3.start(); &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"面向对象总结","slug":"JavaSEOOP","date":"2019-03-20T13:04:35.000Z","updated":"2019-04-03T05:02:58.324Z","comments":true,"path":"JavaSEOOP.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSEOOP.html","excerpt":"面向对象的三条主线:1.类及类的成分2.面向对象的三大特性3.其他的关键字: this super import package abstract static final interface等","text":"面向对象的三条主线:1.类及类的成分2.面向对象的三大特性3.其他的关键字: this super import package abstract static final interface等 一.专注类的设计类从代码的角度: 并列关系! 从执行、设计的角度: 关联关系、继承关系、聚合关系 1.类的成分属性 方法 构造器 代码块 内部类 属性: ①变量的分类: 成员变量(属性 Field) vs 局部变量(方法的形参、方法内部、代码块内部)基本数据类型(8种, 不同的数据类型对应不同的默认初始化值) vs 引用数据类型(数组、类、接口默认初始化值为null) ②属性的声明格式: 修饰符 数据类型 变量名 = 初始化值; //java是强数据类型的语言 ③对属性的赋值的操作: A.默认初始化 B.显式的初始化 C.代码块的初始化 D.构造器的初始化 E.调用方法、属性进行赋值 方法: ①格式: 修饰符 (其它的关键字: static/final/abstract)返回值类型 方法名 (形参列表){//方法体 } ②方法的重载(overload) vs 方法的重写(override overwrite) ③方法的参数传递机制: 值传递 构造器: ①构造器的作用: A.创建类的对象 B.初始化对象的成员变量 ②构造器也是可以重载的. 代码块: 主要作用: 用来初始化类的成员变量 分类: 静态的代码块 vs 非静态的代码块 内部类: ①分类: 成员内部类(static的成员 vs 非static的成员) vs 局部内部类(方法内部声明的类) ②掌握: A.如何创建成员内部类的对象 B.如何区分调用外部类、内部类的变量(尤其是变量重名时) C.局部内部类的使用 2.类的初始化 如何创建类的对象. 如: Person p = new Person(); Date d = new Date(); 内存解析: 栈: 局部变量、对象的引用名、数组的引用名 堆: new 出来的“东西” 方法区: (字符串常量池) 静态域: 存放类中静态的变量 理解创建的对象在内存中加载的过程 二.面向对象的三大特性1.封装性 ① 通过私有化类的成员变量, 通过公共的getter和setter方法来调用和修改 ② 还可以对类的其他结构进行“封装” ③ 权限修饰符: public protected 缺省 private 2.继承性通过让一个类A继承另一个类B, 就可以获取类B中的结构(主要的: 属性、方法、构造器). 子类: 类A; 父类: 类B java中的类的继承性: 单继承的 3.多态性 ①体现: 方法的重载与重写; 子类对象的多态性 Person p = new Student(); ②子类对象多态性的使用: 虚拟方法调用. ③向上转型 向下转型 Student s = (Student)p; //建议在向下转型之前: if(p instanceof Student)避免出现ClassCastException的异常 三.其他关键字 this: 修饰属性、方法、构造器. 表示: 当前对象或当前正在创建的对象 super: 修饰属性、方法、构造器. 显式的调用父类的相应的结构, 尤其是子父类有重名的方法、属性 static: 修饰属性、方法、代码块、内部类. 随着类的加载而加载! final: 修饰类、属性、方法. 表示“最终的” abstract: 修饰类、方法 interface: 表示是一个接口, (接口是与类并列的一个结构). 类与接口之间同时“implements”发生关系. package import …… abstract不能修饰属性、构造器、不能与final static private共用.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"面向对象3.2","slug":"JavaSE5-2","date":"2019-03-20T09:11:26.000Z","updated":"2019-04-03T05:02:21.677Z","comments":true,"path":"JavaSE5-2.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE5-2.html","excerpt":"abstractinterface内部类","text":"abstractinterface内部类 一.abstractabstract: 抽象的, 可以用来修饰类、方法 abstract修饰类: 抽象类 不可被实例化 抽象类有构造器 (凡是类都有构造器) 抽象方法所在的类, 一定是抽象类. 抽象类中可以没有抽象方法. abstract修饰方法: 抽象方法 格式: 没有方法体和{}.如: public abstract void eat(); 抽象方法只保留方法的功能, 而具体的执行, 交给继承抽象类的子类, 由子类重写此抽象方法. 若子类继承抽象类, 并重写了所有的抽象方法, 则此类是一个”实体类”, 即可以实例化 若子类继承抽象类, 没有重写所有的抽象方法, 意味着此类中仍有抽象方法, 则此类必须声明为抽象的! abstract不能用来修饰属性、构造器、private、final、static A.模板方法设计模式功能的内部一部分实现是确定的, 一部分实现是不确定的, 可以将不确定的暴露出去让子类去实现它 点击显/隐内容 12345678910111213141516171819202122232425262728293031323334//模板方法设计模式public class TestTemplate &#123; public static void main(String[] args) &#123; new SubTemplate().spendTime(); &#125;&#125;abstract class Template &#123; //此部分功能不确定: 具体要执行什么代码 public abstract void code(); //此部分功能确定: 计算执行code()方法的时间 public void spendTime() &#123; long start = System.currentTimeMillis(); this.code(); long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start)); &#125;&#125;class SubTemplate extends Template &#123; public void code() &#123; boolean flag = false; for(int i = 2;i &lt;= 10000;i++)&#123; for(int j = 2;j &lt;= Math.sqrt(i);j++)&#123; if(i % j == 0)&#123; flag = true; break; &#125; &#125; if(!flag)&#123; System.out.println(i); &#125; flag = false; &#125; &#125;&#125; 二.interface接口(interface)是与类并行的一个概念 接口可以看做是一个特殊的抽象类, 是常量与抽象方法的一个集合, 不能包含变量、一般的方法. 常量默认有 public static final修饰, 方法默认有 public abstract修饰 接口是没有构造器的. 接口定义的就是一种功能. 此功能可以被类所实现(implements). 比如: class CC extends DD implements AA 实现接口的类, 必须要重写其中的所有的抽象方法, 方可实例化. 若没有重写所有的抽象方法, 则此类仍为一个抽象类 一个类可以实现多个接口.—-java 中的类的继承是单继承的 接口与接口之间也是继承的关系, 而且可以实现多继承 接口与具体的实现类之间也存在多态性 面向接口编程的思想: A.工厂方法的设计模式定义一个用户创建对象的接口, 让子类决定实例化哪一个类. 工厂方法使一个类的实例化延迟到其子类. 123456789101112131415161718192021222324252627282930313233343536373839404142//接口的应用: 工厂方法的设计模式public class TestFactoryMethod &#123; public static void main(String[] args) &#123; IWorkFactory i = new StudentWorkFactory(); i.getWork().doWork(); IWorkFactory i1 = new TeacherWorkFactory(); i1.getWork().doWork(); &#125;&#125;//工厂接口interface IWorkFactory&#123; Work getWork();&#125;//创建学生工作的工厂class StudentWorkFactory implements IWorkFactory&#123; @Override public Work getWork() &#123; return new StudentWork(); &#125;&#125;//创建老师工作的工厂class TeacherWorkFactory implements IWorkFactory&#123; @Override public Work getWork() &#123; return new TeacherWork(); &#125;&#125;interface Work&#123; void doWork();&#125;class StudentWork implements Work&#123; @Override public void doWork() &#123; System.out.println(\"学生写作业\"); &#125;&#125;class TeacherWork implements Work&#123; @Override public void doWork() &#123; System.out.println(\"老师批改作业\"); &#125;&#125; B.代理模式1234567891011121314151617181920212223242526272829303132//接口的应用: 代理模式(静态代理), 后面会有动态代理public class TestProxy &#123; public static void main(String[] args) &#123; Object obj = new ProxyObject(); obj.action(); &#125;&#125;interface Object&#123; void action();&#125;//代理类class ProxyObject implements Object&#123; Object obj; public ProxyObject()&#123; System.out.println(\"代理类创建成功\"); obj = new ObjctImpl(); &#125; public void action()&#123; System.out.println(\"代理类开始执行\"); obj.action(); System.out.println(\"代理类执行结束\"); &#125;&#125;//被代理类class ObjctImpl implements Object&#123; @Override public void action() &#123; System.out.println(\"=====被代理类开始执行======\"); System.out.println(\"=====具体的操作======\"); System.out.println(\"=====被代理类执行完毕======\"); &#125;&#125; 了解就好, 你可以将这两种设计模式当成算法记下来 三.内部类类的第5个成员: 内部类(inner class) 例: Thread类内的State枚举类 相当于说, 我们可以在类的内部再定义类. 外面的类: 外部类. 定义在类内的类: 内部类 内部类的分类: 成员内部类(声明在类内部且方法外的) vs 局部内部类(声明在类的方法里) 成员内部类: 是外部类的一个成员: ①可以有修饰符(4个) ②static final ③可以调用外部类的属性、方法 具体类的特点: ①abstract ②还可以在其内部定义属性、方法、构造器 局部内部类(知道有就好) 关于内部类, 掌握三点: ①如何创建成员内部类的对象(如: 创建Bird类和Dog类的对象) ②如何区分调用外部类、内部类的变量(尤其是变量重名时) ③局部内部类的使用 A.成员内部类:1234567891011121314151617181920212223242526272829303132333435363738394041public class TestInnerClass &#123; public static void main(String[] args) &#123; //创建静态内部类的对象: 可以直接通过外部类调用静态内部类的构造器 Person.Dog d = new Person.Dog();//区别Person.new Dog(); //Person.Bird b = new Person.Bird(); //创建非静态的内部类的对象: 必须先创建外部类的对象, 通过外部类的对象调用内部类的构造器 Person p = new Person(); Person.Bird b = p.new Bird(); b.info(); b.setName(\"杜鹃\"); &#125;&#125;class Person&#123; String name = \"小明\"; int age; //成员内部类(非static的) class Bird&#123; String name = \"黄鹂\"; int id; public Bird()&#123; &#125; public void setName(String name)&#123;//假设传过来的参数为\"杜鹃\" System.out.println(name);//杜鹃 System.out.println(this.name);//黄鹂 System.out.println(Person.this.name);//小明 &#125; public void info()&#123; show(); &#125; &#125; //成员内部类(静态内部类) static class Dog&#123; &#125; public void show()&#123; System.out.println(\"show()\"); &#125; public void method1()&#123; class A&#123; &#125; &#125;&#125; B.局部内部类:12345678910111213141516171819202122232425262728293031class OuterClass&#123; //局部内部类 //如下的使用方式较少 public void method1()&#123; class InnnerClass&#123; &#125; &#125; //常常使用一个方法, 使其返回值为某个类或接口的对象. 而这个类或接口在方法内部创建 //使用方式一 public Comparable getComparable()&#123; //1.创建一个实现Comparable接口的类:局部内部类 class MyComparable implements Comparable&#123; @Override public int compareTo(java.lang.Object o) &#123; return 0; &#125; &#125; //2.返回一个实现类的对象 return new MyComparable(); &#125; //使用方式二 public Comparable getComparable1()&#123; //返回一个实现Comparable接口的匿名内部类的对象 return new Comparable()&#123; @Override public int compareTo(java.lang.Object o) &#123; return 0; &#125; &#125;; &#125;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"面向对象3.1","slug":"JavaSE5-1","date":"2019-03-20T07:03:18.000Z","updated":"2019-04-03T04:59:06.752Z","comments":true,"path":"JavaSE5-1.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE5-1.html","excerpt":"static关键字main()方法代码块final","text":"static关键字main()方法代码块final 一.staticstatic: 静态的, 可以用来修饰属性、方法、*代码块(或初始化块)、*内部类 A.static修饰属性(类变量): 由类创建的所有的对象，都共用这一个属性 当其中一个对象对此属性进行修改, 会导致其他对象对此属性调用时也会更改. vs 实例变量(非static修饰的属性, 各个对象各自拥有一套副本) 类变量随着类的加载而加载的, 而且独一份 静态的变量可以直接通过“类.类变量”的形式来调用 类变量的加载是要早于对象. 所以当有对象以后, 可以“对象.类变量”使用. 但是”类.实例变量”是不行的. 类变量存在于内存的静态域中. B.static修饰方法(类方法): 随着类的加载而加载, 在内存中也是独一份 可以直接通过“类.类方法”的方式调用 方法内部可以调用静态的属性或静态的方法, 而不能调用非静态的属性或方法. 反之, 非静态的方法是可以调用静态的属性或静态的方法. 静态的方法内是不可以有this或super关键字的! 注意: 静态的结构(static的属性、方法、代码块、内部类)的生命周期要早于非静态的结构，同时被回收也要晚于非静态的结构 示例, 静态属性及内存状态: 点击显/隐内容 12345678910111213141516171819202122public Test&#123; public static void main(String []args)&#123; SportsMan s1 = new SportsMan(\"金龙\",23); SportsMan s2 = new SportsMan(\"银龙\",20); s1.setName(\"花龙\"); s1.nation = \"China\"; &#125;&#125;class SportsMan&#123; private String name; private int age; public static String nation; SportsMan()&#123; &#125; SportsMan(String name,int age)&#123; this.name = name; this.age = age; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; C.单例模式23种设计模式 单例模式(Singleton): 即类只能创建一个对象, Runtime类就是一个单例模式的应用 解决的问题: 如何只让设计的类只能创建一个对象 如何实现: 饿汉式 &amp; 懒汉式 私有化构造器 在类内部创建类的对象, 同时设置为private的, 通过公共的方法来调用, 体现封装性 一个public static的方法, 获得该(单例)对象 要求该对象也为static的 1234567891011121314151617181920212223242526272829303132333435363738394041//饿汉式1class Bank&#123; //1.私有化构造器 private Bank()&#123;&#125; //2.创建类的对象，同时设置为private的，通过公共的来调用，体现封装性 //4.要求此对象也为static的 private static Bank instance = new Bank(); //3.此公共的方法，必须为static public static Bank getInstance()&#123; return instance; &#125;&#125;//饿汉式2class Bank&#123; //1.私有化构造器 private Bank()&#123;&#125; //2.创建类的对象，同时设置为private的，通过公共的来调用，体现封装性 //4.要求此对象也为static的 private static Bank instance = null; static&#123; instance = new Bank(); &#125; //3.此公共的方法，必须为static public static Bank getInstance()&#123; return instance; &#125;&#125;//懒汉式class Bank&#123; private Bank()&#123;&#125; private static Bank instance = null; public static Bank getInstance()&#123; if(instance == null)&#123;//可能存在线程安全问题的! instance = new Bank(); &#125; return instance; &#125;&#125; 二.main()123public static void main(String[] args) throws Exception&#123; //方法体 &#125; main()是一个方法, 是主方法, 为程序的入口 权限修饰符: public protected 缺省 private —面向对象的封装性 对于方法来讲: static final abstract 可修饰 方法的返回值: void / 具体的返回值类型(基本的数据类型 &amp; 引用数据类型), 方法内部一定要有return 方法名: 命名的规则: xxxYyyZzz. 给方法命名时, 要见名知意 形参列表: 同一个方法名不同的形参列表的诸多个方法间构成重载. 形参 &amp; 实参—方法的参数传递机制: 值传递 抛出异常列表 方法体: 方法定义的是一种功能, 具体的实现由方法体操作. 三.代码块 代码块: 是类的第4个成员, 由一对大括号括起来 作用: 用来初始化类的属性 分类: 只能用static来修饰. A.静态代码块 里面可以有输出语句 随着类的加载而加载，而且只被加载一次 多个静态代码块之间按照顺序结构执行 静态代码块的执行要早于非静态代码块的执行. 静态的代码块中只能执行静态的结构(类属性, 类方法) B.非静态代码块 可以对类的属性(静态的 &amp; 非静态的)进行初始化操作, 同时也可以调用本类声明的方法(静态的 &amp; 非静态的) 里面可以有输出语句 一个类中可以有多个非静态的代码块, 多个代码块之间按照顺序结构执行 每创建一个类的对象, 非静态代码块就加载一次. 非静态代码块的执行要早于构造器 关于属性赋值的操作: ①默认的初始化②显式的初始化或代码块初始化(此处两个结构按照顺序执行)③构造器中;—————————以上是对象的属性初始化的过程—————————————④通过方法对对象的相应属性进行修改 四.finalfinal:最终的, 可以用来修饰类、属性、方法 final修饰类: 这个类就不能被继承. 如: String类、StringBuffer类、System类 final修饰方法: 不能被重写. 如: Object类的getClass() final修饰属性: 此属性就是一个常量, 一旦初始化后, 不可再被赋值. 习惯上, 常量用大写字符表示.此常量在哪里赋值: ①此常量不能使用默认初始化 ②可以显式的赋值、代码块、构造器.变量用static final修饰时: 全局常量. 比如: Math 类的PI","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"多态性","slug":"JavaSE4-2","date":"2019-03-20T06:26:18.000Z","updated":"2019-04-03T04:56:35.455Z","comments":true,"path":"JavaSE4-2.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE4-2.html","excerpt":"面向对象的特征三: 多态性Object类包装类","text":"面向对象的特征三: 多态性Object类包装类 一.多态性 多态性的表现: ①方法的重载与重写 ②子类对象的多态性 使用的前提: ①要有继承关系 ②要有方法的重写 格式: 点击显/隐内容 123456789101112131415161718class Person&#123; public void eat()&#123; System.out.println(\"人吃饭\"); &#125; public void walk()&#123; System.out.println(\"人走路\"); &#125;&#125;class Man extends Person&#123; public void entertainment()&#123; System.out.println(\"男人娱乐\"); &#125;&#125;class Woman extends Person&#123; public void shopping()&#123; System.out.println(\"女人购物\"); &#125;&#125; 12345Person p = new Man();//向上转型//虚拟方法调用：通过父类的引用指向子类的对象实体，当调用方法时，实际执行的是子类重写父类的方法p1.eat();p1.walk();//p1.entertainment();//不能调用, Man类里没有这个函数 编译时, 认为p是Person类型的, 故只能执行Person里才有的结构, 即Man里特有的结构不能够调用 子类对象的多态性, 并不使用于属性. 关于向下转型:①向下转型,使用强转符: ()②为了保证不报ClassCastException, 最好在向下转型前, 进行判断: instanceof 12345678910// 若a是A类的实例, 那么a也一定是A类的父类的实例。if (p1 instanceof Woman) &#123; System.out.println(\"hello!\"); Woman w1 = (Woman) p1; w1.shopping();&#125;if (p1 instanceof Man) &#123; Man m1 = (Man) p1; m1.entertainment();&#125; 二.Object类 java.lang.Object 类, 是所有类的根父类! Object类仅有一个空参的构造器 public Object(){ } 关于方法: ① equals(Object obj)123public boolean equals(Object obj) &#123; return (this == obj);&#125; A.基本数据类型: 根据基本数据类型的值判断是否相等. 相等返回true, 反之返回false&emsp;&emsp;注意: 两端数据类型可以不同, 在不同的情况下, 也可以返回true.B.引用数据类型: 比较引用类型变量的地址值是否相等.&emsp;&emsp;而我们希望比较的两个对象的属性值都相同的情况下返回true的话, 要重写Object类的equals(Object obj)方法&emsp;&emsp;像String类 File类 Date类…重写了Object类的equals()方法, 比较是两个对象的”实体内容”是否完全相同 ② toString() 当我们输出一个对象的引用时, 会默认调用toString()方法. 当我们没有重写Object类的toString()方法时, 打印的就是对象所在的类, 以及对象实体在堆空间的位置 而我们一般需要重写Object类的toString()方法, 将此对象的各个属性值返回. 像String类、Date、File类、包装类都重写了toString()方法. 1234//Object类的toString()public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode());&#125; String的内存结构: 三.包装类Wrapper Class, 包装类均位于java.lang包下 基本数据类型由于不是类, 不能够使用Java类库里提供的大量的方法. 所以在设计上, 我们让每一个基本数据类型都对应一个类, 同时数据存储的范围还不变. 此时, 相当于基本数据类型就具有了类的特点. 这些类即为包装(wrapper 或封装类) boolean ==&gt; Boolean byte&emsp;&emsp;==&gt; Byte short &emsp; ==&gt; Short int &emsp; &emsp; ==&gt; Integer long&emsp;&emsp;==&gt; Long char&emsp;&emsp;==&gt; Character float&emsp;&emsp;==&gt; Float double&emsp;==&gt; Double 需要掌握的: 基本数据类型、包装类、String类之间的转换! 简易理解: 基本数据类型与对应的包装类有自动装箱、自动拆箱 (JDK5.0之后) 1234//如下:int i = 10;Integer i1 = i;//自动装箱int j = i1;//自动拆箱 基本数据类型、包装类—-&gt;String类: 调用String类的重载的valueOf(Xxx xx); String类—-&gt;基本数据类型、包装类: 调用相应的包装的parseXxx(String str); 123//注意:String str = \"123\";int i = (int)str;//是错误的转换法. 特别的: Boolean的默认初始化值为null, 而boolean的默认初始化值为false; 12Boolean b = new Boolean(\"true\");//除了这样传参之外, 其他传参均为false//不会报java.lang.NumberFormatException","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"继承性","slug":"JavaSE4-1","date":"2019-03-19T12:38:13.000Z","updated":"2019-04-03T04:53:41.037Z","comments":true,"path":"JavaSE4-1.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE4-1.html","excerpt":"面向对象特征二:继承性方法的重写super关键字子类对象的实例化过程","text":"面向对象特征二:继承性方法的重写super关键字子类对象的实例化过程 一.继承性1.为什么要有继承性:&emsp;&emsp;有一些东西拥有某些公共的特性, 将他们相同的部分抽取出来放在一起, 方便代码的复用与修改2.通过”class A extends B“类实现类的继承:&emsp;&emsp;子类: A; 父类(或基类SuperClass): B3.子类继承父类以后, 父类中声明的属性、方法, 子类就可以获取到.&emsp;&emsp;明确: 当父类中有私有的属性或方法时, 子类同样可以获取得到, 只是由于封装性的设计, 使得子类不可以直接调用罢了.&emsp;&emsp;子类除了通过继承, 获取父类的结构之外, 还可以定义自己的特有的成分.extends:子类是对父类功能的“扩展”, 明确子类不是父类的子集.4.Java中类的继承性只支持单继承: 一个类只能继承一个父类. 反之, 一个父类可以有多个子类.5.子父类是相对的概念. 二.orverwrite or override方法的重载与重写的区别?重载: “两同一不同”: 同一个类, 同一个方法名, 不同的参数列表. 注: 方法的重载与方法的返回值无关!构造器也是可以重载的重写: (前提: 在继承的基础之上, 子类在获取了父类的结构以后, 可以对父类中同名的方法进行“重构”) 方法的返回值, 方法名, 形参列表形同; 权限修饰符不小于父类的同名方法; 子类方法的异常类型不大于父类的; 两个方法要同为static或同为非static. 三.super1.super: 相较于关键字this, 可以修饰属性、方法、构造器2.super修饰属性、方法: 在子类的方法、构造器中, 通过“super.属性”或者”super.方法”的形式, 显式的调用父类的指定属性或方法. 尤其是, 当子类与父类有同名的属性、或方法时, 调用父类中的结构的话, 一定要用“super.”3.通过“super(形参列表)”, 显式的在子类的构造器中, 调用父类指定的构造器!&emsp;&emsp;任何一个类(除Object类)的构造器的首行, 要么显式的调用本类中重载的其它的构造器“this(形参列表)”或显式的调用父类中指定的构造器“super(形参列表)”, 要么默认的调用父类空参的构造器”super()” “super(形参列表)”或”this(形参列表)”只能出现一个&emsp;&emsp;建议在设计类时, 提供一个空参的构造器! 四.子类对象的实例化先构建(调用父类的构造器构建)父类的内容, 再构建子类的内容 为了直观的理解, 可以运行一下代码, 看输出的结果: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//子类对象实例化的全过程public class TestDog &#123; public static void main(String[] args) &#123; Dog d = new Dog(); d.setAge(10); d.setName(\"小明\"); d.setHostName(\"花花\"); System.out.println(\"name:\" + d.getName() + \" age:\" + d.getAge() + \" hostName:\" + d.getHostName()); System.out.println(d.toString()); &#125;&#125;// 生物class Creator &#123; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Creator() &#123; super(); System.out.println(\"this is Creator's constructor\"); &#125;&#125;// 动物类class Animal extends Creator &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Animal() &#123; super(); System.out.println(\"this is Animal's constructor\"); &#125;&#125;// 狗class Dog extends Animal &#123; private String hostName; public String getHostName() &#123; return hostName; &#125; public void setHostName(String hostName) &#123; this.hostName = hostName; &#125; public Dog() &#123; super(); System.out.println(\"this is Dog's constructor\"); &#125;&#125; 输出结果为: 12345this is Creator's constructorthis is Animal's constructorthis is Dog's constructorname:小明 age:10 hostName:花花Dog类的对象dd在堆空间内的信息","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"封装性","slug":"JavaSE3-3","date":"2019-03-19T08:08:05.000Z","updated":"2019-04-03T04:52:10.269Z","comments":true,"path":"JavaSE3-3.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE3-3.html","excerpt":"面向对象之封装性构造器this关键字package与import","text":"面向对象之封装性构造器this关键字package与import 一.封装性面向对象的特征一: 封装与隐藏 问题: 当创建了类的对象以后, 如果直接通过”对象.属性”的方式对相应的对象属性赋值的话, 可能会出现不满足实际情况的意外, 我们考虑不让对象来直接作用属性, 而是通过”对象.方法”的形式, 来控制对象对属性的访问. 实际情况中, 对属性的要求就可以通过方法来体现. 封装性的思想: ①将类的属性私有化; ②提供公共的方法(setter&amp;getter)来实现调用. A.四种权限修饰符1.权限从大到小为：public protected 缺省 private2.四种权限都可以用来修饰属性、方法、构造器3.修饰类的话：public 缺省(default)类只能被同一个包中的类访问 二.构造器类的第三个成员: 构造器(constructor 构造方法) A.构造器的作用①创建对象 ②给创建的对象的属性赋值 B.构造器的特征①与类名一致②没有返回值类型③无return与语句 ④不能被static|final|abstract|native本地的|synchronized同步的 1.设计类时, 若不显式声明类的构造器的话, 程序会默认提供一个空参的构造器.. 2.一旦显式的定义类的构造器, 那么默认的构造器就不再提供. 3.如何声明类的构造器. 格式: 权限修饰符 类名(形参){ } 4.类的多个构造器之间构成重载 类对象的属性赋值的先后顺序: ①属性的默认初始化 ②属性的显式初始化 ③通过构造器给属性初始化 ④通过”对象.方法”的方式给属性赋值 三.thisthis: 1.使用在类中, 可以用来修饰属性、方法、构造器2.表示当前对象或者是当前正在创建的对象3.当形参与成员变量重名时, 如果在方法内部需要使用成员变量, 必须添加this来表明该变量时类成员4.在任意方法内, 如果使用当前类的成员变量或成员方法可以在其前面添加this, 增强程序的阅读性5.在构造器中使用“this(形参列表)”显式的调用本类中重载的其它的构造器&emsp;&emsp;①要求“this(形参列表)”要声明在构造器的首行!&emsp;&emsp;②类中若存在n个构造器, 那么最多有n-1构造器中使用了this.6.静态方法中不能使用this和super关键字 例子: 点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TestPerson&#123; public static void main(String[] args) &#123; Person p1 = new Person(); System.out.println(p1.getName() + \":\" + p1.getAge()); Person p2 = new Person(\"BB\",23); int temp = p2.compare(p1); System.out.println(temp); &#125;&#125;class Person&#123; private String name; private int age; public Person()&#123; this.name = \"AA\"; this.age = 1; &#125; public Person(String name)&#123; this(); this.name = name; &#125; public Person(String name,int age)&#123; this(name); this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void eat()&#123; System.out.println(\"eating\"); &#125; public void sleep()&#123; System.out.println(\"sleeping\"); this.eat(); &#125; //比较当前对象与形参的对象的age谁大。 public int compare(Person p)&#123; if(this.age &gt; p.age) return 1; else if(this.age &lt; p.age) return -1; else return 0; &#125;&#125; 四.package与importpackage: 声明源文件(即当前文件)所在的包(即文件夹), 必须写在程序的第一行. 每“.”一次, 表示一层文件目录; 包名都要小写. import: 1)显式导入指定包下的类或接口2)写在包的声明和源文件之间3)如果需要引入多个类或接口, 那么并列写出4)如果导入的类是java.lang包下的, 如: System String Math等, 就不需要显式的声明.5)理解.*的概念.比如java.util.*;6)如何处理同名类的导入. 如: 在util包和sql包下同时存在Date类.7)import static 表示导入指定类的static的属性或方法8)导入java.lang.*只能导入lang包下的所有类或接口, 不能导入lang的子包下的类或接口","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"面向对象1.2","slug":"JavaSE3-2","date":"2019-03-19T03:10:59.000Z","updated":"2019-04-03T04:50:27.611Z","comments":true,"path":"JavaSE3-2.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE3-2.html","excerpt":"方法的重载可变个数的形参的方法Java的值传递机制","text":"方法的重载可变个数的形参的方法Java的值传递机制 一.overload(重载)1.重载要求: 同一个类中 方法名必须相同 方法的参数列表不同(①参数的个数不同②参数类型不同)注意: 方法的重载与方法的返回值类型没有关系! 123456789101112131415161718192021222324//如下的四个方法构成重载//定义两个int型变量的和public int getSum(int i,int j)&#123; return i + j;&#125;//定义三个int型变量的和public int getSum(int i,int j,int k)&#123; return i + j + k;&#125;//定义两个double型数据的和public double getSum(double d1,double d2)&#123; return d1 + d2;&#125;//定义三个double型数组的和public void getSum(double d1,double d2,double d3)&#123; System.out.println(d1 + d2 + d3);&#125;//如下两个方法不能与如上的几个方法构成重载//public int getSum1(int i,int j,int k)&#123;//方法名必须相同// return i + j + k;//&#125;//public void getSum(int i,int j,int k)&#123;//与方法的返回值类型// System.out.println(i + j + k);//&#125; 二.可变个数的形参的方法可变个数的形参的方法(JDK5.0之后的特性): 1.格式: 对于方法的形参: 数据类型 … 形参名 2.可变个数的形参的方法与同名的方法之间构成重载 3.可变个数的形参在调用时, 个数从0开始, 到无穷多个都可以 4.使用可变多个形参的方法与方法的形参使用数组是一致的 5.若方法中存在可变个数的形参, 那么一定要声明在方法形参的最后 6.在一个方法中, 最多声明一个可变个数的形参 点击显/隐内容 1234567891011121314151617181920212223242526//如下四个方法构成重载//在类中一旦定义了重载的可变个数的形参的方法以后, 下面的前两个方法可以省略 public void sayHello()&#123; System.out.println(\"hello world!\"); &#125; public void sayHello(String str1)&#123; System.out.println(\"hello \" + str1); &#125; //可变个数的形参的方法 public void sayHello(String ... args)&#123; for(int i = 0;i &lt; args.length;i++)&#123; System.out.println(args[i] + \"$\"); &#125; &#125; public void sayHello(int i,String ... args)&#123; //public void sayHello(String ... args,int i)&#123;//这样不对 System.out.println(i); for(int j = 0;j &lt; args.length;j++)&#123; System.out.println(args[j] + \"$\"); &#125; &#125; public void sayHello1(String[] args)&#123; for(int i = 0;i &lt; args.length;i++)&#123; System.out.println(args[i]); &#125; &#125; 三.Java的值传递机制1.方法的参数传递 形参: 方法声明时, 方法小括号内的参数;实参: 调用方法时, 实际传入的参数的值 规则: Java中的参数传递机制: 值传递机制 ①形参是基本数据类型的: 将实参的值传递给形参的基本数据类型的变量②形参是引用数据类型的: 将实参的引用类型变量的值(对应的堆空间的对象实体的首地址值)传递给形参的引用类型变量. 12345678910111213141516171819202122//例1:class Test1&#123; public static void main(String[] args) &#123; Test1 tt = new Test1(); int i = 10; int j = 5; System.out.println(\"i:\" + i + \" j:\" + j);//i : 10 j : 5/* //直接交换变量i与j的值 int temp = i; i = j; j = temp;*/ tt.swap(i, j);//通过方法交换, 将i的值传递给m，j的值传递给n, 实际上i与j的值根本没有交换 System.out.println(\"i:\" + i + \" j:\" + j);//i : 10 j : 5 &#125; //定义一个方法，交换两个变量的值 public void swap(int m,int n)&#123; int temp = m; m = n; n = temp; System.out.println(\"m:\" + m + \" n:\" + n); &#125;&#125; 若直接用注释部分的代码交换i与j可以交换, 使用swap方法以后: 实际上i与j本身的值根本没有交换 12345678910111213141516171819202122//例2:public class Test1 &#123; public static void main(String[] args) &#123; Test1 tt = new Test1(); DataSwap ds = new DataSwap(); System.out.println(\"ds.i:\" + ds.i + \" ds.j:\" + ds.j); tt.swap(ds); System.out.println(ds); System.out.println(\"ds.i:\" + ds.i + \" ds.j:\" + ds.j); &#125; //交换元素的值 public void swap(DataSwap d)&#123; int temp = d.i; d.i = d.j; d.j = temp; System.out.println(d);//打印引用变量d的值 &#125;&#125;class DataSwap&#123; int i = 10; int j = 5;&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"面向对象1.1","slug":"JavaSE3-1","date":"2019-03-19T02:07:23.000Z","updated":"2019-04-03T04:48:35.963Z","comments":true,"path":"JavaSE3-1.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE3-1.html","excerpt":"一.面向对象的初步认识","text":"一.面向对象的初步认识 1.(了解)面向对象vs面向过程例:实现人把大象装进冰箱 面向对象: 1234567891011121314public class 人&#123;//可以这么理解 open()&#123;//打开冰箱 &#125; put()&#123;//将大象放进冰箱 &#125; close()&#123;//关闭冰箱 &#125; main()&#123; 人 = new 人(); 人.open(); 人.put(); 人.close(); &#125;&#125; 面向过程:①人打开冰箱;②将大象放进冰箱;③关闭冰箱 2.面向对象的编程关注于类的设计!1）一个项目或工程, 不管多庞大, 一定是有一个一个类构成的.2）类是抽象的, 好比是制造汽车的图纸.而具体的一辆一辆的车, 是根据图纸制造的, 实际上就是类的实例化 3.完成一个项目(或功能)的思路1）所要完成的功能对应的类的对象是否存在.2）若存在, 则通过对象直接调用对应的类中的属性或方法即可.3）若不存在, 需要创建类的对象.甚至说, 类都不存在, 就需要设计类. 4.面向对象编程的三条主线:1）类及类的构成成分:属性 方法 构造器 代码块 内部类2）面向对象编程的特征:封装性 继承性 多态性(抽象性)3）其它的关键字:this super package import static final abstract interface … 二.类及对象1.关于类的设计 2.类的组成成分: 1)属性(成员变量, Field) 2)方法(成员方法, 函数, Method) 2.1属性:成员变量 vs 局部变量相同点: 1.遵循变量声明的格式: 数据类型 变量名 = 初始化值 2.都有作用域 不同点: 1.声明的位置的不同: 成员变量: 声明在类里, 方法外; 局部变量: 声明在方法内, 方法的形参部分, 代码块内 &emsp;&emsp;&emsp;&emsp;2.成员变量的修饰符有四个:public private protected 缺省, 局部变量没有修饰符, 与所在的方法修饰符相同 &emsp;&emsp;&emsp;&emsp;3.初始化值: 一定会有初始化值, 成员变量:如果在声明的时候, 不显式的赋值, 那么不同数据类型会有不同的默认初始化值.局部变量: 一定要显式的赋值.(局部变量没有默认初始化值) byte short int long ==&gt;0 float double ==&gt;0.0 char ==&gt;空格 boolean ==&gt;false 引用类型变量==&gt;null &emsp;&emsp;&emsp;&emsp;4.二者在内存中存放的位置不同:成员变量存在于堆空间中; 局部变量: 栈空间中 总结: 关于变量的分类: 1)按照数据类型的不同: 基本数据类型(8种)&amp;引用数据类型 2)按照声明的位置的不同: 成员变量 &amp; 局部变量 2.2 方法: 提供某种功能的实现1)实例: 123public void eat()&#123;//方法体&#125;public String getName()&#123;&#125;public void setName(String n)&#123;&#125; 格式: 权限修饰符 返回值类型(void:无返回值/具体的返回值) 方法名(形参){} 2)关于返回值类型: void: 表明此方法不需要返回值 有返回值的方法: 在方法的最后一定有return + 返回值类型对应的变量 记忆: void 与return不可以同时出现一个方法内. 像一对“冤家”. 3)方法内可以调用本类的其他方法或属性, 但是不能在方法内再定义方法! 3.面向对象编程的思想的落地法则一:1)设计并创建类及类的成分2)实例化类的对象3)通过“对象.属性”或”对象.方法”的形式完成某项功能 4.类的初始化的内存解析 4.1 内存划分的结构: 栈(stack):局部变量、对象的引用名、数组的引用名 堆(heap):new 出来的“东西”(如: 对象的实体, 数组的实体), 含成员变量 方法区: 含字符串常量 静态域: 声明为static的变量 4.2 理解的基础上, 学会基本的创建的类的对象在内存中的运行.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"Java数组","slug":"JavaSE2-3","date":"2019-03-18T12:03:27.000Z","updated":"2019-04-03T04:45:22.533Z","comments":true,"path":"JavaSE2-3.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE2-3.html","excerpt":"Java数组","text":"Java数组 一.一维数组数组: 相同数据类型的数据的组合. 1234567891011121314151617181920212223//如: 多个intint score1 = 72;int score2 = 90;int score3 = 59;//使用数组存储int[] scores1 = new int[]&#123;72,90,59&#125;;//静态初始化:声明并初始化数组与给数组相应的元素赋值操作同时进行int scores2[] = new int[3];//动态初始化:声明并初始化数组与数组相应的元素赋值操作分开进行scores2[0] = 72;scores2[1] = 90;scores2[2] = 59;int[] arr = &#123;72,90,59&#125;;//这样可以//声明数组的错误写法:/*String[] names = new String[5]&#123;\"AA\",\"BB\",\"CC\"&#125;;//这样用时不能指定大小int i[10];int i = new int[];//i是int型int[] arr;arr = &#123;10,11,12&#125;;//两句分开不行, 合并为一句可以*/System.out.println(scores2.length);//求数组长度for(int i = 0;i &lt; scores1.length;i++)&#123;//遍历数组 System.out.println(scores1[i]);&#125; 注意1.不管是动态还是静态初始化数组, 一定在创建的时候, 就指明了数组的长度&emsp;&emsp;2.如何引用数组元素: 通过数组的下角标的方式. 下角标从0开始, 到n-1结束.其中n为数组的长度 &emsp;&emsp;3.关于数组元素的默认初始化值 byte short int long 而言:0 float double 而言:0.0 char而言:空格 boolean而言:false 引用类型变量而言:null 4.数组的内存结构内存结构图: 在JAVA中, 凡是new出来的东西, 都会被默认初始化并赋值 对于数组来讲: 字符串: 面向对象之后再看 二.二维数组123456789101112131415161718192021222324//1.声明并初始化//一维:类型后一个[]int[] i = new int[12];i[0] = 12;int[] j = new int[]&#123;12,3&#125;;//二维:类型后两个[]String[][] str = new String[4][3];//4行3列String[][] str1 = new String[4][];//4行, 每行的列可能不一样str1[0] = new String[3];//...str1[3] = new String[5];int[][] arr = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6&#125;&#125;;//2.如何引用二维数组的元素arr[1][0] = 12;//3.二维数组的长度:arr.length;//3arr[1].length;//2//4.遍历二维数组for(int i = 0;i &lt; arr.length;i++)&#123; for(int j = 0;j &lt; arr[i].length;j++)&#123; System.out.print(arr[i][j] + \"\\t\"); &#125; System.out.println(); &#125; 5.二维数组的结构: 三.数组中常见的异常123456789101112131415161718192021//1.数组下标越界的异常:java.lang.ArrayIndexOutOfBoundsExceptionint[] i = new int[10];//i[0] = 90;//i[10] = 99;//最大i[9]//for(int m = 0;m &lt;= i.length;m++)&#123;// System.out.println(i[m]);//最大i[i.length-1]//&#125;//2.空指针的异常:NullPointerException//第一种://boolean[] b = new boolean[3];//b = null;//System.out.println(b[0]);//b已经为空//第二种://String[] str = new String[4];//System.out.println(str[3].toString());//没有初始化str[3]//第三种:int[][] j = new int[3][];//j[2][0] = 12;//j的第二维还未初始化 四.数组中常用的算法求数组元素的最大值&amp;最小值&amp;和&amp;平均数数组的复制和反转情况1: 浅复制, 两个数组的引用指向同一片内存空间, 改变一个的内容另一个也会改变 12int[] arr1 = new int[]&#123;10,11,12&#125;;int[] arr2 = arr1; 情况2: 深复制, 将一片内存里的内容, 复制到另一片内存里(如何实现复制) 12345int[] arr1 = new int[]&#123;10,11,12&#125;;int[] arr2 = new int[arr1.length];for(int i = 0;i &lt; arr1.length;i ++)&#123; arr2[i] = arr1[i];&#125; 数组的反转：数组元素的反转 123456789101112//①for(int i = 0;i &lt; arr.length/2;i++)&#123; int temp = arr[i]; arr[i] = arr[arr.length-1 - i]; arr[arr.length - 1 - i] = temp;&#125;//②for (int x = 0, y = arr.length - 1; x &lt; y; x++, y--) &#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp;&#125; 拓展:String str = “abcdefg”; 数组的排序 插入排序: 直接插入排序、折半插入排序、Shell排序 交换排序: 冒泡排序、快速排序(或分区交换排序) 选择排序: 简单选择排序、堆排序 归并排序 基数排序 使用冒泡排序使数组元素从小到大排列 123456789for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125; 使用直接选择排序使数组元素从小到大排列 1234567891011121314for(int i = 0; i &lt; arr.length - 1; i++)&#123; int t = i;//默认i处是最小的 for(int j = i;j &lt; arr.length;j++)&#123; //一旦在i后发现存在比其小的元素，就记录那个元素的下角标 if(arr[t] &gt; arr[j])&#123; t = j; &#125; &#125; if(t != i)&#123; int temp = arr[t]; arr[t] = arr[i]; arr[i] = temp; &#125;&#125; 还可以调用: Arrays工具类: Arrays.sort(arr);","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"Java基本语法2","slug":"JavaSE2-2","date":"2019-03-18T10:59:37.000Z","updated":"2019-04-03T04:42:13.695Z","comments":true,"path":"JavaSE2-2.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE2-2.html","excerpt":"Java的一些基本语法","text":"Java的一些基本语法 4.流程控制A.顺序结构程序从上往下的顺序执行 B.分支结构if-else &amp; switch-case 12345678910111213141516①if(条件表达式)&#123; &#125;②if(条件表达式)&#123; //执行的语句1; &#125;else&#123; //执行的语句2; &#125;③if(条件表达式1)&#123; //执行的语句1; &#125;else if(条件表达式2)&#123; //执行的语句2; &#125;else if( 条件表达式3)&#123; //执行的语句3; &#125;... &#125;else&#123; //执行的语句; &#125; [注意]&emsp;&emsp;1.一旦满足某个条件表达式, 则进入其执行语句块执行, 执行完毕, 跳出当前的条件判断结构, 不会执行剩下的条件结构语句. &emsp;&emsp;2.如果多个条件表达式之间为“互斥”关系, 多个结构可以上下调换顺序如果多个条件表达式之间为“包含”关系, 要求条件表达式范围小的写在范围大的上面. 123456789switch(变量)&#123; case 值1: //break; case 值2: //break; ... default: break;&#125; [注意]1.变量可以为如下的数据类型:byte short int char 枚举 String(jdk1.7)2.case后只能填写变量的值, 不能写范围.3.default是可以省略的, 并且其位置也是灵活的, 但通常将其放在case语句之后.4.一旦满足某个case语句, 则进入执行其操作, 直至遇到break或者程序终止.5.若要判断的语句的条件满足switch变量的数据类型, 且值不多的情况下, 建议选择switch-case .除此之外, 选择if-else. [例题]从键盘输入三个int类型的数存入三个int变量, 利用if-else实现对三个数的排序, 并输出.[例题]输入一个年月日, 像: 2019/7/20, 输出该天是这一年中的哪一天. C.循环结构格式: 12345678910111213for(①;②;③)&#123; ④&#125;①while(②)&#123; ④ ③&#125;①do&#123; ④ ③&#125;while(②); ①初始化条件②循环条件③迭代部分④循环体 注意 1.不同的循环结构之间可以相互转换&emsp;&emsp; 2.while和do-while的区别; do-while程序至少会执行一次 嵌套循环: 上述循环体嵌套循环体若外层循环执行m次, 内层循环执行n次, 整个程序执行m*n次 . [例题]输出九九乘法表 [例题]输出100内的质数.(两种) 无限循环结构: 123456789101112131415for(;;)&#123; ... if( )&#123; break; &#125; ...&#125;//或者while(true)&#123; ... if( )&#123; break; &#125; ...&#125; 我们往往会在无限循环结构内部提供循环的终止条件, 使用break关键字跳出循环.避免死循环. D.break&amp;continuebreak:使用switch-case结构或者循环结构中在循环结构中, 一旦执行到break, 就跳出当前循环 . continue:使用在循环结构中, 一旦执行到continue, 就跳出当次循环, 继续执行下一次循环. 1234567for(int i = 1;i &lt;= 10;i++)&#123; if(i % 4 == 0)&#123; //break; //程序执行结果:123 continue; //程序执行结果:123567910 &#125; System.out.print(i);&#125; 在嵌套循环中, 使用带标签的break和continue. 123456789101112label:for(int i = 1;i &lt; 5;i++)&#123; for(int j = 1;j &lt;= 10;j++)&#123; if(j % 4 == 0)&#123; //break; //continue; //break label; continue label; &#125; System.out.print(j); &#125; System.out.println();&#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"Java基本语法1","slug":"JavaSE2-1","date":"2019-03-17T03:18:41.000Z","updated":"2019-04-03T04:41:37.523Z","comments":true,"path":"JavaSE2-1.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE2-1.html","excerpt":"一.Java的一些基本语法","text":"一.Java的一些基本语法 1.关键字＆标识符关键字: 被Java语言赋予了特殊含义, 用做专门用途的字符串(单词), 关键字全是小写的 保留字: 以后可能用来作为关键字 标识符: 凡是自己可以起名字的地方都叫标识符 命名规则:&emsp;&emsp;一定要遵守, 不遵守就会报编译的错误 由26个英文字母大小写,0-9, _或 $ 组成 数字不可以开头.不可以使用关键字和保留字, 但能包含关键字和保留字.Java中严格区分大小写, 长度无限制.标识符不能包含空格. 命名规范:&emsp;&emsp;不遵守, 也不会出现编译的错误 包名: 多单词组成时所有字母都小写: xxxyyyzzz类名、接口名: 多单词组成时, 所有单词的首字母大写: XxxYyyZzz变量名、方法名: 多单词组成时, 第一个单词首字母小写, 第二个单词开始每个单词首字母大写: xxxYyyZzz常量名: 所有字母都大写, 多单词时每个单词用下划线连接: XXX_YYY_ZZZ 2.变量 Java中变量按照数据类型来分类: 基本数据类型 vs 引用数据类型(数组 类 接口) 基本数据类型:​ 整型: byte(8 bit,-128~127) short(-32768~32767) int(默认类型,-2^31~2^31-1) long​ 浮点型: float double (默认类型)​ 字符型: char（‘ ’）16 bit 是以十六进制保存的字符,例:char ch = ‘\\u0041’;为’A’​ 布尔类型: boolean (只能取值为true 或false, 不能取null)​ String类型(引用数据类型): 值可以为null数据类型 变量名 = 初始化值;​ 补充: 按照在类中存在的位置的不同: 成员变量 vs 局部变量​ 成员变量在声明时会被默认初始化, 因此可以在声明后直接使用, 而局部变量在使用之前必须先初始化​ 声明: long型常量需后缀”l”或”L”,long lo = 123L;​ float类型变量要后缀”f”或”F”,float f = 12.3F; 2.进制(了解) 十进制 二进制 八进制 十六进制 二进制: 计算机底层都是用二进制来存储、运算. 二进制 与十进制之间的转换.二进制在底层存储: 正数、负数都是以补码的形式存储的.(原码、反码、补码)四种进制间的转换 3.变量的运算: ①自动类型转换: 容量小的数据类型自动转换为容量大的数据类型转换. short s = 12; int i = s + 2; 注意: byte short char之间做运算, 结果为int型! ②强制类型转换: 是①的逆过程.使用“()”实现强转. 3.运算符运算符是一种特殊的符号, 用以表示数据的运算. A.算术运算符:1+ - / % ++ -- + 注意: 1) /: int i = 12; i = i / 5;地板除2) %: 取模, 结果的符号与被模数相同3) 前++: 先+1, 后运算 后++: 先运算, 后+14) +: String字符串与其他数据类型只能做连接运算, 且结果为String类型. 12sysout(\"*\" + '\\t' + '*'); vs sysout('*' + '\\t' + '*');结果为93//sysout为Java的快捷键用法, 先输入sysout, 再按\"Alt + /\", 即可打出System.out.println(); B.赋值运算符:123456789//= += -= *= /= %=int i = 12;i = i * 5;i *= 5;//与上一行代码同样的意思//[特别地]short s = 10;s = s + 5;//报编译的异常，s+5会被默认转化为int类型，再赋值给short会出错s = (short)(s + 5);//强制类型转换便不会异常s += 5;//相当于, s = s + 5, 但两者并不完全等价, 但是结果不会改变s的数据类型. C.比较运算符(关系运算符)1== &gt; &lt; &gt;= &lt;= instanceof [注意] 区分 == 与 = 区别.进行比较运算操作以后,返回一个boolean类型的值(true或false)4&gt;=3 表达的是4 &gt; 3或者 4 = 3.结果是true. if(i &gt; 1 &amp;&amp; i &lt; 10){ } 不能写为: if(1 &lt; i &lt; 10){} D.逻辑运算符(运算符的两端是boolean值)1&amp; &amp;&amp; | || ^ ! [注意]区分&amp;与&amp;&amp;的区别, 以及 | 与 || 的区别 我们使用的时候, 选择 &amp;&amp; , || 短路与、短路或 E.位运算符(两端是数值类型的数据)1&lt;&lt; &gt;&gt; &gt;&gt;&gt;(无符号右移) &amp; | ^(异或) ~(按位取反) [例子] 1.如何交换m = 12和n = 5的值 2.将60转换为十六进制输出. F.三元运算符(条件表达式) ? 表达式1 : 表达式2;1) 既然是运算符, 一定会返回一个结果, 并且结果的数据类型与表达式1, 2的类型一致2) 表达式1与表达式2的数据类型一致.3) 使用三元运算符的, 一定可以转换为if-else. 反之不一定成立.4) ?: 可以嵌套使用例子: 获取两个数的较大值; 获取三个数的最大值. 点击显/隐内容 1234int i = 0, j = 1;int max = (i &gt; j) ? i : j;int k = 2;int max2 = (i &gt; j) ? ((i &gt; k) ? i : k) : (( j &gt; k) ? j : k);","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"JavaSE概述","slug":"JavaSE1-0","date":"2019-03-17T02:38:04.000Z","updated":"2019-04-03T04:40:07.780Z","comments":true,"path":"JavaSE1-0.html","link":"","permalink":"http://crainyday.gitee.io/blog/JavaSE1-0.html","excerpt":"走进Java","text":"走进Java 一.关于Java①关于Java语言, 其实它很简单, 就是我们人类与计算机交流的语言, 就像人类的语言: 英语、汉语……②Java之父: 詹姆斯·高斯林, 他曾说过, C语言是撑起一切的基石, C语言之父: 丹尼斯·里奇③Java语言由类C、C++等衍生出来, 属于完全面向对象的语言④Java的技术体系平台: JavaSE、JavaEE、JavaME 二.关于计算机1.计算机软件软件: 系统软件 and 应用软件 2.人与计算机做交互: 使用计算机语言. 图形化界面(GUI) vs 命令行方式(CLI): dir md rd cd cd.. cd/ del exit echo content &gt;temp.txt3.语言的分类: 第一代: 机器语言; 第二代: 汇编语言; 第三代: 高级语言(面向过程 — 面向对象) 4.java语言的特性: ①面向对象性 ②健壮性 ③跨平台性(write once,run anywhere)—JVM 不同的系统有不同的JVM(Java Virtual Machine即Java虚拟机), 所以要想编写Java程序, 就要在自己的系统上安装JVM等部件. 学习Java, 我们首先要做的, 就是安装JDK环境. 5.安装JDK及配置系统的path环境变量​ 1)傻瓜式安装JDK(提取码: et1y).​ 2)path: window操作系统在执行cmd命令时所要搜寻的路径.​ 我们需要将jdk中bin目录所在的路径: D:\\Program Files\\Java\\jdk1.8.0_131\\bin 保存在path环境变量下.​ 3)测试: 在命令行窗口, 任意的文件目录下, 执行javac.exe 或者java.exe都可以调用成功.​ JDK(Java Development Kit, Java语言的软件开发工具包即Java的SDK, Software Development Kit)​ JDK包含JRE(Java Runtime Environment, Java运行时环境), JRE包含JVM和一些常用的Java库类​ &gt;河床好比操作底层, jdk好比是河水, java应用程序好比是船. 6.如何编写并运行第一个java程序​ [过程]编写—-编译(javac.exe)—-运行(java.exe)1)编写: 每一个java文件都是.java结尾的, 称为源文件[HelloWorld.java], java程序就存在于源文件中 如下, 第一个Java程序: 1234567public class HelloWorld&#123; //程序的主方法，是程序的入口 public static void main(String args[])&#123; //要执行的代码 System.out.println(\"HelloWorld\"); &#125;&#125;//假设这是在桌面上的源文件HelloWorld.java中的源代码, 执行过程如下: ①win+R键, 再输入cmd进入命令行模式, 通过cd desktop命令进入桌面②通过javac HelloWorld.java命令编译源文件生成字节码文件③通过java HelloWorld命令解释运行字节码文件, 之后控制台会输出HelloWorld 注意点：①Java源文件以“java”为扩展名. 源文件的基本组成部分是类(class), 如本例中的HelloWorld类.②一个源文件中最多只能有一个public类, 其它类的个数不限, 如果源文件包含一个public类, 则.java文件名必须与该类名一致.③Java应用程序的执行入口是main()方法, 它有固定的书写格式: public static void main(String[] args){}④Java语言严格区分大小写.⑤Java方法由一条条语句构成, 每个语句以“;”结束.⑥大括号都是成对出现的,缺一不可. 2)编译: 在源文件所在的目录下, 执行javac.exe 源文件名.java;生成一个或多个.class结尾的字节码文件3)运行: 生成的字节码文件通过java.exe解释执行 7.会调试程序中出现的问题 8.注释: ①单行注释 // ②多行注释 / / （多行注释不能够嵌套） ③文档注释 /* / javadoc -d 文件目录名 -author -version 源文件名.java; ​ 其中文档注释是JAVA特有的9.JDK提供的关于旗下所有的包&amp;类的说明文档: API","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/categories/JavaSE/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://crainyday.gitee.io/blog/tags/JavaSE/"}]},{"title":"VPS和shadowsocks搭建VPN","slug":"VPN","date":"2019-03-16T09:06:14.000Z","updated":"2019-04-03T05:17:39.570Z","comments":true,"path":"VPN.html","link":"","permalink":"http://crainyday.gitee.io/blog/VPN.html","excerpt":"用VPS和shadowsocks搭建VPN, 手机端也能用的VPN","text":"用VPS和shadowsocks搭建VPN, 手机端也能用的VPN 1.前期准备 购买一个国外的VPS, 建议CentOS7系统 安装XShell, 用来远程连接你的VPS 安装XFTP, 用来向你的VPS传输文件 2.安装&amp;配置shadowsocks&emsp;&emsp;启动XShell, 输入主机, 点击用户身份验证, 输入用户名:root, 和你的root密码 A.先用shell命令安装pip12345678#有yum可以用yum安装pipyum install python-setuptoolseasy_install pip#没有的用下面命令安装pip, 没有python需要先安装pythonwget https://bootstrap.pypa.io/get-pip.pypython get-pip.py#安装完pip后, 用pip安装shadowsockspip install shadowsocks B.配置VPS上的shadowsocks&emsp;&emsp;启动XFTP, 同XShell连接远程VPS, 将新建的shadowsocks.json文件, 上传到/etc目录下 shadowsocks.json(提取码: 4k4l,下载的话请重命名)文件要用UTF-8编码, 内容如下: 1234567891011&#123; \"server\":\"你的VPSIPv4地址\", \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"port_password\":&#123; \"443\":\"自己随便设置一个连接这个VPN的密码\" &#125;, \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\":false&#125; C.开启shadowsocks服务1234567891011#用以下命令之一关闭防火墙service iptables stopservice firewalld stop#禁止firewall开机启动systemctl disable firewalld.service#加载shadowsocks配置ssserver -c /etc/shadowsocks.json#开启shadowsocks服务ssserver -c /etc/shadowsocks.json -d start#关闭shadowsocks服务ssserver -c /etc/shadowsocks.json -d stop 3.本地配置shadowsocks Android Windows IPhone(百度网盘提取码: lagp, 链接失效请向博主索取) A.Windows配置下载解压文件, 运行exe文件, 如图配置: 右键点击状态栏中的本软件, 再点击”启用系统代理”即开启VPN B.Android配置(IPhone一样)","categories":[],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://crainyday.gitee.io/blog/tags/VPN/"}]},{"title":"Hexo代码一键复制","slug":"copy-code","date":"2019-03-16T07:10:42.000Z","updated":"2019-04-03T04:21:59.331Z","comments":true,"path":"copy-code.html","link":"","permalink":"http://crainyday.gitee.io/blog/copy-code.html","excerpt":"有时候代码块是真的多啊, 添加一个一键复制功能吧","text":"有时候代码块是真的多啊, 添加一个一键复制功能吧 1.需要的JS文件 clipboard.min.js(提取码: p3xj) clipboard-use.js(提取码: sbsk) 将以上js文件放到主题的js文件目录下. clipboard-use.js: 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class=\"btn-copy\" data-clipboard-snippet=\"\"&gt;'; copyHtml += ' &lt;i class=\"fa fa-copy\"&gt;&lt;/i&gt;&lt;span&gt;Copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(\".highlight .code pre\").before(copyHtml); var clipboard = new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); clipboard.on('success', function(e) &#123; //您可以加入成功提示 console.info('Action:', e.action); console.info('Text:', e.text); console.info('Trigger:', e.trigger); success_prompt(COPY_SUCCESS); e.clearSelection(); &#125;); clipboard.on('error', function(e) &#123; //您可以加入失败提示 console.error('Action:', e.action); console.error('Trigger:', e.trigger); fail_prompt(COPY_FAILURE); &#125;); &#125; initCopyCode();&#125;(window, document);/** * 弹出式提示框，默认1.5秒自动消失 * @param message 提示信息 * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info * @param time 消失时间 */var prompt = function (message, style, time)&#123; style = (style === undefined) ? 'alert-success' : style; time = (time === undefined) ? 1500 : time*1000; $('&lt;div&gt;') .appendTo('body') .addClass('alert ' + style) .html(message) .show() .delay(time) .fadeOut();&#125;;// 成功提示var success_prompt = function(message, time)&#123; prompt(message, 'alert-success', time);&#125;;// 失败提示var fail_prompt = function(message, time)&#123; prompt(message, 'alert-danger', time);&#125;;// 提醒var warning_prompt = function(message, time)&#123; prompt(message, 'alert-warning', time);&#125;;// 信息提示var info_prompt = function(message, time)&#123; prompt(message, 'alert-info', time);&#125;; 2.引入JS文件将JS文件引入的模板footer里, 一定要输入对你自己的src路径 12&lt;script type=\"text/javascript\" src=\"/blog/js/clipboard.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/blog/js/clipboard-use.js\"&gt;&lt;/script&gt; 3.配置样式表将下列代码添加到主题的样式表里, 根据自己的div修改 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125;//复制提示, 成功or失败.alert &#123; display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); z-index: 99999; text-align: center; padding: 24px 36px; border-radius: @border_radius_code_block; box-shadow: @boxshadow_card_normal; font-family: @fontfamily_base; font-weight: bold; font-size: @fontsize_base; &amp;.alert-success &#123; color: #ffffff; background-color: #1BC3FB; border-color: #d6e9c6; &#125; &amp;.alert-info &#123; color: #31708f; background-color: #d9edf7; border-color: #bce8f1; &#125; &amp;.alert-warning &#123; color: #8a6d3b; background-color: #fcf8e3; border-color: #faebcc; &#125; &amp;.alert-danger &#123; color: #a94442; background-color: #f2dede; border-color: #ebccd1; &#125;&#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://crainyday.gitee.io/blog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://crainyday.gitee.io/blog/tags/Hexo/"}]},{"title":"Hexo为主题添加代码隐藏功能","slug":"hide-code","date":"2019-03-16T06:30:04.000Z","updated":"2019-04-03T04:29:05.386Z","comments":true,"path":"hide-code.html","link":"","permalink":"http://crainyday.gitee.io/blog/hide-code.html","excerpt":"写博客有时候需要添加的代码真的很多, 而我们又不想让它显示在网页上. 添加一个代码隐藏功能吧!","text":"写博客有时候需要添加的代码真的很多, 而我们又不想让它显示在网页上. 添加一个代码隐藏功能吧! &emsp;&emsp;首先, 你要明白不论添加一些什么功能, 无非是添加一些js插件实现. 1.自定义内置标签&emsp;&emsp;通过查看自定义标签的API, 发现主题自带标签脚本都会存放在themes/xxx/scripts/tag/xxx.js中 首先, 我们要注册一个自己的代码隐藏内置标签fold. 新建fold.js(提取码: 0khu)文件, 路径(没有相应目录的自建)如图: 内容:点击显/隐内容 12345678/* global hexo */// Usage: &#123;% fold ???? %&#125; Something &#123;% endfold %&#125;function fold (args, content) &#123; var text = args[0]; if(!text) text = \"点击显/隐\"; return '&lt;div&gt;&lt;div class=\"fold_hider\"&gt;&lt;div class=\"close hider_title\"&gt;' + text + '&lt;/div&gt;&lt;/div&gt;&lt;div class=\"fold\"&gt;\\n' + hexo.render.renderSync(&#123;text: content, engine: 'markdown'&#125;) + '\\n&lt;/div&gt;&lt;/div&gt;';&#125;hexo.extend.tag.register('fold', fold, &#123;ends: true&#125;); 2.消除渲染undefined问题在scripts目录下添加一个tags.js(提取码: giom)文件, 内容: 12345678910111213141516171819202122/*修复在 fold 标签里写 ```代码块```，最终会被渲染成 undefined 的问题*/const rEscapeContent = /&lt;escape(?:[^&gt;]*)&gt;([\\s\\S]*?)&lt;\\/escape&gt;/g;const placeholder = '\\uFFFD';const rPlaceholder = /(?:&lt;|&amp;lt;)\\!--\\uFFFD(\\d+)--(?:&gt;|&amp;gt;)/g;const cache = [];function escapeContent(str) &#123; return '&lt;!--' + placeholder + (cache.push(str) - 1) + '--&gt;';&#125;hexo.extend.filter.register('before_post_render', function(data) &#123; data.content = data.content.replace(rEscapeContent, function(match, content) &#123; return escapeContent(content); &#125;); return data;&#125;);hexo.extend.filter.register('after_post_render', function(data) &#123; data.content = data.content.replace(rPlaceholder, function() &#123; return cache[arguments[1]]; &#125;); return data;&#125;); 3.设置默认折叠代码将下列代码复制到你的主题的JS(每个页面都会加载的JS)文件中 12345678$(document).ready(function()&#123; $(document).on('click', '.fold_hider', function()&#123; $('&gt;.fold', this.parentNode).slideToggle(); $('&gt;:first', this).toggleClass('open'); &#125;); //默认情况下折叠 $(\"div.fold\").css(\"display\", \"none\");&#125;); 4.配置fold显示样式将下述代码复制到你的主题样式文件里: 12345678910.hider_title&#123; font-family: \"Microsoft Yahei\"; cursor: pointer;&#125;.close:after&#123; content: \"▼\";&#125;.open:after&#123; content: \"▲\";&#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://crainyday.gitee.io/blog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://crainyday.gitee.io/blog/tags/Hexo/"}]},{"title":"利用Hexo和Gitee搭建一个静态博客","slug":"Hexo","date":"2019-03-16T02:38:04.000Z","updated":"2019-04-03T04:24:55.366Z","comments":true,"path":"Hexo.html","link":"","permalink":"http://crainyday.gitee.io/blog/Hexo.html","excerpt":"没有服务器也可以哦 用github pages或gitee pages(中国的github)与Hexo搭建免费的个人博客","text":"没有服务器也可以哦 用github pages或gitee pages(中国的github)与Hexo搭建免费的个人博客 本文主要讲解gitee, github上搭建同理 1.前期准备 有一个gitee或github账号, 没有就先去注册一个 本地安装node.js &amp; npm, 配置教程 本地安装git for windows 2.创建gitee仓库开启pages服务&emsp;&emsp;先创建仓库, 点击右上角的加号; 再进入仓库, 开启pages服务, 如图: 注意: !!!每次用hexo d提交代码后, 都需要更新一下pages服务!!! 3.Hexo的使用&emsp;&emsp;Hexo是一个很常用的博客发布工具, 支持markdown格式(推荐一款md编译器), 有很多插件和主题 一定要配置好系统的环境变量, 才能用npm和hexo命令 12345678#全程在博客目录下进行, 先新建一个空文件夹(例:f:/blog), 再cd进入#安装hexonpm install hexo-cli -gnpm install hexo-server --save#用hexo新建项目, 生成站点hexo init#清理缓存&amp;&amp;生成项目文件&amp;&amp;本地运行项目hexo clean &amp;&amp; hexo g &amp;&amp; hexo s#需要先安装hexo-server插件 &emsp;&emsp;执行到这里, 如果前面过程中没有错误, 就会在本地成功启用Hexo博客站点, 通过http://localhost:4000/blog访问本地博客站点, 如图: &emsp;&emsp;执行完hexo init命令, 生成的Hexo的目录结构如图: &emsp;&emsp;若想要将本地的博客文件push到gitee仓库, 需要先配置_config.yml全局配置文件, 再进行一下步骤4配置git相关信息, 再执行下列命令: 12345678910#发布项目到远程hexo d#需要hexo-deployer-git插件, 配置完一些git的相关配置才能上传#生成页面hexo new page \"xxx\"#生成文章hexo new \"xxx\"#安装插件npm install xxx --save#卸载插件npm unstall xxx &emsp;&emsp;以上命令既可以用Windows的cmd来完成, 也可以用git bash来完成, 但有的命令cmd执行会有一些问题, 建议全部使用git bash来执行. 之后会提到git bash的使用 根目录_config.yml全局配置文件123456789101112title: CRainyDay&apos;s Blogauthor: CRainyDaylanguage: zh-CN#urlurl: http://crainyday.gitee.io/blog#这里填写gitee pages生成的urlroot: /blog#博客根目录theme: landscape#网站应用的主题名字#与hexo d相关的配置deploy: type: git repo: https://gitee.com/用户名/仓库名.git #你的gitee仓库地址 branch: master 注意: 配置文件中每个 : 后要有一个英文的空格 每个主题相应的目录下也有主题的_config.yml配置文件 4.git的使用1234567891011#需要在你的博客根目录下右键运行Git Bash Heregit config --global user.name \"你的gitee用户名\"git config --global user.email \"你的gitee绑定的邮箱地址\"git initgit remote add origin &lt;你的仓库地址&gt;#以下命令这里用不到, 可以了解一下git clone &lt;想要克隆的项目地址&gt;git pull origin master#拉取代码git add .git commit -m \"提交信息\"git push origin master#提交代码","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://crainyday.gitee.io/blog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://crainyday.gitee.io/blog/tags/Hexo/"},{"name":"Gitee","slug":"Gitee","permalink":"http://crainyday.gitee.io/blog/tags/Gitee/"}]}]}